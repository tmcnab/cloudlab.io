function standardSpeed(a) { if (!a || typeof a === "number" || $.fx.speeds[a]) { return true } if (typeof a === "string" && !$.jqplot.effects.effect[a]) { if (backCompat && $.jqplot.effects[a]) { return false } return true } return false } function _normalizeArguments(a, b, c, d) { if ($.isPlainObject(a)) { return a } a = { effect: a }; if (b === undefined) { b = {} } if ($.isFunction(b)) { d = b; c = null; b = {} } if ($.type(b) === "number" || $.fx.speeds[b]) { d = c; c = b; b = {} } if ($.isFunction(c)) { d = c; c = null } if (b) { $.extend(a, b) } c = c || b.duration; a.duration = $.fx.off ? 0 : typeof c === "number" ? c : c in $.fx.speeds ? $.fx.speeds[c] : $.fx.speeds._default; a.complete = d || b.complete; return a } (function (a) { function $(a) { if (a === null) return "[object Null]"; return Object.prototype.toString.call(a) } function Z(a, b) { if (b.indexOf) { return b.indexOf(a) } for (var c = 0, d = b.length; c < d; c++) { if (b[c] === a) { return c } } return -1 } function I(a, b) { if (b == null || typeof b != "object") { return } for (var c in b) { if (c == "highlightColors") { a[c] = H(b[c]) } if (b[c] != null && typeof b[c] == "object") { if (!a.hasOwnProperty(c)) { a[c] = {} } I(a[c], b[c]) } else { a[c] = b[c] } } } function H(a) { if (a == null || typeof a != "object") { return a } var b = new a.constructor; for (var c in a) { b[c] = H(a[c]) } return b } function G(a, b) { return a - b } function F(a, b) { var c = Math.floor(Math.log(a) / Math.LN10); var d = Math.pow(10, c); var e = a / d; var f; var g; e = e / b; if (e <= .38) { g = .1 } else if (e <= 1.6) { g = .2 } else if (e <= 4) { g = .5 } else if (e <= 8) { g = 1 } else if (e <= 16) { g = 2 } else { g = 5 } f = g * d; return [f, g, d] } function E(a, b) { b = b || 1; var c = Math.floor(Math.log(a) / Math.LN10); var d = Math.pow(10, c); var e = a / d; var f; e = e / b; if (e <= .38) { f = .1 } else if (e <= 1.6) { f = .2 } else if (e <= 4) { f = .5 } else if (e <= 8) { f = 1 } else if (e <= 16) { f = 2 } else { f = 5 } return f * d } function D(a, b) { b = b || 7; var c = a / (b - 1); var d = Math.pow(10, Math.floor(Math.log(c) / Math.LN10)); var e = c / d; var f; if (d < 1) { if (e > 5) { f = 10 * d } else if (e > 2) { f = 5 * d } else if (e > 1) { f = 2 * d } else { f = d } } else { if (e > 5) { f = 10 * d } else if (e > 4) { f = 5 * d } else if (e > 3) { f = 4 * d } else if (e > 2) { f = 3 * d } else if (e > 1) { f = 2 * d } else { f = d } } return f } function C(b, c, d) { var e = Math.floor(d / 2); var f = Math.ceil(d * 1.5); var g = Number.MAX_VALUE; var h = c - b; var i; var j; var k; var l; var m; var n = a.jqplot.getSignificantFigures; var o; var p; for (var q = 0, r = f - e + 1; q < r; q++) { o = e + q; i = h / (o - 1); j = n(i); i = Math.abs(d - o) + j.digitsRight; if (i < g) { g = i; k = o; p = j.digitsRight } else if (i === g) { if (j.digitsRight < p) { k = o; p = j.digitsRight } } } l = Math.max(p, Math.max(n(b).digitsRight, n(c).digitsRight)); if (l === 0) { m = "%d" } else { m = "%." + l + "f" } i = h / (k - 1); return [b, c, k, m, i] } function y(a) { var b; a = Math.abs(a); if (a >= 10) { b = "%d" } else if (a > 1) { if (a === parseInt(a, 10)) { b = "%d" } else { b = "%.1f" } } else { var c = -Math.floor(Math.log(a) / Math.LN10); b = "%." + c + "f" } return b } function x(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; var g = e.plugins.lineRenderer.highlightedSeriesIndex; if (g != null && e.series[g].highlightMouseDown) { s(e) } var h = jQuery.Event("jqplotDataRightClick"); h.pageX = a.pageX; h.pageY = a.pageY; e.target.trigger(h, f) } } function w(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; var g = jQuery.Event("jqplotDataClick"); g.pageX = a.pageX; g.pageY = a.pageY; e.target.trigger(g, f) } } function v(a, b, c, d, e) { var f = e.plugins.lineRenderer.highlightedSeriesIndex; if (f != null && e.series[f].highlightMouseDown) { s(e) } } function u(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; if (e.series[f[0]].highlightMouseDown && !(f[0] == e.plugins.lineRenderer.highlightedSeriesIndex)) { var g = jQuery.Event("jqplotDataHighlight"); g.pageX = a.pageX; g.pageY = a.pageY; e.target.trigger(g, f); r(e, d.seriesIndex, d.pointIndex, d.points) } } else if (d == null) { s(e) } } function t(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; var g = jQuery.Event("jqplotDataMouseOver"); g.pageX = a.pageX; g.pageY = a.pageY; e.target.trigger(g, f); if (e.series[f[0]].highlightMouseOver && !(f[0] == e.plugins.lineRenderer.highlightedSeriesIndex)) { var h = jQuery.Event("jqplotDataHighlight"); h.pageX = a.pageX; h.pageY = a.pageY; e.target.trigger(h, f); r(e, d.seriesIndex, d.pointIndex, d.points) } } else if (d == null) { s(e) } } function s(a) { var b = a.plugins.lineRenderer.highlightCanvas; b._ctx.clearRect(0, 0, b._ctx.canvas.width, b._ctx.canvas.height); for (var c = 0; c < a.series.length; c++) { a.series[c]._highlightedPoint = null } a.plugins.lineRenderer.highlightedSeriesIndex = null; a.target.trigger("jqplotDataUnhighlight"); b = null } function r(a, b, c, d) { var e = a.series[b]; var f = a.plugins.lineRenderer.highlightCanvas; f._ctx.clearRect(0, 0, f._ctx.canvas.width, f._ctx.canvas.height); e._highlightedPoint = c; a.plugins.lineRenderer.highlightedSeriesIndex = b; var g = { fillStyle: e.highlightColor }; if (e.type === "line" && e.renderer.bands.show) { g.fill = true; g.closePath = true } e.renderer.shapeRenderer.draw(f._ctx, d, g); f = null } function q() { if (this.plugins.lineRenderer && this.plugins.lineRenderer.highlightCanvas) { this.plugins.lineRenderer.highlightCanvas.resetCanvas(); this.plugins.lineRenderer.highlightCanvas = null } this.plugins.lineRenderer.highlightedSeriesIndex = null; this.plugins.lineRenderer.highlightCanvas = new a.jqplot.GenericCanvas; this.eventCanvas._elem.before(this.plugins.lineRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-lineRenderer-highlight-canvas", this._plotDimensions, this)); this.plugins.lineRenderer.highlightCanvas.setContext(); this.eventCanvas._elem.bind("mouseleave", { plot: this }, function (a) { s(a.data.plot) }) } function p(b, c, d) { for (var e = 0; e < this.series.length; e++) { if (this.series[e].renderer.constructor == a.jqplot.LineRenderer) { if (this.series[e].highlightMouseOver) { this.series[e].highlightMouseDown = false } } } } function o(a) { var b = this.renderer.smooth; var c = this.renderer.tension; var d = this.canvas.getWidth(); var e = this._xaxis.series_p2u; var f = this._yaxis.series_p2u; var g = null; var h = null; var i = null; var j = null; var l = null; var n = null; var o = null; var p = null; var q, r, s, t, u, v; var w, x, y, z; var A, B, C; var D = []; var E = []; var F = a.length / d; var G, H, I, J, K; var L = []; var M = []; if (!isNaN(parseFloat(b))) { g = parseFloat(b) } else { g = k(F, .5) } if (!isNaN(parseFloat(c))) { c = parseFloat(c) } for (var N = 0, O = a.length - 1; N < O; N++) { if (c === null) { n = Math.abs((a[N + 1][1] - a[N][1]) / (a[N + 1][0] - a[N][0])); G = .3; H = .6; I = (H - G) / 2; J = 2.5; K = -1.4; p = n / J + K; j = I * m(p) - I * m(K) + G; if (N > 0) { o = Math.abs((a[N][1] - a[N - 1][1]) / (a[N][0] - a[N - 1][0])) } p = o / J + K; l = I * m(p) - I * m(K) + G; i = (j + l) / 2 } else { i = c } for (q = 0; q < g; q++) { r = q / g; s = (1 + 2 * r) * Math.pow(1 - r, 2); t = r * Math.pow(1 - r, 2); u = Math.pow(r, 2) * (3 - 2 * r); v = Math.pow(r, 2) * (r - 1); if (a[N - 1]) { w = i * (a[N + 1][0] - a[N - 1][0]); x = i * (a[N + 1][1] - a[N - 1][1]) } else { w = i * (a[N + 1][0] - a[N][0]); x = i * (a[N + 1][1] - a[N][1]) } if (a[N + 2]) { y = i * (a[N + 2][0] - a[N][0]); z = i * (a[N + 2][1] - a[N][1]) } else { y = i * (a[N + 1][0] - a[N][0]); z = i * (a[N + 1][1] - a[N][1]) } A = s * a[N][0] + u * a[N + 1][0] + t * w + v * y; B = s * a[N][1] + u * a[N + 1][1] + t * x + v * z; C = [A, B]; L.push(C); M.push([e(A), f(B)]) } } L.push(a[O]); M.push([e(a[O][0]), f(a[O][1])]); return [L, M] } function n(a) { function p(a, b) { if (a - b == 0) { return Math.pow(10, 10) } else { return a - b } } var b = this.renderer.smooth; var c = this.canvas.getWidth(); var d = this._xaxis.series_p2u; var e = this._yaxis.series_p2u; var f = null; var g = null; var h = a.length / c; var i = []; var j = []; if (!isNaN(parseFloat(b))) { f = parseFloat(b) } else { f = k(h, .5) } var l = []; var m = []; for (var n = 0, o = a.length; n < o; n++) { l.push(a[n][1]); m.push(a[n][0]) } var q, r, s, t; var u = a.length - 1; for (var v = 1, w = a.length; v < w; v++) { var x = []; var y = []; for (var z = 0; z < 2; z++) { var n = v - 1 + z; if (n == 0 || n == u) { x[z] = Math.pow(10, 10) } else if (l[n + 1] - l[n] == 0 || l[n] - l[n - 1] == 0) { x[z] = 0 } else if ((m[n + 1] - m[n]) / (l[n + 1] - l[n]) + (m[n] - m[n - 1]) / (l[n] - l[n - 1]) == 0) { x[z] = 0 } else if ((l[n + 1] - l[n]) * (l[n] - l[n - 1]) < 0) { x[z] = 0 } else { x[z] = 2 / (p(m[n + 1], m[n]) / (l[n + 1] - l[n]) + p(m[n], m[n - 1]) / (l[n] - l[n - 1])) } } if (v == 1) { x[0] = 3 / 2 * (l[1] - l[0]) / p(m[1], m[0]) - x[1] / 2 } else if (v == u) { x[1] = 3 / 2 * (l[u] - l[u - 1]) / p(m[u], m[u - 1]) - x[0] / 2 } y[0] = -2 * (x[1] + 2 * x[0]) / p(m[v], m[v - 1]) + 6 * (l[v] - l[v - 1]) / Math.pow(p(m[v], m[v - 1]), 2); y[1] = 2 * (2 * x[1] + x[0]) / p(m[v], m[v - 1]) - 6 * (l[v] - l[v - 1]) / Math.pow(p(m[v], m[v - 1]), 2); t = 1 / 6 * (y[1] - y[0]) / p(m[v], m[v - 1]); s = 1 / 2 * (m[v] * y[0] - m[v - 1] * y[1]) / p(m[v], m[v - 1]); r = (l[v] - l[v - 1] - s * (Math.pow(m[v], 2) - Math.pow(m[v - 1], 2)) - t * (Math.pow(m[v], 3) - Math.pow(m[v - 1], 3))) / p(m[v], m[v - 1]); q = l[v - 1] - r * m[v - 1] - s * Math.pow(m[v - 1], 2) - t * Math.pow(m[v - 1], 3); var A = (m[v] - m[v - 1]) / f; var B, C; for (var z = 0, o = f; z < o; z++) { B = []; C = m[v - 1] + z * A; B.push(C); B.push(q + r * C + s * Math.pow(C, 2) + t * Math.pow(C, 3)); i.push(B); j.push([d(B[0]), e(B[1])]) } } i.push(a[n]); j.push([d(a[n][0]), e(a[n][1])]); return [i, j] } function m(a) { var b = (Math.exp(2 * a) - 1) / (Math.exp(2 * a) + 1); return b } function l(a, b) { var c = Math.sqrt(Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2)); return 5.7648 * Math.log(c) + 7.4456 } function k(a, b) { return (3.4182054 + b) * Math.pow(a, -.3534992) } function i() { function m(b, c) { var d = c.series; var e, f, g, h, i, j, k, l, m, n, o, p; var q, r, s, t, u, v; var w, x; for (g = c.seriesStack.length - 1; g >= 0; g--) { e = c.seriesStack[g]; h = d[e]; switch (h.renderer.constructor) { case a.jqplot.BarRenderer: case a.jqplot.PyramidRenderer: j = b.x; k = b.y; for (f = 0; f < h._barPoints.length; f++) { u = h._barPoints[f]; s = h.gridData[f]; if (j > u[0][0] && j < u[2][0] && k > u[2][1] && k < u[0][1]) { return { seriesIndex: h.index, pointIndex: f, gridData: s, data: h.data[f], points: h._barPoints[f]} } } break; case a.jqplot.DonutRenderer: n = h.startAngle / 180 * Math.PI; j = b.x - h._center[0]; k = b.y - h._center[1]; i = Math.sqrt(Math.pow(j, 2) + Math.pow(k, 2)); if (j > 0 && -k >= 0) { l = 2 * Math.PI - Math.atan(-k / j) } else if (j > 0 && -k < 0) { l = -Math.atan(-k / j) } else if (j < 0) { l = Math.PI - Math.atan(-k / j) } else if (j == 0 && -k > 0) { l = 3 * Math.PI / 2 } else if (j == 0 && -k < 0) { l = Math.PI / 2 } else if (j == 0 && k == 0) { l = 0 } if (n) { l -= n; if (l < 0) { l += 2 * Math.PI } else if (l > 2 * Math.PI) { l -= 2 * Math.PI } } m = h.sliceMargin / 180 * Math.PI; if (i < h._radius && i > h._innerRadius) { for (f = 0; f < h.gridData.length; f++) { o = f > 0 ? h.gridData[f - 1][1] + m : m; p = h.gridData[f][1]; if (l > o && l < p) { return { seriesIndex: h.index, pointIndex: f, gridData: h.gridData[f], data: h.data[f]} } } } break; case a.jqplot.PieRenderer: n = h.startAngle / 180 * Math.PI; j = b.x - h._center[0]; k = b.y - h._center[1]; i = Math.sqrt(Math.pow(j, 2) + Math.pow(k, 2)); if (j > 0 && -k >= 0) { l = 2 * Math.PI - Math.atan(-k / j) } else if (j > 0 && -k < 0) { l = -Math.atan(-k / j) } else if (j < 0) { l = Math.PI - Math.atan(-k / j) } else if (j == 0 && -k > 0) { l = 3 * Math.PI / 2 } else if (j == 0 && -k < 0) { l = Math.PI / 2 } else if (j == 0 && k == 0) { l = 0 } if (n) { l -= n; if (l < 0) { l += 2 * Math.PI } else if (l > 2 * Math.PI) { l -= 2 * Math.PI } } m = h.sliceMargin / 180 * Math.PI; if (i < h._radius) { for (f = 0; f < h.gridData.length; f++) { o = f > 0 ? h.gridData[f - 1][1] + m : m; p = h.gridData[f][1]; if (l > o && l < p) { return { seriesIndex: h.index, pointIndex: f, gridData: h.gridData[f], data: h.data[f]} } } } break; case a.jqplot.BubbleRenderer: j = b.x; k = b.y; var y = null; if (h.show) { for (var f = 0; f < h.gridData.length; f++) { s = h.gridData[f]; r = Math.sqrt((j - s[0]) * (j - s[0]) + (k - s[1]) * (k - s[1])); if (r <= s[2] && (r <= q || q == null)) { q = r; y = { seriesIndex: e, pointIndex: f, gridData: s, data: h.data[f]} } } if (y != null) { return y } } break; case a.jqplot.FunnelRenderer: j = b.x; k = b.y; var z = h._vertices, A = z[0], B = z[z.length - 1], C, D, E; function F(a, b, c) { var d = (b[1] - c[1]) / (b[0] - c[0]); var e = b[1] - d * b[0]; var f = a + b[1]; return [(f - e) / d, f] } C = F(k, A[0], B[3]); D = F(k, A[1], B[2]); for (f = 0; f < z.length; f++) { E = z[f]; if (k >= E[0][1] && k <= E[3][1] && j >= C[0] && j <= D[0]) { return { seriesIndex: h.index, pointIndex: f, gridData: null, data: h.data[f]} } } break; case a.jqplot.LineRenderer: j = b.x; k = b.y; i = h.renderer; if (h.show) { if ((h.fill || h.renderer.bands.show && h.renderer.bands.fill) && (!c.plugins.highlighter || !c.plugins.highlighter.show)) { var G = false; if (j > h._boundingBox[0][0] && j < h._boundingBox[1][0] && k > h._boundingBox[1][1] && k < h._boundingBox[0][1]) { var H = h._areaPoints.length; var I; var f = H - 1; for (var I = 0; I < H; I++) { var J = [h._areaPoints[I][0], h._areaPoints[I][1]]; var K = [h._areaPoints[f][0], h._areaPoints[f][1]]; if (J[1] < k && K[1] >= k || K[1] < k && J[1] >= k) { if (J[0] + (k - J[1]) / (K[1] - J[1]) * (K[0] - J[0]) < j) { G = !G } } f = I } } if (G) { return { seriesIndex: e, pointIndex: null, gridData: h.gridData, data: h.data, points: h._areaPoints} } break } else { x = h.markerRenderer.size / 2 + h.neighborThreshold; w = x > 0 ? x : 0; for (var f = 0; f < h.gridData.length; f++) { s = h.gridData[f]; if (i.constructor == a.jqplot.OHLCRenderer) { if (i.candleStick) { var L = h._yaxis.series_u2p; if (j >= s[0] - i._bodyWidth / 2 && j <= s[0] + i._bodyWidth / 2 && k >= L(h.data[f][2]) && k <= L(h.data[f][3])) { return { seriesIndex: e, pointIndex: f, gridData: s, data: h.data[f]} } } else if (!i.hlc) { var L = h._yaxis.series_u2p; if (j >= s[0] - i._tickLength && j <= s[0] + i._tickLength && k >= L(h.data[f][2]) && k <= L(h.data[f][3])) { return { seriesIndex: e, pointIndex: f, gridData: s, data: h.data[f]} } } else { var L = h._yaxis.series_u2p; if (j >= s[0] - i._tickLength && j <= s[0] + i._tickLength && k >= L(h.data[f][1]) && k <= L(h.data[f][2])) { return { seriesIndex: e, pointIndex: f, gridData: s, data: h.data[f]} } } } else if (s[0] != null && s[1] != null) { r = Math.sqrt((j - s[0]) * (j - s[0]) + (k - s[1]) * (k - s[1])); if (r <= w && (r <= q || q == null)) { q = r; return { seriesIndex: e, pointIndex: f, gridData: s, data: h.data[f]} } } } } } break; default: j = b.x; k = b.y; i = h.renderer; if (h.show) { x = h.markerRenderer.size / 2 + h.neighborThreshold; w = x > 0 ? x : 0; for (var f = 0; f < h.gridData.length; f++) { s = h.gridData[f]; if (i.constructor == a.jqplot.OHLCRenderer) { if (i.candleStick) { var L = h._yaxis.series_u2p; if (j >= s[0] - i._bodyWidth / 2 && j <= s[0] + i._bodyWidth / 2 && k >= L(h.data[f][2]) && k <= L(h.data[f][3])) { return { seriesIndex: e, pointIndex: f, gridData: s, data: h.data[f]} } } else if (!i.hlc) { var L = h._yaxis.series_u2p; if (j >= s[0] - i._tickLength && j <= s[0] + i._tickLength && k >= L(h.data[f][2]) && k <= L(h.data[f][3])) { return { seriesIndex: e, pointIndex: f, gridData: s, data: h.data[f]} } } else { var L = h._yaxis.series_u2p; if (j >= s[0] - i._tickLength && j <= s[0] + i._tickLength && k >= L(h.data[f][1]) && k <= L(h.data[f][2])) { return { seriesIndex: e, pointIndex: f, gridData: s, data: h.data[f]} } } } else { r = Math.sqrt((j - s[0]) * (j - s[0]) + (k - s[1]) * (k - s[1])); if (r <= w && (r <= q || q == null)) { q = r; return { seriesIndex: e, pointIndex: f, gridData: s, data: h.data[f]} } } } } break } } return null } function l(a) { var b = a.data.plot; var c = b.eventCanvas._elem.offset(); var d = { x: a.pageX - c.left, y: a.pageY - c.top }; var e = { xaxis: null, yaxis: null, x2axis: null, y2axis: null, y3axis: null, y4axis: null, y5axis: null, y6axis: null, y7axis: null, y8axis: null, y9axis: null, yMidAxis: null }; var f = ["xaxis", "yaxis", "x2axis", "y2axis", "y3axis", "y4axis", "y5axis", "y6axis", "y7axis", "y8axis", "y9axis", "yMidAxis"]; var g = b.axes; var h, i; for (h = 11; h > 0; h--) { i = f[h - 1]; if (g[i].show) { e[i] = g[i].series_p2u(d[i.charAt(0)]) } } return { offsets: c, gridPos: d, dataPos: e} } function k(a) { var b, c, d, e, f; for (var g = 0; g < a.length; g++) { var h; var i = [a[g].data, a[g]._stackData, a[g]._plotData, a[g]._prevPlotData]; for (var j = 0; j < 4; j++) { h = true; b = i[j]; if (a[g]._stackAxis == "x") { for (var k = 0; k < b.length; k++) { if (typeof b[k][1] != "number") { h = false; break } } if (h) { b.sort(function (a, b) { return a[1] - b[1] }) } } else { for (var k = 0; k < b.length; k++) { if (typeof b[k][0] != "number") { h = false; break } } if (h) { b.sort(function (a, b) { return a[0] - b[0] }) } } } } } this.animate = false; this.animateReplot = false; this.axes = { xaxis: new c("xaxis"), yaxis: new c("yaxis"), x2axis: new c("x2axis"), y2axis: new c("y2axis"), y3axis: new c("y3axis"), y4axis: new c("y4axis"), y5axis: new c("y5axis"), y6axis: new c("y6axis"), y7axis: new c("y7axis"), y8axis: new c("y8axis"), y9axis: new c("y9axis"), yMidAxis: new c("yMidAxis") }; this.baseCanvas = new a.jqplot.GenericCanvas; this.captureRightClick = false; this.data = []; this.dataRenderer; this.dataRendererOptions; this.defaults = { axesDefaults: {}, axes: { xaxis: {}, yaxis: {}, x2axis: {}, y2axis: {}, y3axis: {}, y4axis: {}, y5axis: {}, y6axis: {}, y7axis: {}, y8axis: {}, y9axis: {}, yMidAxis: {} }, seriesDefaults: {}, series: [] }; this.defaultAxisStart = 1; this.drawIfHidden = false; this.eventCanvas = new a.jqplot.GenericCanvas; this.fillBetween = { series1: null, series2: null, color: null, baseSeries: 0, fill: true }; this.fontFamily; this.fontSize; this.grid = new g; this.legend = new d; this.negativeSeriesColors = a.jqplot.config.defaultNegativeColors; this.noDataIndicator = { show: false, indicator: "Loading Data...", axes: { xaxis: { min: 0, max: 10, tickInterval: 2, show: true }, yaxis: { min: 0, max: 12, tickInterval: 3, show: true}} }; this.options = {}; this.previousSeriesStack = []; this.plugins = {}; this.series = []; this.seriesStack = []; this.seriesColors = a.jqplot.config.defaultColors; this.sortData = true; this.stackSeries = false; this.syncXTicks = true; this.syncYTicks = true; this.target = null; this.targetId = null; this.textColor; this.title = new e; this._drawCount = 0; this._sumy = 0; this._sumx = 0; this._stackData = []; this._plotData = []; this._width = null; this._height = null; this._plotDimensions = { height: null, width: null }; this._gridPadding = { top: null, right: null, bottom: null, left: null }; this._defaultGridPadding = { top: 10, right: 10, bottom: 23, left: 10 }; this._addDomReference = a.jqplot.config.addDomReference; this.preInitHooks = new a.jqplot.HooksManager; this.postInitHooks = new a.jqplot.HooksManager; this.preParseOptionsHooks = new a.jqplot.HooksManager; this.postParseOptionsHooks = new a.jqplot.HooksManager; this.preDrawHooks = new a.jqplot.HooksManager; this.postDrawHooks = new a.jqplot.HooksManager; this.preDrawSeriesHooks = new a.jqplot.HooksManager; this.postDrawSeriesHooks = new a.jqplot.HooksManager; this.preDrawLegendHooks = new a.jqplot.HooksManager; this.addLegendRowHooks = new a.jqplot.HooksManager; this.preSeriesInitHooks = new a.jqplot.HooksManager; this.postSeriesInitHooks = new a.jqplot.HooksManager; this.preParseSeriesOptionsHooks = new a.jqplot.HooksManager; this.postParseSeriesOptionsHooks = new a.jqplot.HooksManager; this.eventListenerHooks = new a.jqplot.EventListenerManager; this.preDrawSeriesShadowHooks = new a.jqplot.HooksManager; this.postDrawSeriesShadowHooks = new a.jqplot.HooksManager; this.colorGenerator = new a.jqplot.ColorGenerator; this.negativeColorGenerator = new a.jqplot.ColorGenerator; this.canvasManager = new a.jqplot.CanvasManager; this.themeEngine = new a.jqplot.ThemeEngine; var j = 0; this.init = function (b, c, d) { d = d || {}; for (var e = 0; e < a.jqplot.preInitHooks.length; e++) { a.jqplot.preInitHooks[e].call(this, b, c, d) } for (var e = 0; e < this.preInitHooks.hooks.length; e++) { this.preInitHooks.hooks[e].call(this, b, c, d) } this.targetId = "#" + b; this.target = a("#" + b); if (this._addDomReference) { this.target.data("jqplot_plot", this) } this.target.removeClass("jqplot-error"); if (!this.target.get(0)) { throw "No plot target specified" } if (this.target.css("position") == "static") { this.target.css("position", "relative") } if (!this.target.hasClass("jqplot-target")) { this.target.addClass("jqplot-target") } if (!this.target.height()) { var f; if (d && d.height) { f = parseInt(d.height, 10) } else if (this.target.attr("data-height")) { f = parseInt(this.target.attr("data-height"), 10) } else { f = parseInt(a.jqplot.config.defaultHeight, 10) } this._height = f; this.target.css("height", f + "px") } else { this._height = f = this.target.height() } if (!this.target.width()) { var g; if (d && d.width) { g = parseInt(d.width, 10) } else if (this.target.attr("data-width")) { g = parseInt(this.target.attr("data-width"), 10) } else { g = parseInt(a.jqplot.config.defaultWidth, 10) } this._width = g; this.target.css("width", g + "px") } else { this._width = g = this.target.width() } this._plotDimensions.height = this._height; this._plotDimensions.width = this._width; this.grid._plotDimensions = this._plotDimensions; this.title._plotDimensions = this._plotDimensions; this.baseCanvas._plotDimensions = this._plotDimensions; this.eventCanvas._plotDimensions = this._plotDimensions; this.legend._plotDimensions = this._plotDimensions; if (this._height <= 0 || this._width <= 0 || !this._height || !this._width) { throw "Canvas dimension not set" } if (d.dataRenderer && jQuery.isFunction(d.dataRenderer)) { if (d.dataRendererOptions) { this.dataRendererOptions = d.dataRendererOptions } this.dataRenderer = d.dataRenderer; c = this.dataRenderer(c, this, this.dataRendererOptions) } if (d.noDataIndicator && jQuery.isPlainObject(d.noDataIndicator)) { a.extend(true, this.noDataIndicator, d.noDataIndicator) } if (c == null || jQuery.isArray(c) == false || c.length == 0 || jQuery.isArray(c[0]) == false || c[0].length == 0) { if (this.noDataIndicator.show == false) { throw { name: "DataError", message: "No data to plot."} } else { for (var i in this.noDataIndicator.axes) { for (var j in this.noDataIndicator.axes[i]) { this.axes[i][j] = this.noDataIndicator.axes[i][j] } } this.postDrawHooks.add(function () { var b = this.eventCanvas.getHeight(); var c = this.eventCanvas.getWidth(); var d = a('<div class="jqplot-noData-container" style="position:absolute;"></div>'); this.target.append(d); d.height(b); d.width(c); d.css("top", this.eventCanvas._offsets.top); d.css("left", this.eventCanvas._offsets.left); var e = a('<div class="jqplot-noData-contents" style="text-align:center; position:relative; margin-left:auto; margin-right:auto;"></div>'); d.append(e); e.html(this.noDataIndicator.indicator); var f = e.height(); var g = e.width(); e.height(f); e.width(g); e.css("top", (b - f) / 2 + "px") }) } } this.data = c; this.parseOptions(d); if (this.textColor) { this.target.css("color", this.textColor) } if (this.fontFamily) { this.target.css("font-family", this.fontFamily) } if (this.fontSize) { this.target.css("font-size", this.fontSize) } this.title.init(); this.legend.init(); this._sumy = 0; this._sumx = 0; for (var e = 0; e < this.series.length; e++) { this.seriesStack.push(e); this.previousSeriesStack.push(e); this.series[e].shadowCanvas._plotDimensions = this._plotDimensions; this.series[e].canvas._plotDimensions = this._plotDimensions; for (var l = 0; l < a.jqplot.preSeriesInitHooks.length; l++) { a.jqplot.preSeriesInitHooks[l].call(this.series[e], b, c, this.options.seriesDefaults, this.options.series[e], this) } for (var l = 0; l < this.preSeriesInitHooks.hooks.length; l++) { this.preSeriesInitHooks.hooks[l].call(this.series[e], b, c, this.options.seriesDefaults, this.options.series[e], this) } this.populatePlotData(this.series[e], e); this.series[e]._plotDimensions = this._plotDimensions; this.series[e].init(e, this.grid.borderWidth, this); for (var l = 0; l < a.jqplot.postSeriesInitHooks.length; l++) { a.jqplot.postSeriesInitHooks[l].call(this.series[e], b, c, this.options.seriesDefaults, this.options.series[e], this) } for (var l = 0; l < this.postSeriesInitHooks.hooks.length; l++) { this.postSeriesInitHooks.hooks[l].call(this.series[e], b, c, this.options.seriesDefaults, this.options.series[e], this) } this._sumy += this.series[e]._sumy; this._sumx += this.series[e]._sumx } var m; for (var e = 0; e < 12; e++) { m = h[e]; this.axes[m]._plotDimensions = this._plotDimensions; this.axes[m].init(); if (this.axes[m].borderColor == null) { if (m.charAt(0) !== "x" && this.axes[m].useSeriesColor === true && this.axes[m].show) { this.axes[m].borderColor = this.axes[m]._series[0].color } else { this.axes[m].borderColor = this.grid.borderColor } } } if (this.sortData) { k(this.series) } this.grid.init(); this.grid._axes = this.axes; this.legend._series = this.series; for (var e = 0; e < a.jqplot.postInitHooks.length; e++) { a.jqplot.postInitHooks[e].call(this, b, c, d) } for (var e = 0; e < this.postInitHooks.hooks.length; e++) { this.postInitHooks.hooks[e].call(this, b, c, d) } }; this.resetAxesScale = function (a, b) { var c = b || {}; var d = a || this.axes; if (d === true) { d = this.axes } if (jQuery.isArray(d)) { for (var e = 0; e < d.length; e++) { this.axes[d[e]].resetScale(c[d[e]]) } } else if (typeof d === "object") { for (var f in d) { this.axes[f].resetScale(c[f]) } } }; this.reInitialize = function () { this._height = this.target.height(); this._width = this.target.width(); if (this._height <= 0 || this._width <= 0 || !this._height || !this._width) { throw "Target dimension not set" } this._plotDimensions.height = this._height; this._plotDimensions.width = this._width; this.grid._plotDimensions = this._plotDimensions; this.title._plotDimensions = this._plotDimensions; this.baseCanvas._plotDimensions = this._plotDimensions; this.eventCanvas._plotDimensions = this._plotDimensions; this.legend._plotDimensions = this._plotDimensions; for (var c in this.axes) { this.axes[c]._plotWidth = this._width; this.axes[c]._plotHeight = this._height } this.title._plotWidth = this._width; if (this.textColor) { this.target.css("color", this.textColor) } if (this.fontFamily) { this.target.css("font-family", this.fontFamily) } if (this.fontSize) { this.target.css("font-size", this.fontSize) } this._sumy = 0; this._sumx = 0; for (var d = 0; d < this.series.length; d++) { this.populatePlotData(this.series[d], d); if (this.series[d]._type === "line" && this.series[d].renderer.bands.show) { this.series[d].renderer.initBands.call(this.series[d], this.series[d].renderer.options, this) } this.series[d]._plotDimensions = this._plotDimensions; this.series[d].canvas._plotDimensions = this._plotDimensions; this._sumy += this.series[d]._sumy; this._sumx += this.series[d]._sumx } var e; for (var f = 0; f < 12; f++) { e = h[f]; var g = this.axes[e]._ticks; for (var d = 0; d < g.length; d++) { var i = g[d]._elem; if (i) { if (a.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== b) { window.G_vmlCanvasManager.uninitElement(i.get(0)) } i.emptyForce(); i = null; g._elem = null } } g = null; this.axes[e]._plotDimensions = this._plotDimensions; this.axes[e]._ticks = [] } if (this.sortData) { k(this.series) } this.grid._axes = this.axes; this.legend._series = this.series }; this.populatePlotData = function (b, c) { this._plotData = []; this._stackData = []; b._stackData = []; b._plotData = []; var d = { x: [], y: [] }; if (this.stackSeries && !b.disableStack) { b._stack = true; var e = b._stackAxis == "x" ? 0 : 1; var f = e ? 0 : 1; var g = a.extend(true, [], b.data); var h = a.extend(true, [], b.data); for (var i = 0; i < c; i++) { var j = this.series[i].data; for (var k = 0; k < j.length; k++) { g[k][0] += j[k][0]; g[k][1] += j[k][1]; h[k][e] += j[k][e] } } for (var l = 0; l < h.length; l++) { d.x.push(h[l][0]); d.y.push(h[l][1]) } this._plotData.push(h); this._stackData.push(g); b._stackData = g; b._plotData = h; b._plotValues = d } else { for (var l = 0; l < b.data.length; l++) { d.x.push(b.data[l][0]); d.y.push(b.data[l][1]) } this._stackData.push(b.data); this.series[c]._stackData = b.data; this._plotData.push(b.data); b._plotData = b.data; b._plotValues = d } if (c > 0) { b._prevPlotData = this.series[c - 1]._plotData } b._sumy = 0; b._sumx = 0; for (l = b.data.length - 1; l > -1; l--) { b._sumy += b.data[l][1]; b._sumx += b.data[l][0] } }; this.getNextSeriesColor = function (a) { var b = 0; var c = a.seriesColors; return function () { if (b < c.length) { return c[b++] } else { b = 0; return c[b++] } } } (this); this.parseOptions = function (b) { for (var c = 0; c < this.preParseOptionsHooks.hooks.length; c++) { this.preParseOptionsHooks.hooks[c].call(this, b) } for (var c = 0; c < a.jqplot.preParseOptionsHooks.length; c++) { a.jqplot.preParseOptionsHooks[c].call(this, b) } this.options = a.extend(true, {}, this.defaults, b); var d = this.options; this.animate = d.animate; this.animateReplot = d.animateReplot; this.stackSeries = d.stackSeries; if (a.isPlainObject(d.fillBetween)) { var e = ["series1", "series2", "color", "baseSeries", "fill"], g; for (var c = 0, i = e.length; c < i; c++) { g = e[c]; if (d.fillBetween[g] != null) { this.fillBetween[g] = d.fillBetween[g] } } } if (d.seriesColors) { this.seriesColors = d.seriesColors } if (d.negativeSeriesColors) { this.negativeSeriesColors = d.negativeSeriesColors } if (d.captureRightClick) { this.captureRightClick = d.captureRightClick } this.defaultAxisStart = b && b.defaultAxisStart != null ? b.defaultAxisStart : this.defaultAxisStart; this.colorGenerator.setColors(this.seriesColors); this.negativeColorGenerator.setColors(this.negativeSeriesColors); a.extend(true, this._gridPadding, d.gridPadding); this.sortData = d.sortData != null ? d.sortData : this.sortData; for (var c = 0; c < 12; c++) { var j = h[c]; var k = this.axes[j]; k._options = a.extend(true, {}, d.axesDefaults, d.axes[j]); a.extend(true, k, d.axesDefaults, d.axes[j]); k._plotWidth = this._width; k._plotHeight = this._height } var l = function (b, c, d) { var e = []; var f; c = c || "vertical"; if (!jQuery.isArray(b[0])) { for (f = 0; f < b.length; f++) { if (c == "vertical") { e.push([d + f, b[f]]) } else { e.push([b[f], d + f]) } } } else { a.extend(true, e, b) } return e }; var m = 0; for (var c = 0; c < this.data.length; c++) { var e = new f; for (var n = 0; n < a.jqplot.preParseSeriesOptionsHooks.length; n++) { a.jqplot.preParseSeriesOptionsHooks[n].call(e, this.options.seriesDefaults, this.options.series[c]) } for (var n = 0; n < this.preParseSeriesOptionsHooks.hooks.length; n++) { this.preParseSeriesOptionsHooks.hooks[n].call(e, this.options.seriesDefaults, this.options.series[c]) } a.extend(true, e, { seriesColors: this.seriesColors, negativeSeriesColors: this.negativeSeriesColors }, this.options.seriesDefaults, this.options.series[c], { rendererOptions: { animation: { show: this.animate}} }); var o = "vertical"; if (e.renderer === a.jqplot.BarRenderer && e.rendererOptions && e.rendererOptions.barDirection == "horizontal" && e.transposeData === true) { o = "horizontal" } e.data = l(this.data[c], o, this.defaultAxisStart); switch (e.xaxis) { case "xaxis": e._xaxis = this.axes.xaxis; break; case "x2axis": e._xaxis = this.axes.x2axis; break; default: break } e._yaxis = this.axes[e.yaxis]; e._xaxis._series.push(e); e._yaxis._series.push(e); if (e.show) { e._xaxis.show = true; e._yaxis.show = true } if (!e.label) { e.label = "Series " + (c + 1).toString() } this.series.push(e); for (var n = 0; n < a.jqplot.postParseSeriesOptionsHooks.length; n++) { a.jqplot.postParseSeriesOptionsHooks[n].call(this.series[c], this.options.seriesDefaults, this.options.series[c]) } for (var n = 0; n < this.postParseSeriesOptionsHooks.hooks.length; n++) { this.postParseSeriesOptionsHooks.hooks[n].call(this.series[c], this.options.seriesDefaults, this.options.series[c]) } } a.extend(true, this.grid, this.options.grid); for (var c = 0; c < 12; c++) { var j = h[c]; var k = this.axes[j]; if (k.borderWidth == null) { k.borderWidth = this.grid.borderWidth } } if (typeof this.options.title == "string") { this.title.text = this.options.title } else if (typeof this.options.title == "object") { a.extend(true, this.title, this.options.title) } this.title._plotWidth = this._width; this.legend.setOptions(this.options.legend); for (var c = 0; c < a.jqplot.postParseOptionsHooks.length; c++) { a.jqplot.postParseOptionsHooks[c].call(this, b) } for (var c = 0; c < this.postParseOptionsHooks.hooks.length; c++) { this.postParseOptionsHooks.hooks[c].call(this, b) } }; this.destroy = function () { this.canvasManager.freeAllCanvases(); if (this.eventCanvas && this.eventCanvas._elem) { this.eventCanvas._elem.unbind() } this.target.empty(); this.target[0].innerHTML = "" }; this.replot = function (a) { var b = a || {}; var c = b.clear === false ? false : true; var d = b.resetAxes || false; this.target.trigger("jqplotPreReplot"); if (c) { this.destroy() } this.reInitialize(); if (d) { this.resetAxesScale(d, b.axes) } this.draw(); this.target.trigger("jqplotPostReplot") }; this.redraw = function (a) { a = a != null ? a : true; this.target.trigger("jqplotPreRedraw"); if (a) { this.canvasManager.freeAllCanvases(); this.eventCanvas._elem.unbind(); this.target.empty() } for (var b in this.axes) { this.axes[b]._ticks = [] } for (var c = 0; c < this.series.length; c++) { this.populatePlotData(this.series[c], c) } this._sumy = 0; this._sumx = 0; for (c = 0; c < this.series.length; c++) { this._sumy += this.series[c]._sumy; this._sumx += this.series[c]._sumx } this.draw(); this.target.trigger("jqplotPostRedraw") }; this.draw = function () { if (this.drawIfHidden || this.target.is(":visible")) { this.target.trigger("jqplotPreDraw"); var b, c, d, e; for (b = 0, d = a.jqplot.preDrawHooks.length; b < d; b++) { a.jqplot.preDrawHooks[b].call(this) } for (b = 0, d = this.preDrawHooks.length; b < d; b++) { this.preDrawHooks.hooks[b].apply(this, this.preDrawSeriesHooks.args[b]) } this.target.append(this.baseCanvas.createElement({ left: 0, right: 0, top: 0, bottom: 0 }, "jqplot-base-canvas", null, this)); this.baseCanvas.setContext(); this.target.append(this.title.draw()); this.title.pack({ top: 0, left: 0 }); var f = this.legend.draw(); var g = { top: 0, left: 0, bottom: 0, right: 0 }; if (this.legend.placement == "outsideGrid") { this.target.append(f); switch (this.legend.location) { case "n": g.top += this.legend.getHeight(); break; case "s": g.bottom += this.legend.getHeight(); break; case "ne": case "e": case "se": g.right += this.legend.getWidth(); break; case "nw": case "w": case "sw": g.left += this.legend.getWidth(); break; default: g.right += this.legend.getWidth(); break } f = f.detach() } var i = this.axes; var j; for (b = 0; b < 12; b++) { j = h[b]; this.target.append(i[j].draw(this.baseCanvas._ctx, this)); i[j].set() } if (i.yaxis.show) { g.left += i.yaxis.getWidth() } var k = ["y2axis", "y3axis", "y4axis", "y5axis", "y6axis", "y7axis", "y8axis", "y9axis"]; var l = [0, 0, 0, 0, 0, 0, 0, 0]; var m = 0; var n; for (n = 0; n < 8; n++) { if (i[k[n]].show) { m += i[k[n]].getWidth(); l[n] = m } } g.right += m; if (i.x2axis.show) { g.top += i.x2axis.getHeight() } if (this.title.show) { g.top += this.title.getHeight() } if (i.xaxis.show) { g.bottom += i.xaxis.getHeight() } if (this.options.gridDimensions && a.isPlainObject(this.options.gridDimensions)) { var o = parseInt(this.options.gridDimensions.width, 10) || 0; var p = parseInt(this.options.gridDimensions.height, 10) || 0; var q = (this._width - g.left - g.right - o) / 2; var r = (this._height - g.top - g.bottom - p) / 2; if (r >= 0 && q >= 0) { g.top += r; g.bottom += r; g.left += q; g.right += q } } var s = ["top", "bottom", "left", "right"]; for (var n in s) { if (this._gridPadding[s[n]] == null && g[s[n]] > 0) { this._gridPadding[s[n]] = g[s[n]] } else if (this._gridPadding[s[n]] == null) { this._gridPadding[s[n]] = this._defaultGridPadding[s[n]] } } var t = this.legend.placement == "outsideGrid" ? { top: this.title.getHeight(), left: 0, right: 0, bottom: 0} : this._gridPadding; i.xaxis.pack({ position: "absolute", bottom: this._gridPadding.bottom - i.xaxis.getHeight(), left: 0, width: this._width }, { min: this._gridPadding.left, max: this._width - this._gridPadding.right }); i.yaxis.pack({ position: "absolute", top: 0, left: this._gridPadding.left - i.yaxis.getWidth(), height: this._height }, { min: this._height - this._gridPadding.bottom, max: this._gridPadding.top }); i.x2axis.pack({ position: "absolute", top: this._gridPadding.top - i.x2axis.getHeight(), left: 0, width: this._width }, { min: this._gridPadding.left, max: this._width - this._gridPadding.right }); for (b = 8; b > 0; b--) { i[k[b - 1]].pack({ position: "absolute", top: 0, right: this._gridPadding.right - l[b - 1] }, { min: this._height - this._gridPadding.bottom, max: this._gridPadding.top }) } var u = (this._width - this._gridPadding.left - this._gridPadding.right) / 2 + this._gridPadding.left - i.yMidAxis.getWidth() / 2; i.yMidAxis.pack({ position: "absolute", top: 0, left: u, zIndex: 9, textAlign: "center" }, { min: this._height - this._gridPadding.bottom, max: this._gridPadding.top }); this.target.append(this.grid.createElement(this._gridPadding, this)); this.grid.draw(); var v = this.series; var w = v.length; for (b = 0, d = w; b < d; b++) { c = this.seriesStack[b]; this.target.append(v[c].shadowCanvas.createElement(this._gridPadding, "jqplot-series-shadowCanvas", null, this)); v[c].shadowCanvas.setContext(); v[c].shadowCanvas._elem.data("seriesIndex", c) } for (b = 0, d = w; b < d; b++) { c = this.seriesStack[b]; this.target.append(v[c].canvas.createElement(this._gridPadding, "jqplot-series-canvas", null, this)); v[c].canvas.setContext(); v[c].canvas._elem.data("seriesIndex", c) } this.target.append(this.eventCanvas.createElement(this._gridPadding, "jqplot-event-canvas", null, this)); this.eventCanvas.setContext(); this.eventCanvas._ctx.fillStyle = "rgba(0,0,0,0)"; this.eventCanvas._ctx.fillRect(0, 0, this.eventCanvas._ctx.canvas.width, this.eventCanvas._ctx.canvas.height); this.bindCustomEvents(); if (this.legend.preDraw) { this.eventCanvas._elem.before(f); this.legend.pack(t); if (this.legend._elem) { this.drawSeries({ legendInfo: { location: this.legend.location, placement: this.legend.placement, width: this.legend.getWidth(), height: this.legend.getHeight(), xoffset: this.legend.xoffset, yoffset: this.legend.yoffset} }) } else { this.drawSeries() } } else { this.drawSeries(); if (w) { a(v[w - 1].canvas._elem).after(f) } this.legend.pack(t) } for (var b = 0, d = a.jqplot.eventListenerHooks.length; b < d; b++) { this.eventCanvas._elem.bind(a.jqplot.eventListenerHooks[b][0], { plot: this }, a.jqplot.eventListenerHooks[b][1]) } for (var b = 0, d = this.eventListenerHooks.hooks.length; b < d; b++) { this.eventCanvas._elem.bind(this.eventListenerHooks.hooks[b][0], { plot: this }, this.eventListenerHooks.hooks[b][1]) } var x = this.fillBetween; if (x.fill && x.series1 !== x.series2 && x.series1 < w && x.series2 < w && v[x.series1]._type === "line" && v[x.series2]._type === "line") { this.doFillBetweenLines() } for (var b = 0, d = a.jqplot.postDrawHooks.length; b < d; b++) { a.jqplot.postDrawHooks[b].call(this) } for (var b = 0, d = this.postDrawHooks.hooks.length; b < d; b++) { this.postDrawHooks.hooks[b].apply(this, this.postDrawHooks.args[b]) } if (this.target.is(":visible")) { this._drawCount += 1 } var y, z, A, B; for (b = 0, d = w; b < d; b++) { y = v[b]; z = y.renderer; A = ".jqplot-point-label.jqplot-series-" + b; if (z.animation && z.animation._supported && z.animation.show && (this._drawCount < 2 || this.animateReplot)) { B = this.target.find(A); B.stop(true, true).hide(); y.canvas._elem.stop(true, true).hide(); y.shadowCanvas._elem.stop(true, true).hide(); y.canvas._elem.jqplotEffect("blind", { mode: "show", direction: z.animation.direction }, z.animation.speed); y.shadowCanvas._elem.jqplotEffect("blind", { mode: "show", direction: z.animation.direction }, z.animation.speed); B.fadeIn(z.animation.speed * .8) } } B = null; this.target.trigger("jqplotPostDraw", [this]) } }; i.prototype.doFillBetweenLines = function () { var a = this.fillBetween; var b = a.series1; var c = a.series2; var d = b < c ? b : c; var e = c > b ? c : b; var f = this.series[d]; var g = this.series[e]; if (g.renderer.smooth) { var h = g.renderer._smoothedData.slice(0).reverse() } else { var h = g.gridData.slice(0).reverse() } if (f.renderer.smooth) { var i = f.renderer._smoothedData.concat(h) } else { var i = f.gridData.concat(h) } var j = a.color !== null ? a.color : this.series[b].fillColor; var k = a.baseSeries !== null ? a.baseSeries : d; var l = this.series[k].renderer.shapeRenderer; var m = { fillStyle: j, fill: true, closePath: true }; l.draw(f.shadowCanvas._ctx, i, m) }; this.bindCustomEvents = function () { this.eventCanvas._elem.bind("click", { plot: this }, this.onClick); this.eventCanvas._elem.bind("dblclick", { plot: this }, this.onDblClick); this.eventCanvas._elem.bind("mousedown", { plot: this }, this.onMouseDown); this.eventCanvas._elem.bind("mousemove", { plot: this }, this.onMouseMove); this.eventCanvas._elem.bind("mouseenter", { plot: this }, this.onMouseEnter); this.eventCanvas._elem.bind("mouseleave", { plot: this }, this.onMouseLeave); if (this.captureRightClick) { this.eventCanvas._elem.bind("mouseup", { plot: this }, this.onRightClick); this.eventCanvas._elem.get(0).oncontextmenu = function () { return false } } else { this.eventCanvas._elem.bind("mouseup", { plot: this }, this.onMouseUp) } }; this.onClick = function (b) { var c = l(b); var d = b.data.plot; var e = m(c.gridPos, d); var f = jQuery.Event("jqplotClick"); f.pageX = b.pageX; f.pageY = b.pageY; a(this).trigger(f, [c.gridPos, c.dataPos, e, d]) }; this.onDblClick = function (b) { var c = l(b); var d = b.data.plot; var e = m(c.gridPos, d); var f = jQuery.Event("jqplotDblClick"); f.pageX = b.pageX; f.pageY = b.pageY; a(this).trigger(f, [c.gridPos, c.dataPos, e, d]) }; this.onMouseDown = function (b) { var c = l(b); var d = b.data.plot; var e = m(c.gridPos, d); var f = jQuery.Event("jqplotMouseDown"); f.pageX = b.pageX; f.pageY = b.pageY; a(this).trigger(f, [c.gridPos, c.dataPos, e, d]) }; this.onMouseUp = function (b) { var c = l(b); var d = jQuery.Event("jqplotMouseUp"); d.pageX = b.pageX; d.pageY = b.pageY; a(this).trigger(d, [c.gridPos, c.dataPos, null, b.data.plot]) }; this.onRightClick = function (b) { var c = l(b); var d = b.data.plot; var e = m(c.gridPos, d); if (d.captureRightClick) { if (b.which == 3) { var f = jQuery.Event("jqplotRightClick"); f.pageX = b.pageX; f.pageY = b.pageY; a(this).trigger(f, [c.gridPos, c.dataPos, e, d]) } else { var f = jQuery.Event("jqplotMouseUp"); f.pageX = b.pageX; f.pageY = b.pageY; a(this).trigger(f, [c.gridPos, c.dataPos, e, d]) } } }; this.onMouseMove = function (b) { var c = l(b); var d = b.data.plot; var e = m(c.gridPos, d); var f = jQuery.Event("jqplotMouseMove"); f.pageX = b.pageX; f.pageY = b.pageY; a(this).trigger(f, [c.gridPos, c.dataPos, e, d]) }; this.onMouseEnter = function (b) { var c = l(b); var d = b.data.plot; var e = jQuery.Event("jqplotMouseEnter"); e.pageX = b.pageX; e.pageY = b.pageY; e.relatedTarget = b.relatedTarget; a(this).trigger(e, [c.gridPos, c.dataPos, null, d]) }; this.onMouseLeave = function (b) { var c = l(b); var d = b.data.plot; var e = jQuery.Event("jqplotMouseLeave"); e.pageX = b.pageX; e.pageY = b.pageY; e.relatedTarget = b.relatedTarget; a(this).trigger(e, [c.gridPos, c.dataPos, null, d]) }; this.drawSeries = function (c, d) { var e, f, g; d = typeof c === "number" && d == null ? c : d; c = typeof c === "object" ? c : {}; if (d != b) { f = this.series[d]; g = f.shadowCanvas._ctx; g.clearRect(0, 0, g.canvas.width, g.canvas.height); f.drawShadow(g, c, this); g = f.canvas._ctx; g.clearRect(0, 0, g.canvas.width, g.canvas.height); f.draw(g, c, this); if (f.renderer.constructor == a.jqplot.BezierCurveRenderer) { if (d < this.series.length - 1) { this.drawSeries(d + 1) } } } else { for (e = 0; e < this.series.length; e++) { f = this.series[e]; g = f.shadowCanvas._ctx; g.clearRect(0, 0, g.canvas.width, g.canvas.height); f.drawShadow(g, c, this); g = f.canvas._ctx; g.clearRect(0, 0, g.canvas.width, g.canvas.height); f.draw(g, c, this) } } c = d = e = f = g = null }; this.moveSeriesToFront = function (b) { b = parseInt(b, 10); var c = a.inArray(b, this.seriesStack); if (c == -1) { return } if (c == this.seriesStack.length - 1) { this.previousSeriesStack = this.seriesStack.slice(0); return } var d = this.seriesStack[this.seriesStack.length - 1]; var e = this.series[b].canvas._elem.detach(); var f = this.series[b].shadowCanvas._elem.detach(); this.series[d].shadowCanvas._elem.after(f); this.series[d].canvas._elem.after(e); this.previousSeriesStack = this.seriesStack.slice(0); this.seriesStack.splice(c, 1); this.seriesStack.push(b) }; this.moveSeriesToBack = function (b) { b = parseInt(b, 10); var c = a.inArray(b, this.seriesStack); if (c == 0 || c == -1) { return } var d = this.seriesStack[0]; var e = this.series[b].canvas._elem.detach(); var f = this.series[b].shadowCanvas._elem.detach(); this.series[d].shadowCanvas._elem.before(f); this.series[d].canvas._elem.before(e); this.previousSeriesStack = this.seriesStack.slice(0); this.seriesStack.splice(c, 1); this.seriesStack.unshift(b) }; this.restorePreviousSeriesOrder = function () { var a, b, c, d, e, f, g; if (this.seriesStack == this.previousSeriesStack) { return } for (a = 1; a < this.previousSeriesStack.length; a++) { f = this.previousSeriesStack[a]; g = this.previousSeriesStack[a - 1]; c = this.series[f].canvas._elem.detach(); d = this.series[f].shadowCanvas._elem.detach(); this.series[g].shadowCanvas._elem.after(d); this.series[g].canvas._elem.after(c) } e = this.seriesStack.slice(0); this.seriesStack = this.previousSeriesStack.slice(0); this.previousSeriesStack = e }; this.restoreOriginalSeriesOrder = function () { var a, b, c = [], d, e; for (a = 0; a < this.series.length; a++) { c.push(a) } if (this.seriesStack == c) { return } this.previousSeriesStack = this.seriesStack.slice(0); this.seriesStack = c; for (a = 1; a < this.seriesStack.length; a++) { d = this.series[a].canvas._elem.detach(); e = this.series[a].shadowCanvas._elem.detach(); this.series[a - 1].shadowCanvas._elem.after(e); this.series[a - 1].canvas._elem.after(d) } }; this.activateTheme = function (a) { this.themeEngine.activate(this, a) } } function g() { a.jqplot.ElemContainer.call(this); this.drawGridlines = true; this.gridLineColor = "#cccccc"; this.gridLineWidth = 1; this.background = "#fffdf6"; this.borderColor = "#999999"; this.borderWidth = 2; this.drawBorder = true; this.shadow = true; this.shadowAngle = 45; this.shadowOffset = 1.5; this.shadowWidth = 3; this.shadowDepth = 3; this.shadowColor = null; this.shadowAlpha = "0.07"; this._left; this._top; this._right; this._bottom; this._width; this._height; this._axes = []; this.renderer = a.jqplot.CanvasGridRenderer; this.rendererOptions = {}; this._offsets = { top: null, bottom: null, left: null, right: null} } function f() { a.jqplot.ElemContainer.call(this); this.show = true; this.xaxis = "xaxis"; this._xaxis; this.yaxis = "yaxis"; this._yaxis; this.gridBorderWidth = 2; this.renderer = a.jqplot.LineRenderer; this.rendererOptions = {}; this.data = []; this.gridData = []; this.label = ""; this.showLabel = true; this.color; this.negativeColor; this.lineWidth = 2.5; this.lineJoin = "round"; this.lineCap = "round"; this.linePattern = "solid"; this.shadow = true; this.shadowAngle = 45; this.shadowOffset = 1.25; this.shadowDepth = 3; this.shadowAlpha = "0.1"; this.breakOnNull = false; this.markerRenderer = a.jqplot.MarkerRenderer; this.markerOptions = {}; this.showLine = true; this.showMarker = true; this.index; this.fill = false; this.fillColor; this.fillAlpha; this.fillAndStroke = false; this.disableStack = false; this._stack = false; this.neighborThreshold = 4; this.fillToZero = false; this.fillToValue = 0; this.fillAxis = "y"; this.useNegativeColors = true; this._stackData = []; this._plotData = []; this._plotValues = { x: [], y: [] }; this._intervals = { x: {}, y: {} }; this._prevPlotData = []; this._prevGridData = []; this._stackAxis = "y"; this._primaryAxis = "_xaxis"; this.canvas = new a.jqplot.GenericCanvas; this.shadowCanvas = new a.jqplot.GenericCanvas; this.plugins = {}; this._sumy = 0; this._sumx = 0; this._type = "" } function e(b) { a.jqplot.ElemContainer.call(this); this.text = b; this.show = true; this.fontFamily; this.fontSize; this.textAlign; this.textColor; this.renderer = a.jqplot.DivTitleRenderer; this.rendererOptions = {}; this.escapeHtml = false } function d(b) { a.jqplot.ElemContainer.call(this); this.show = false; this.location = "ne"; this.labels = []; this.showLabels = true; this.showSwatches = true; this.placement = "insideGrid"; this.xoffset = 0; this.yoffset = 0; this.border; this.background; this.textColor; this.fontFamily; this.fontSize; this.rowSpacing = "0.5em"; this.renderer = a.jqplot.TableLegendRenderer; this.rendererOptions = {}; this.preDraw = false; this.marginTop = null; this.marginRight = null; this.marginBottom = null; this.marginLeft = null; this.escapeHtml = false; this._series = []; a.extend(true, this, b) } function c(b) { a.jqplot.ElemContainer.call(this); this.name = b; this._series = []; this.show = false; this.tickRenderer = a.jqplot.AxisTickRenderer; this.tickOptions = {}; this.labelRenderer = a.jqplot.AxisLabelRenderer; this.labelOptions = {}; this.label = null; this.showLabel = true; this.min = null; this.max = null; this.autoscale = false; this.pad = 1.2; this.padMax = null; this.padMin = null; this.ticks = []; this.numberTicks; this.tickInterval; this.renderer = a.jqplot.LinearAxisRenderer; this.rendererOptions = {}; this.showTicks = true; this.showTickMarks = true; this.showMinorTicks = true; this.drawMajorGridlines = true; this.drawMinorGridlines = false; this.drawMajorTickMarks = true; this.drawMinorTickMarks = true; this.useSeriesColor = false; this.borderWidth = null; this.borderColor = null; this._dataBounds = { min: null, max: null }; this._intervalStats = []; this._offsets = { min: null, max: null }; this._ticks = []; this._label = null; this.syncTicks = null; this.tickSpacing = 75; this._min = null; this._max = null; this._tickInterval = null; this._numberTicks = null; this.__ticks = null; this._options = {} } var b; a.fn.emptyForce = function () { for (var b = 0, c; (c = a(this)[b]) != null; b++) { if (c.nodeType === 1) { jQuery.cleanData(c.getElementsByTagName("*")) } if (a.jqplot_use_excanvas) { c.outerHTML = "" } else { while (c.firstChild) { c.removeChild(c.firstChild) } } c = null } return a(this) }; a.fn.removeChildForce = function (a) { while (a.firstChild) { this.removeChildForce(a.firstChild); a.removeChild(a.firstChild) } }; a.jqplot = function (b, c, d) { var e, f; if (d == null) { if (jQuery.isArray(c)) { e = c; f = null } else if (typeof c === "object") { e = null; f = c } } else { e = c; f = d } var g = new i; a("#" + b).removeClass("jqplot-error"); if (a.jqplot.config.catchErrors) { try { g.init(b, e, f); g.draw(); g.themeEngine.init.call(g); return g } catch (h) { var j = a.jqplot.config.errorMessage || h.message; a("#" + b).append('<div class="jqplot-error-message">' + j + "</div>"); a("#" + b).addClass("jqplot-error"); document.getElementById(b).style.background = a.jqplot.config.errorBackground; document.getElementById(b).style.border = a.jqplot.config.errorBorder; document.getElementById(b).style.fontFamily = a.jqplot.config.errorFontFamily; document.getElementById(b).style.fontSize = a.jqplot.config.errorFontSize; document.getElementById(b).style.fontStyle = a.jqplot.config.errorFontStyle; document.getElementById(b).style.fontWeight = a.jqplot.config.errorFontWeight } } else { g.init(b, e, f); g.draw(); g.themeEngine.init.call(g); return g } }; a.jqplot.version = "1.0.0b2_r1012"; a.jqplot.CanvasManager = function () { if (typeof a.jqplot.CanvasManager.canvases == "undefined") { a.jqplot.CanvasManager.canvases = []; a.jqplot.CanvasManager.free = [] } var c = []; this.getCanvas = function () { var b; var d = true; if (!a.jqplot.use_excanvas) { for (var e = 0, f = a.jqplot.CanvasManager.canvases.length; e < f; e++) { if (a.jqplot.CanvasManager.free[e] === true) { d = false; b = a.jqplot.CanvasManager.canvases[e]; a.jqplot.CanvasManager.free[e] = false; c.push(e); break } } } if (d) { b = document.createElement("canvas"); c.push(a.jqplot.CanvasManager.canvases.length); a.jqplot.CanvasManager.canvases.push(b); a.jqplot.CanvasManager.free.push(false) } return b }; this.initCanvas = function (b) { if (a.jqplot.use_excanvas) { return window.G_vmlCanvasManager.initElement(b) } return b }; this.freeAllCanvases = function () { for (var a = 0, b = c.length; a < b; a++) { this.freeCanvas(c[a]) } c = [] }; this.freeCanvas = function (c) { if (a.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== b) { window.G_vmlCanvasManager.uninitElement(a.jqplot.CanvasManager.canvases[c]); a.jqplot.CanvasManager.canvases[c] = null } else { var d = a.jqplot.CanvasManager.canvases[c]; d.getContext("2d").clearRect(0, 0, d.width, d.height); a(d).unbind().removeAttr("class").removeAttr("style"); a(d).css({ left: "", top: "", position: "" }); d.width = 0; d.height = 0; a.jqplot.CanvasManager.free[c] = true } } }; a.jqplot.log = function () { if (window.console) { window.console.log.apply(window.console, arguments) } }; a.jqplot.config = { addDomReference: false, enablePlugins: false, defaultHeight: 300, defaultWidth: 400, UTCAdjust: false, timezoneOffset: new Date((new Date).getTimezoneOffset() * 6e4), errorMessage: "", errorBackground: "", errorBorder: "", errorFontFamily: "", errorFontSize: "", errorFontStyle: "", errorFontWeight: "", catchErrors: false, defaultTickFormatString: "%.1f", defaultColors: ["#4bb2c5", "#EAA228", "#c5b47f", "#579575", "#839557", "#958c12", "#953579", "#4b5de4", "#d8b83f", "#ff5800", "#0085cc", "#c747a3", "#cddf54", "#FBD178", "#26B4E3", "#bd70c7"], defaultNegativeColors: ["#498991", "#C08840", "#9F9274", "#546D61", "#646C4A", "#6F6621", "#6E3F5F", "#4F64B0", "#A89050", "#C45923", "#187399", "#945381", "#959E5C", "#C7AF7B", "#478396", "#907294"], dashLength: 4, gapLength: 4, dotGapLength: 2.5, srcLocation: "jqplot/src/", pluginLocation: "jqplot/src/plugins/" }; a.jqplot.arrayMax = function (a) { return Math.max.apply(Math, a) }; a.jqplot.arrayMin = function (a) { return Math.min.apply(Math, a) }; a.jqplot.enablePlugins = a.jqplot.config.enablePlugins; a.jqplot.support_canvas = function () { if (typeof a.jqplot.support_canvas.result == "undefined") { a.jqplot.support_canvas.result = !!document.createElement("canvas").getContext } return a.jqplot.support_canvas.result }; a.jqplot.support_canvas_text = function () { if (typeof a.jqplot.support_canvas_text.result == "undefined") { if (window.G_vmlCanvasManager !== b && window.G_vmlCanvasManager._version > 887) { a.jqplot.support_canvas_text.result = true } else { a.jqplot.support_canvas_text.result = !!(document.createElement("canvas").getContext && typeof document.createElement("canvas").getContext("2d").fillText == "function") } } return a.jqplot.support_canvas_text.result }; a.jqplot.use_excanvas = a.browser.msie && !a.jqplot.support_canvas() ? true : false; a.jqplot.preInitHooks = []; a.jqplot.postInitHooks = []; a.jqplot.preParseOptionsHooks = []; a.jqplot.postParseOptionsHooks = []; a.jqplot.preDrawHooks = []; a.jqplot.postDrawHooks = []; a.jqplot.preDrawSeriesHooks = []; a.jqplot.postDrawSeriesHooks = []; a.jqplot.preDrawLegendHooks = []; a.jqplot.addLegendRowHooks = []; a.jqplot.preSeriesInitHooks = []; a.jqplot.postSeriesInitHooks = []; a.jqplot.preParseSeriesOptionsHooks = []; a.jqplot.postParseSeriesOptionsHooks = []; a.jqplot.eventListenerHooks = []; a.jqplot.preDrawSeriesShadowHooks = []; a.jqplot.postDrawSeriesShadowHooks = []; a.jqplot.ElemContainer = function () { this._elem; this._plotWidth; this._plotHeight; this._plotDimensions = { height: null, width: null} }; a.jqplot.ElemContainer.prototype.createElement = function (b, c, d, e, f) { this._offsets = c; var g = d || "jqplot"; var h = document.createElement(b); this._elem = a(h); this._elem.addClass(g); this._elem.css(e); this._elem.attr(f); h = null; return this._elem }; a.jqplot.ElemContainer.prototype.getWidth = function () { if (this._elem) { return this._elem.outerWidth(true) } else { return null } }; a.jqplot.ElemContainer.prototype.getHeight = function () { if (this._elem) { return this._elem.outerHeight(true) } else { return null } }; a.jqplot.ElemContainer.prototype.getPosition = function () { if (this._elem) { return this._elem.position() } else { return { top: null, left: null, bottom: null, right: null} } }; a.jqplot.ElemContainer.prototype.getTop = function () { return this.getPosition().top }; a.jqplot.ElemContainer.prototype.getLeft = function () { return this.getPosition().left }; a.jqplot.ElemContainer.prototype.getBottom = function () { return this._elem.css("bottom") }; a.jqplot.ElemContainer.prototype.getRight = function () { return this._elem.css("right") }; c.prototype = new a.jqplot.ElemContainer; c.prototype.constructor = c; c.prototype.init = function () { this.renderer = new this.renderer; this.tickOptions.axis = this.name; if (this.tickOptions.showMark == null) { this.tickOptions.showMark = this.showTicks } if (this.tickOptions.showMark == null) { this.tickOptions.showMark = this.showTickMarks } if (this.tickOptions.showLabel == null) { this.tickOptions.showLabel = this.showTicks } if (this.label == null || this.label == "") { this.showLabel = false } else { this.labelOptions.label = this.label } if (this.showLabel == false) { this.labelOptions.show = false } if (this.pad == 0) { this.pad = 1 } if (this.padMax == 0) { this.padMax = 1 } if (this.padMin == 0) { this.padMin = 1 } if (this.padMax == null) { this.padMax = (this.pad - 1) / 2 + 1 } if (this.padMin == null) { this.padMin = (this.pad - 1) / 2 + 1 } this.pad = this.padMax + this.padMin - 1; if (this.min != null || this.max != null) { this.autoscale = false } if (this.syncTicks == null && this.name.indexOf("y") > -1) { this.syncTicks = true } else if (this.syncTicks == null) { this.syncTicks = false } this.renderer.init.call(this, this.rendererOptions) }; c.prototype.draw = function (a, b) { if (this.__ticks) { this.__ticks = null } return this.renderer.draw.call(this, a, b) }; c.prototype.set = function () { this.renderer.set.call(this) }; c.prototype.pack = function (a, b) { if (this.show) { this.renderer.pack.call(this, a, b) } if (this._min == null) { this._min = this.min; this._max = this.max; this._tickInterval = this.tickInterval; this._numberTicks = this.numberTicks; this.__ticks = this._ticks } }; c.prototype.reset = function () { this.renderer.reset.call(this) }; c.prototype.resetScale = function (b) { a.extend(true, this, { min: null, max: null, numberTicks: null, tickInterval: null, _ticks: [], ticks: [] }, b); this.resetDataBounds() }; c.prototype.resetDataBounds = function () { var b = this._dataBounds; b.min = null; b.max = null; var c, d, e; var f = this.show ? true : false; for (var g = 0; g < this._series.length; g++) { d = this._series[g]; if (d.show) { e = d._plotData; if (d._type === "line" && d.renderer.bands.show && this.name.charAt(0) !== "x") { e = [[0, d.renderer.bands._min], [1, d.renderer.bands._max]] } var h = 1, i = 1; if (d._type != null && d._type == "ohlc") { h = 3; i = 2 } for (var j = 0, c = e.length; j < c; j++) { if (this.name == "xaxis" || this.name == "x2axis") { if (e[j][0] != null && e[j][0] < b.min || b.min == null) { b.min = e[j][0] } if (e[j][0] != null && e[j][0] > b.max || b.max == null) { b.max = e[j][0] } } else { if (e[j][h] != null && e[j][h] < b.min || b.min == null) { b.min = e[j][h] } if (e[j][i] != null && e[j][i] > b.max || b.max == null) { b.max = e[j][i] } } } if (f && d.renderer.constructor !== a.jqplot.BarRenderer) { f = false } else if (f && this._options.hasOwnProperty("forceTickAt0") && this._options.forceTickAt0 == false) { f = false } else if (f && d.renderer.constructor === a.jqplot.BarRenderer) { if (d.barDirection == "vertical" && this.name != "xaxis" && this.name != "x2axis") { if (this._options.pad != null || this._options.padMin != null) { f = false } } else if (d.barDirection == "horizontal" && (this.name == "xaxis" || this.name == "x2axis")) { if (this._options.pad != null || this._options.padMin != null) { f = false } } } } } if (f && this.renderer.constructor === a.jqplot.LinearAxisRenderer && b.min >= 0) { this.padMin = 1; this.forceTickAt0 = true } }; d.prototype = new a.jqplot.ElemContainer; d.prototype.constructor = d; d.prototype.setOptions = function (b) { a.extend(true, this, b); if (this.placement == "inside") { this.placement = "insideGrid" } if (this.xoffset > 0) { if (this.placement == "insideGrid") { switch (this.location) { case "nw": case "w": case "sw": if (this.marginLeft == null) { this.marginLeft = this.xoffset + "px" } this.marginRight = "0px"; break; case "ne": case "e": case "se": default: if (this.marginRight == null) { this.marginRight = this.xoffset + "px" } this.marginLeft = "0px"; break } } else if (this.placement == "outside") { switch (this.location) { case "nw": case "w": case "sw": if (this.marginRight == null) { this.marginRight = this.xoffset + "px" } this.marginLeft = "0px"; break; case "ne": case "e": case "se": default: if (this.marginLeft == null) { this.marginLeft = this.xoffset + "px" } this.marginRight = "0px"; break } } this.xoffset = 0 } if (this.yoffset > 0) { if (this.placement == "outside") { switch (this.location) { case "sw": case "s": case "se": if (this.marginTop == null) { this.marginTop = this.yoffset + "px" } this.marginBottom = "0px"; break; case "ne": case "n": case "nw": default: if (this.marginBottom == null) { this.marginBottom = this.yoffset + "px" } this.marginTop = "0px"; break } } else if (this.placement == "insideGrid") { switch (this.location) { case "sw": case "s": case "se": if (this.marginBottom == null) { this.marginBottom = this.yoffset + "px" } this.marginTop = "0px"; break; case "ne": case "n": case "nw": default: if (this.marginTop == null) { this.marginTop = this.yoffset + "px" } this.marginBottom = "0px"; break } } this.yoffset = 0 } }; d.prototype.init = function () { this.renderer = new this.renderer; this.renderer.init.call(this, this.rendererOptions) }; d.prototype.draw = function (b) { for (var c = 0; c < a.jqplot.preDrawLegendHooks.length; c++) { a.jqplot.preDrawLegendHooks[c].call(this, b) } return this.renderer.draw.call(this, b) }; d.prototype.pack = function (a) { this.renderer.pack.call(this, a) }; e.prototype = new a.jqplot.ElemContainer; e.prototype.constructor = e; e.prototype.init = function () { this.renderer = new this.renderer; this.renderer.init.call(this, this.rendererOptions) }; e.prototype.draw = function (a) { return this.renderer.draw.call(this, a) }; e.prototype.pack = function () { this.renderer.pack.call(this) }; f.prototype = new a.jqplot.ElemContainer; f.prototype.constructor = f; f.prototype.init = function (b, c, d) { this.index = b; this.gridBorderWidth = c; var e = this.data; var f = [], g; for (g = 0; g < e.length; g++) { if (!this.breakOnNull) { if (e[g] == null || e[g][0] == null || e[g][1] == null) { continue } else { f.push(e[g]) } } else { f.push(e[g]) } } this.data = f; if (!this.color && this.show) { this.color = d.colorGenerator.get(this.index) } if (!this.negativeColor && this.show) { this.negativeColor = d.negativeColorGenerator.get(this.index) } if (!this.fillColor) { this.fillColor = this.color } if (this.fillAlpha) { var h = a.jqplot.normalize2rgb(this.fillColor); var h = a.jqplot.getColorComponents(h); this.fillColor = "rgba(" + h[0] + "," + h[1] + "," + h[2] + "," + this.fillAlpha + ")" } this.renderer = new this.renderer; this.renderer.init.call(this, this.rendererOptions, d); this.markerRenderer = new this.markerRenderer; if (!this.markerOptions.color) { this.markerOptions.color = this.color } if (this.markerOptions.show == null) { this.markerOptions.show = this.showMarker } this.showMarker = this.markerOptions.show; this.markerRenderer.init(this.markerOptions) }; f.prototype.draw = function (c, d, e) { var f = d == b ? {} : d; c = c == b ? this.canvas._ctx : c; var g, h, i; for (g = 0; g < a.jqplot.preDrawSeriesHooks.length; g++) { a.jqplot.preDrawSeriesHooks[g].call(this, c, f) } if (this.show) { this.renderer.setGridData.call(this, e); if (!f.preventJqPlotSeriesDrawTrigger) { a(c.canvas).trigger("jqplotSeriesDraw", [this.data, this.gridData]) } h = []; if (f.data) { h = f.data } else if (!this._stack) { h = this.data } else { h = this._plotData } i = f.gridData || this.renderer.makeGridData.call(this, h, e); if (this._type === "line" && this.renderer.smooth && this.renderer._smoothedData.length) { i = this.renderer._smoothedData } this.renderer.draw.call(this, c, i, f, e) } for (g = 0; g < a.jqplot.postDrawSeriesHooks.length; g++) { a.jqplot.postDrawSeriesHooks[g].call(this, c, f, e) } c = d = e = g = h = i = null }; f.prototype.drawShadow = function (c, d, e) { var f = d == b ? {} : d; c = c == b ? this.shadowCanvas._ctx : c; var g, h, i; for (g = 0; g < a.jqplot.preDrawSeriesShadowHooks.length; g++) { a.jqplot.preDrawSeriesShadowHooks[g].call(this, c, f) } if (this.shadow) { this.renderer.setGridData.call(this, e); h = []; if (f.data) { h = f.data } else if (!this._stack) { h = this.data } else { h = this._plotData } i = f.gridData || this.renderer.makeGridData.call(this, h, e); this.renderer.drawShadow.call(this, c, i, f) } for (g = 0; g < a.jqplot.postDrawSeriesShadowHooks.length; g++) { a.jqplot.postDrawSeriesShadowHooks[g].call(this, c, f) } c = d = e = g = h = i = null }; f.prototype.toggleDisplay = function (a) { var b, c; if (a.data.series) { b = a.data.series } else { b = this } if (a.data.speed) { c = a.data.speed } if (c) { if (b.canvas._elem.is(":hidden")) { b.canvas._elem.removeClass("jqplot-series-hidden"); if (b.shadowCanvas._elem) { b.shadowCanvas._elem.fadeIn(c) } b.canvas._elem.fadeIn(c); b.canvas._elem.nextAll(".jqplot-point-label.jqplot-series-" + b.index).fadeIn(c) } else { b.canvas._elem.addClass("jqplot-series-hidden"); if (b.shadowCanvas._elem) { b.shadowCanvas._elem.fadeOut(c) } b.canvas._elem.fadeOut(c); b.canvas._elem.nextAll(".jqplot-point-label.jqplot-series-" + b.index).fadeOut(c) } } else { if (b.canvas._elem.is(":hidden")) { b.canvas._elem.removeClass("jqplot-series-hidden"); if (b.shadowCanvas._elem) { b.shadowCanvas._elem.show() } b.canvas._elem.show(); b.canvas._elem.nextAll(".jqplot-point-label.jqplot-series-" + b.index).show() } else { b.canvas._elem.addClass("jqplot-series-hidden"); if (b.shadowCanvas._elem) { b.shadowCanvas._elem.hide() } b.canvas._elem.hide(); b.canvas._elem.nextAll(".jqplot-point-label.jqplot-series-" + b.index).hide() } } }; g.prototype = new a.jqplot.ElemContainer; g.prototype.constructor = g; g.prototype.init = function () { this.renderer = new this.renderer; this.renderer.init.call(this, this.rendererOptions) }; g.prototype.createElement = function (a, b) { this._offsets = a; return this.renderer.createElement.call(this, b) }; g.prototype.draw = function () { this.renderer.draw.call(this) }; a.jqplot.GenericCanvas = function () { a.jqplot.ElemContainer.call(this); this._ctx }; a.jqplot.GenericCanvas.prototype = new a.jqplot.ElemContainer; a.jqplot.GenericCanvas.prototype.constructor = a.jqplot.GenericCanvas; a.jqplot.GenericCanvas.prototype.createElement = function (c, d, e, f) { this._offsets = c; var g = "jqplot"; if (d != b) { g = d } var h; h = f.canvasManager.getCanvas(); if (e != null) { this._plotDimensions = e } h.width = this._plotDimensions.width - this._offsets.left - this._offsets.right; h.height = this._plotDimensions.height - this._offsets.top - this._offsets.bottom; this._elem = a(h); this._elem.css({ position: "absolute", left: this._offsets.left, top: this._offsets.top }); this._elem.addClass(g); h = f.canvasManager.initCanvas(h); h = null; return this._elem }; a.jqplot.GenericCanvas.prototype.setContext = function () { this._ctx = this._elem.get(0).getContext("2d"); return this._ctx }; a.jqplot.GenericCanvas.prototype.resetCanvas = function () { if (this._elem) { if (a.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== b) { window.G_vmlCanvasManager.uninitElement(this._elem.get(0)) } this._elem.emptyForce() } this._ctx = null }; a.jqplot.HooksManager = function () { this.hooks = []; this.args = [] }; a.jqplot.HooksManager.prototype.addOnce = function (a, b) { b = b || []; var c = false; for (var d = 0, e = this.hooks.length; d < e; d++) { if (this.hooks[d][0] == a) { c = true } } if (!c) { this.hooks.push(a); this.args.push(b) } }; a.jqplot.HooksManager.prototype.add = function (a, b) { b = b || []; this.hooks.push(a); this.args.push(b) }; a.jqplot.EventListenerManager = function () { this.hooks = [] }; a.jqplot.EventListenerManager.prototype.addOnce = function (a, b) { var c = false, d, e; for (var e = 0, f = this.hooks.length; e < f; e++) { d = this.hooks[e]; if (d[0] == a && d[1] == b) { c = true } } if (!c) { this.hooks.push([a, b]) } }; a.jqplot.EventListenerManager.prototype.add = function (a, b) { this.hooks.push([a, b]) }; var h = ["yMidAxis", "xaxis", "yaxis", "x2axis", "y2axis", "y3axis", "y4axis", "y5axis", "y6axis", "y7axis", "y8axis", "y9axis"]; a.jqplot.computeHighlightColors = function (b) { var c; if (jQuery.isArray(b)) { c = []; for (var d = 0; d < b.length; d++) { var e = a.jqplot.getColorComponents(b[d]); var f = [e[0], e[1], e[2]]; var g = f[0] + f[1] + f[2]; for (var h = 0; h < 3; h++) { f[h] = g > 660 ? f[h] * .85 : .73 * f[h] + 90; f[h] = parseInt(f[h], 10); f[h] > 255 ? 255 : f[h] } f[3] = .3 + .35 * e[3]; c.push("rgba(" + f[0] + "," + f[1] + "," + f[2] + "," + f[3] + ")") } } else { var e = a.jqplot.getColorComponents(b); var f = [e[0], e[1], e[2]]; var g = f[0] + f[1] + f[2]; for (var h = 0; h < 3; h++) { f[h] = g > 660 ? f[h] * .85 : .73 * f[h] + 90; f[h] = parseInt(f[h], 10); f[h] > 255 ? 255 : f[h] } f[3] = .3 + .35 * e[3]; c = "rgba(" + f[0] + "," + f[1] + "," + f[2] + "," + f[3] + ")" } return c }; a.jqplot.ColorGenerator = function (b) { b = b || a.jqplot.config.defaultColors; var c = 0; this.next = function () { if (c < b.length) { return b[c++] } else { c = 0; return b[c++] } }; this.previous = function () { if (c > 0) { return b[c--] } else { c = b.length - 1; return b[c] } }; this.get = function (a) { var c = a - b.length * Math.floor(a / b.length); return b[c] }; this.setColors = function (a) { b = a }; this.reset = function () { c = 0 }; this.getIndex = function () { return c }; this.setIndex = function (a) { c = a } }; a.jqplot.hex2rgb = function (a, b) { a = a.replace("#", ""); if (a.length == 3) { a = a.charAt(0) + a.charAt(0) + a.charAt(1) + a.charAt(1) + a.charAt(2) + a.charAt(2) } var c; c = "rgba(" + parseInt(a.slice(0, 2), 16) + ", " + parseInt(a.slice(2, 4), 16) + ", " + parseInt(a.slice(4, 6), 16); if (b) { c += ", " + b } c += ")"; return c }; a.jqplot.rgb2hex = function (a) { var b = /rgba?\( *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *(?:, *[0-9.]*)?\)/; var c = a.match(b); var d = "#"; for (var e = 1; e < 4; e++) { var f; if (c[e].search(/%/) != -1) { f = parseInt(255 * c[e] / 100, 10).toString(16); if (f.length == 1) { f = "0" + f } } else { f = parseInt(c[e], 10).toString(16); if (f.length == 1) { f = "0" + f } } d += f } return d }; a.jqplot.normalize2rgb = function (b, c) { if (b.search(/^ *rgba?\(/) != -1) { return b } else if (b.search(/^ *#?[0-9a-fA-F]?[0-9a-fA-F]/) != -1) { return a.jqplot.hex2rgb(b, c) } else { throw "invalid color spec" } }; a.jqplot.getColorComponents = function (b) { b = a.jqplot.colorKeywordMap[b] || b; var c = a.jqplot.normalize2rgb(b); var d = /rgba?\( *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *, *([0-9]{1,3}\.?[0-9]*%?) *,? *([0-9.]* *)?\)/; var e = c.match(d); var f = []; for (var g = 1; g < 4; g++) { if (e[g].search(/%/) != -1) { f[g - 1] = parseInt(255 * e[g] / 100, 10) } else { f[g - 1] = parseInt(e[g], 10) } } f[3] = parseFloat(e[4]) ? parseFloat(e[4]) : 1; return f }; a.jqplot.colorKeywordMap = { aliceblue: "rgb(240, 248, 255)", antiquewhite: "rgb(250, 235, 215)", aqua: "rgb( 0, 255, 255)", aquamarine: "rgb(127, 255, 212)", azure: "rgb(240, 255, 255)", beige: "rgb(245, 245, 220)", bisque: "rgb(255, 228, 196)", black: "rgb( 0, 0, 0)", blanchedalmond: "rgb(255, 235, 205)", blue: "rgb( 0, 0, 255)", blueviolet: "rgb(138, 43, 226)", brown: "rgb(165, 42, 42)", burlywood: "rgb(222, 184, 135)", cadetblue: "rgb( 95, 158, 160)", chartreuse: "rgb(127, 255, 0)", chocolate: "rgb(210, 105, 30)", coral: "rgb(255, 127, 80)", cornflowerblue: "rgb(100, 149, 237)", cornsilk: "rgb(255, 248, 220)", crimson: "rgb(220, 20, 60)", cyan: "rgb( 0, 255, 255)", darkblue: "rgb( 0, 0, 139)", darkcyan: "rgb( 0, 139, 139)", darkgoldenrod: "rgb(184, 134, 11)", darkgray: "rgb(169, 169, 169)", darkgreen: "rgb( 0, 100, 0)", darkgrey: "rgb(169, 169, 169)", darkkhaki: "rgb(189, 183, 107)", darkmagenta: "rgb(139, 0, 139)", darkolivegreen: "rgb( 85, 107, 47)", darkorange: "rgb(255, 140, 0)", darkorchid: "rgb(153, 50, 204)", darkred: "rgb(139, 0, 0)", darksalmon: "rgb(233, 150, 122)", darkseagreen: "rgb(143, 188, 143)", darkslateblue: "rgb( 72, 61, 139)", darkslategray: "rgb( 47, 79, 79)", darkslategrey: "rgb( 47, 79, 79)", darkturquoise: "rgb( 0, 206, 209)", darkviolet: "rgb(148, 0, 211)", deeppink: "rgb(255, 20, 147)", deepskyblue: "rgb( 0, 191, 255)", dimgray: "rgb(105, 105, 105)", dimgrey: "rgb(105, 105, 105)", dodgerblue: "rgb( 30, 144, 255)", firebrick: "rgb(178, 34, 34)", floralwhite: "rgb(255, 250, 240)", forestgreen: "rgb( 34, 139, 34)", fuchsia: "rgb(255, 0, 255)", gainsboro: "rgb(220, 220, 220)", ghostwhite: "rgb(248, 248, 255)", gold: "rgb(255, 215, 0)", goldenrod: "rgb(218, 165, 32)", gray: "rgb(128, 128, 128)", grey: "rgb(128, 128, 128)", green: "rgb( 0, 128, 0)", greenyellow: "rgb(173, 255, 47)", honeydew: "rgb(240, 255, 240)", hotpink: "rgb(255, 105, 180)", indianred: "rgb(205, 92, 92)", indigo: "rgb( 75, 0, 130)", ivory: "rgb(255, 255, 240)", khaki: "rgb(240, 230, 140)", lavender: "rgb(230, 230, 250)", lavenderblush: "rgb(255, 240, 245)", lawngreen: "rgb(124, 252, 0)", lemonchiffon: "rgb(255, 250, 205)", lightblue: "rgb(173, 216, 230)", lightcoral: "rgb(240, 128, 128)", lightcyan: "rgb(224, 255, 255)", lightgoldenrodyellow: "rgb(250, 250, 210)", lightgray: "rgb(211, 211, 211)", lightgreen: "rgb(144, 238, 144)", lightgrey: "rgb(211, 211, 211)", lightpink: "rgb(255, 182, 193)", lightsalmon: "rgb(255, 160, 122)", lightseagreen: "rgb( 32, 178, 170)", lightskyblue: "rgb(135, 206, 250)", lightslategray: "rgb(119, 136, 153)", lightslategrey: "rgb(119, 136, 153)", lightsteelblue: "rgb(176, 196, 222)", lightyellow: "rgb(255, 255, 224)", lime: "rgb( 0, 255, 0)", limegreen: "rgb( 50, 205, 50)", linen: "rgb(250, 240, 230)", magenta: "rgb(255, 0, 255)", maroon: "rgb(128, 0, 0)", mediumaquamarine: "rgb(102, 205, 170)", mediumblue: "rgb( 0, 0, 205)", mediumorchid: "rgb(186, 85, 211)", mediumpurple: "rgb(147, 112, 219)", mediumseagreen: "rgb( 60, 179, 113)", mediumslateblue: "rgb(123, 104, 238)", mediumspringgreen: "rgb( 0, 250, 154)", mediumturquoise: "rgb( 72, 209, 204)", mediumvioletred: "rgb(199, 21, 133)", midnightblue: "rgb( 25, 25, 112)", mintcream: "rgb(245, 255, 250)", mistyrose: "rgb(255, 228, 225)", moccasin: "rgb(255, 228, 181)", navajowhite: "rgb(255, 222, 173)", navy: "rgb( 0, 0, 128)", oldlace: "rgb(253, 245, 230)", olive: "rgb(128, 128, 0)", olivedrab: "rgb(107, 142, 35)", orange: "rgb(255, 165, 0)", orangered: "rgb(255, 69, 0)", orchid: "rgb(218, 112, 214)", palegoldenrod: "rgb(238, 232, 170)", palegreen: "rgb(152, 251, 152)", paleturquoise: "rgb(175, 238, 238)", palevioletred: "rgb(219, 112, 147)", papayawhip: "rgb(255, 239, 213)", peachpuff: "rgb(255, 218, 185)", peru: "rgb(205, 133, 63)", pink: "rgb(255, 192, 203)", plum: "rgb(221, 160, 221)", powderblue: "rgb(176, 224, 230)", purple: "rgb(128, 0, 128)", red: "rgb(255, 0, 0)", rosybrown: "rgb(188, 143, 143)", royalblue: "rgb( 65, 105, 225)", saddlebrown: "rgb(139, 69, 19)", salmon: "rgb(250, 128, 114)", sandybrown: "rgb(244, 164, 96)", seagreen: "rgb( 46, 139, 87)", seashell: "rgb(255, 245, 238)", sienna: "rgb(160, 82, 45)", silver: "rgb(192, 192, 192)", skyblue: "rgb(135, 206, 235)", slateblue: "rgb(106, 90, 205)", slategray: "rgb(112, 128, 144)", slategrey: "rgb(112, 128, 144)", snow: "rgb(255, 250, 250)", springgreen: "rgb( 0, 255, 127)", steelblue: "rgb( 70, 130, 180)", tan: "rgb(210, 180, 140)", teal: "rgb( 0, 128, 128)", thistle: "rgb(216, 191, 216)", tomato: "rgb(255, 99, 71)", turquoise: "rgb( 64, 224, 208)", violet: "rgb(238, 130, 238)", wheat: "rgb(245, 222, 179)", white: "rgb(255, 255, 255)", whitesmoke: "rgb(245, 245, 245)", yellow: "rgb(255, 255, 0)", yellowgreen: "rgb(154, 205, 50)" }; a.jqplot.AxisLabelRenderer = function (b) { a.jqplot.ElemContainer.call(this); this.axis; this.show = true; this.label = ""; this.fontFamily = null; this.fontSize = null; this.textColor = null; this._elem; this.escapeHTML = false; a.extend(true, this, b) }; a.jqplot.AxisLabelRenderer.prototype = new a.jqplot.ElemContainer; a.jqplot.AxisLabelRenderer.prototype.constructor = a.jqplot.AxisLabelRenderer; a.jqplot.AxisLabelRenderer.prototype.init = function (b) { a.extend(true, this, b) }; a.jqplot.AxisLabelRenderer.prototype.draw = function (b, c) { if (this._elem) { this._elem.emptyForce(); this._elem = null } this._elem = a('<div style="position:absolute;" class="jqplot-' + this.axis + '-label"></div>'); if (Number(this.label)) { this._elem.css("white-space", "nowrap") } if (!this.escapeHTML) { this._elem.html(this.label) } else { this._elem.text(this.label) } if (this.fontFamily) { this._elem.css("font-family", this.fontFamily) } if (this.fontSize) { this._elem.css("font-size", this.fontSize) } if (this.textColor) { this._elem.css("color", this.textColor) } return this._elem }; a.jqplot.AxisLabelRenderer.prototype.pack = function () { }; a.jqplot.AxisTickRenderer = function (b) { a.jqplot.ElemContainer.call(this); this.mark = "outside"; this.axis; this.showMark = true; this.showGridline = true; this.isMinorTick = false; this.size = 4; this.markSize = 6; this.show = true; this.showLabel = true; this.label = null; this.value = null; this._styles = {}; this.formatter = a.jqplot.DefaultTickFormatter; this.prefix = ""; this.formatString = ""; this.fontFamily; this.fontSize; this.textColor; this.escapeHTML = false; this._elem; this._breakTick = false; a.extend(true, this, b) }; a.jqplot.AxisTickRenderer.prototype.init = function (b) { a.extend(true, this, b) }; a.jqplot.AxisTickRenderer.prototype = new a.jqplot.ElemContainer; a.jqplot.AxisTickRenderer.prototype.constructor = a.jqplot.AxisTickRenderer; a.jqplot.AxisTickRenderer.prototype.setTick = function (a, b, c) { this.value = a; this.axis = b; if (c) { this.isMinorTick = true } return this }; a.jqplot.AxisTickRenderer.prototype.draw = function () { if (this.label === null) { this.label = this.prefix + this.formatter(this.formatString, this.value) } var b = { position: "absolute" }; if (Number(this.label)) { b["whitSpace"] = "nowrap" } if (this._elem) { this._elem.emptyForce(); this._elem = null } this._elem = a(document.createElement("div")); this._elem.addClass("jqplot-" + this.axis + "-tick"); if (!this.escapeHTML) { this._elem.html(this.label) } else { this._elem.text(this.label) } this._elem.css(b); for (var c in this._styles) { this._elem.css(c, this._styles[c]) } if (this.fontFamily) { this._elem.css("font-family", this.fontFamily) } if (this.fontSize) { this._elem.css("font-size", this.fontSize) } if (this.textColor) { this._elem.css("color", this.textColor) } if (this._breakTick) { this._elem.addClass("jqplot-breakTick") } return this._elem }; a.jqplot.DefaultTickFormatter = function (b, c) { if (typeof c == "number") { if (!b) { b = a.jqplot.config.defaultTickFormatString } return a.jqplot.sprintf(b, c) } else { return String(c) } }; a.jqplot.AxisTickRenderer.prototype.pack = function () { }; a.jqplot.CanvasGridRenderer = function () { this.shadowRenderer = new a.jqplot.ShadowRenderer }; a.jqplot.CanvasGridRenderer.prototype.init = function (b) { this._ctx; a.extend(true, this, b); var c = { lineJoin: "miter", lineCap: "round", fill: false, isarc: false, angle: this.shadowAngle, offset: this.shadowOffset, alpha: this.shadowAlpha, depth: this.shadowDepth, lineWidth: this.shadowWidth, closePath: false, strokeStyle: this.shadowColor }; this.renderer.shadowRenderer.init(c) }; a.jqplot.CanvasGridRenderer.prototype.createElement = function (c) { var d; if (this._elem) { if (a.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== b) { d = this._elem.get(0); window.G_vmlCanvasManager.uninitElement(d); d = null } this._elem.emptyForce(); this._elem = null } d = c.canvasManager.getCanvas(); var e = this._plotDimensions.width; var f = this._plotDimensions.height; d.width = e; d.height = f; this._elem = a(d); this._elem.addClass("jqplot-grid-canvas"); this._elem.css({ position: "absolute", left: 0, top: 0 }); d = c.canvasManager.initCanvas(d); this._top = this._offsets.top; this._bottom = f - this._offsets.bottom; this._left = this._offsets.left; this._right = e - this._offsets.right; this._width = this._right - this._left; this._height = this._bottom - this._top; d = null; return this._elem }; a.jqplot.CanvasGridRenderer.prototype.draw = function () { function v(c, d, e, f, g) { b.save(); g = g || {}; if (g.lineWidth == null || g.lineWidth != 0) { a.extend(true, b, g); b.beginPath(); b.moveTo(c, d); b.lineTo(e, f); b.stroke(); b.restore() } } this._ctx = this._elem.get(0).getContext("2d"); var b = this._ctx; var c = this._axes; b.save(); b.clearRect(0, 0, this._plotDimensions.width, this._plotDimensions.height); b.fillStyle = this.backgroundColor || this.background; b.fillRect(this._left, this._top, this._width, this._height); b.save(); b.lineJoin = "miter"; b.lineCap = "butt"; b.lineWidth = this.gridLineWidth; b.strokeStyle = this.gridLineColor; var d, e, f, g; var h = ["xaxis", "yaxis", "x2axis", "y2axis"]; for (var i = 4; i > 0; i--) { var j = h[i - 1]; var k = c[j]; var l = k._ticks; var m = l.length; if (k.show) { if (k.drawBaseline) { var n = {}; if (k.baselineWidth !== null) { n.lineWidth = k.baselineWidth } if (k.baselineColor !== null) { n.strokeStyle = k.baselineColor } switch (j) { case "xaxis": v(this._left, this._bottom, this._right, this._bottom, n); break; case "yaxis": v(this._left, this._bottom, this._left, this._top, n); break; case "x2axis": v(this._left, this._bottom, this._right, this._bottom, n); break; case "y2axis": v(this._right, this._bottom, this._right, this._top, n); break } } for (var o = m; o > 0; o--) { var p = l[o - 1]; if (p.show) { var q = Math.round(k.u2p(p.value)) + .5; switch (j) { case "xaxis": if (p.showGridline && this.drawGridlines && (!p.isMinorTick && k.drawMajorGridlines || p.isMinorTick && k.drawMinorGridlines)) { v(q, this._top, q, this._bottom) } if (p.showMark && p.mark && (!p.isMinorTick && k.drawMajorTickMarks || p.isMinorTick && k.drawMinorTickMarks)) { f = p.markSize; g = p.mark; var q = Math.round(k.u2p(p.value)) + .5; switch (g) { case "outside": d = this._bottom; e = this._bottom + f; break; case "inside": d = this._bottom - f; e = this._bottom; break; case "cross": d = this._bottom - f; e = this._bottom + f; break; default: d = this._bottom; e = this._bottom + f; break } if (this.shadow) { this.renderer.shadowRenderer.draw(b, [[q, d], [q, e]], { lineCap: "butt", lineWidth: this.gridLineWidth, offset: this.gridLineWidth * .75, depth: 2, fill: false, closePath: false }) } v(q, d, q, e) } break; case "yaxis": if (p.showGridline && this.drawGridlines && (!p.isMinorTick && k.drawMajorGridlines || p.isMinorTick && k.drawMinorGridlines)) { v(this._right, q, this._left, q) } if (p.showMark && p.mark && (!p.isMinorTick && k.drawMajorTickMarks || p.isMinorTick && k.drawMinorTickMarks)) { f = p.markSize; g = p.mark; var q = Math.round(k.u2p(p.value)) + .5; switch (g) { case "outside": d = this._left - f; e = this._left; break; case "inside": d = this._left; e = this._left + f; break; case "cross": d = this._left - f; e = this._left + f; break; default: d = this._left - f; e = this._left; break } if (this.shadow) { this.renderer.shadowRenderer.draw(b, [[d, q], [e, q]], { lineCap: "butt", lineWidth: this.gridLineWidth * 1.5, offset: this.gridLineWidth * .75, fill: false, closePath: false }) } v(d, q, e, q, { strokeStyle: k.borderColor }) } break; case "x2axis": if (p.showGridline && this.drawGridlines && (!p.isMinorTick && k.drawMajorGridlines || p.isMinorTick && k.drawMinorGridlines)) { v(q, this._bottom, q, this._top) } if (p.showMark && p.mark && (!p.isMinorTick && k.drawMajorTickMarks || p.isMinorTick && k.drawMinorTickMarks)) { f = p.markSize; g = p.mark; var q = Math.round(k.u2p(p.value)) + .5; switch (g) { case "outside": d = this._top - f; e = this._top; break; case "inside": d = this._top; e = this._top + f; break; case "cross": d = this._top - f; e = this._top + f; break; default: d = this._top - f; e = this._top; break } if (this.shadow) { this.renderer.shadowRenderer.draw(b, [[q, d], [q, e]], { lineCap: "butt", lineWidth: this.gridLineWidth, offset: this.gridLineWidth * .75, depth: 2, fill: false, closePath: false }) } v(q, d, q, e) } break; case "y2axis": if (p.showGridline && this.drawGridlines && (!p.isMinorTick && k.drawMajorGridlines || p.isMinorTick && k.drawMinorGridlines)) { v(this._left, q, this._right, q) } if (p.showMark && p.mark && (!p.isMinorTick && k.drawMajorTickMarks || p.isMinorTick && k.drawMinorTickMarks)) { f = p.markSize; g = p.mark; var q = Math.round(k.u2p(p.value)) + .5; switch (g) { case "outside": d = this._right; e = this._right + f; break; case "inside": d = this._right - f; e = this._right; break; case "cross": d = this._right - f; e = this._right + f; break; default: d = this._right; e = this._right + f; break } if (this.shadow) { this.renderer.shadowRenderer.draw(b, [[d, q], [e, q]], { lineCap: "butt", lineWidth: this.gridLineWidth * 1.5, offset: this.gridLineWidth * .75, fill: false, closePath: false }) } v(d, q, e, q, { strokeStyle: k.borderColor }) } break; default: break } } } p = null } k = null; l = null } h = ["y3axis", "y4axis", "y5axis", "y6axis", "y7axis", "y8axis", "y9axis", "yMidAxis"]; for (var i = 7; i > 0; i--) { var k = c[h[i - 1]]; var l = k._ticks; if (k.show) { var r = l[k.numberTicks - 1]; var s = l[0]; var t = k.getLeft(); var u = [[t, r.getTop() + r.getHeight() / 2], [t, s.getTop() + s.getHeight() / 2 + 1]]; if (this.shadow) { this.renderer.shadowRenderer.draw(b, u, { lineCap: "butt", fill: false, closePath: false }) } v(u[0][0], u[0][1], u[1][0], u[1][1], { lineCap: "butt", strokeStyle: k.borderColor, lineWidth: k.borderWidth }); for (var o = l.length; o > 0; o--) { var p = l[o - 1]; f = p.markSize; g = p.mark; var q = Math.round(k.u2p(p.value)) + .5; if (p.showMark && p.mark) { switch (g) { case "outside": d = t; e = t + f; break; case "inside": d = t - f; e = t; break; case "cross": d = t - f; e = t + f; break; default: d = t; e = t + f; break } u = [[d, q], [e, q]]; if (this.shadow) { this.renderer.shadowRenderer.draw(b, u, { lineCap: "butt", lineWidth: this.gridLineWidth * 1.5, offset: this.gridLineWidth * .75, fill: false, closePath: false }) } v(d, q, e, q, { strokeStyle: k.borderColor }) } p = null } s = null } k = null; l = null } b.restore(); if (this.shadow) { var u = [[this._left, this._bottom], [this._right, this._bottom], [this._right, this._top]]; this.renderer.shadowRenderer.draw(b, u) } if (this.borderWidth != 0 && this.drawBorder) { v(this._left, this._top, this._right, this._top, { lineCap: "round", strokeStyle: c.x2axis.borderColor, lineWidth: c.x2axis.borderWidth }); v(this._right, this._top, this._right, this._bottom, { lineCap: "round", strokeStyle: c.y2axis.borderColor, lineWidth: c.y2axis.borderWidth }); v(this._right, this._bottom, this._left, this._bottom, { lineCap: "round", strokeStyle: c.xaxis.borderColor, lineWidth: c.xaxis.borderWidth }); v(this._left, this._bottom, this._left, this._top, { lineCap: "round", strokeStyle: c.yaxis.borderColor, lineWidth: c.yaxis.borderWidth }) } b.restore(); b = null; c = null }; a.jqplot.DivTitleRenderer = function () { }; a.jqplot.DivTitleRenderer.prototype.init = function (b) { a.extend(true, this, b) }; a.jqplot.DivTitleRenderer.prototype.draw = function () { if (this._elem) { this._elem.emptyForce(); this._elem = null } var b = this.renderer; var c = document.createElement("div"); this._elem = a(c); this._elem.addClass("jqplot-title"); if (!this.text) { this.show = false; this._elem.height(0); this._elem.width(0) } else if (this.text) { var d; if (this.color) { d = this.color } else if (this.textColor) { d = this.textColor } var e = { position: "absolute", top: "0px", left: "0px" }; if (this._plotWidth) { e["width"] = this._plotWidth + "px" } if (this.fontSize) { e["fontSize"] = this.fontSize } if (typeof this.textAlign === "string") { e["textAlign"] = this.textAlign } else { e["textAlign"] = "center" } if (d) { e["color"] = d } if (this.paddingBottom) { e["paddingBottom"] = this.paddingBottom } if (this.fontFamily) { e["fontFamily"] = this.fontFamily } this._elem.css(e); if (this.escapeHtml) { this._elem.text(this.text) } else { this._elem.html(this.text) } } c = null; return this._elem }; a.jqplot.DivTitleRenderer.prototype.pack = function () { }; var j = .1; a.jqplot.LinePattern = function (b, c) { var d = { dotted: [j, a.jqplot.config.dotGapLength], dashed: [a.jqplot.config.dashLength, a.jqplot.config.gapLength], solid: null }; if (typeof c === "string") { if (c[0] === "." || c[0] === "-") { var e = c; c = []; for (var f = 0, g = e.length; f < g; f++) { if (e[f] === ".") { c.push(j) } else if (e[f] === "-") { c.push(a.jqplot.config.dashLength) } else { continue } c.push(a.jqplot.config.gapLength) } } else { c = d[c] } } if (!(c && c.length)) { return b } var h = 0; var i = c[0]; var k = 0; var l = 0; var m = 0; var n = 0; var o = function (a, c) { b.moveTo(a, c); k = a; l = c; m = a; n = c }; var p = function (a, d) { var e = b.lineWidth; var f = a - k; var g = d - l; var j = Math.sqrt(f * f + g * g); if (j > 0 && e > 0) { f /= j; g /= j; while (true) { var m = e * i; if (m < j) { k += m * f; l += m * g; if ((h & 1) == 0) { b.lineTo(k, l) } else { b.moveTo(k, l) } j -= m; h++; if (h >= c.length) { h = 0 } i = c[h] } else { k = a; l = d; if ((h & 1) == 0) { b.lineTo(k, l) } else { b.moveTo(k, l) } i -= j / e; break } } } }; var q = function () { b.beginPath() }; var r = function () { p(m, n) }; return { moveTo: o, lineTo: p, beginPath: q, closePath: r} }; a.jqplot.LineRenderer = function () { this.shapeRenderer = new a.jqplot.ShapeRenderer; this.shadowRenderer = new a.jqplot.ShadowRenderer }; a.jqplot.LineRenderer.prototype.init = function (b, c) { b = b || {}; this._type = "line"; this.renderer.animation = { show: false, direction: "left", speed: 2500, _supported: true }; this.renderer.smooth = false; this.renderer.tension = null; this.renderer.constrainSmoothing = true; this.renderer._smoothedData = []; this.renderer._smoothedPlotData = []; this.renderer._hiBandGridData = []; this.renderer._lowBandGridData = []; this.renderer._hiBandSmoothedData = []; this.renderer._lowBandSmoothedData = []; this.renderer.bandData = []; this.renderer.bands = { show: false, hiData: [], lowData: [], color: this.color, showLines: false, fill: true, fillColor: null, _min: null, _max: null, interval: "3%" }; var d = { highlightMouseOver: b.highlightMouseOver, highlightMouseDown: b.highlightMouseDown, highlightColor: b.highlightColor }; delete b.highlightMouseOver; delete b.highlightMouseDown; delete b.highlightColor; a.extend(true, this.renderer, b); this.renderer.options = b; if (this.renderer.bandData.length > 1 && (!b.bands || b.bands.show == null)) { this.renderer.bands.show = true } else if (b.bands && b.bands.show == null && b.bands.interval != null) { this.renderer.bands.show = true } if (this.fill) { this.renderer.bands.show = false } if (this.renderer.bands.show) { this.renderer.initBands.call(this, this.renderer.options, c) } if (this._stack) { this.renderer.smooth = false } var e = { lineJoin: this.lineJoin, lineCap: this.lineCap, fill: this.fill, isarc: false, strokeStyle: this.color, fillStyle: this.fillColor, lineWidth: this.lineWidth, linePattern: this.linePattern, closePath: this.fill }; this.renderer.shapeRenderer.init(e); var f = b.shadowOffset; if (f == null) { if (this.lineWidth > 2.5) { f = 1.25 * (1 + (Math.atan(this.lineWidth / 2.5) / .785398163 - 1) * .6) } else { f = 1.25 * Math.atan(this.lineWidth / 2.5) / .785398163 } } var g = { lineJoin: this.lineJoin, lineCap: this.lineCap, fill: this.fill, isarc: false, angle: this.shadowAngle, offset: f, alpha: this.shadowAlpha, depth: this.shadowDepth, lineWidth: this.lineWidth, linePattern: this.linePattern, closePath: this.fill }; this.renderer.shadowRenderer.init(g); this._areaPoints = []; this._boundingBox = [[], []]; if (!this.isTrendline && this.fill || this.renderer.bands.show) { this.highlightMouseOver = true; this.highlightMouseDown = false; this.highlightColor = null; if (d.highlightMouseDown && d.highlightMouseOver == null) { d.highlightMouseOver = false } a.extend(true, this, { highlightMouseOver: d.highlightMouseOver, highlightMouseDown: d.highlightMouseDown, highlightColor: d.highlightColor }); if (!this.highlightColor) { var h = this.renderer.bands.show ? this.renderer.bands.fillColor : this.fillColor; this.highlightColor = a.jqplot.computeHighlightColors(h) } if (this.highlighter) { this.highlighter.show = false } } if (!this.isTrendline && c) { c.plugins.lineRenderer = {}; c.postInitHooks.addOnce(p); c.postDrawHooks.addOnce(q); c.eventListenerHooks.addOnce("jqplotMouseMove", t); c.eventListenerHooks.addOnce("jqplotMouseDown", u); c.eventListenerHooks.addOnce("jqplotMouseUp", v); c.eventListenerHooks.addOnce("jqplotClick", w); c.eventListenerHooks.addOnce("jqplotRightClick", x) } }; a.jqplot.LineRenderer.prototype.initBands = function (b, c) { var d = b.bandData || []; var e = this.renderer.bands; e.hiData = []; e.lowData = []; var f = this.data; e._max = null; e._min = null; if (d.length == 2) { if (a.isArray(d[0][0])) { var g; var h = 0, i = 0; for (var j = 0, k = d[0].length; j < k; j++) { g = d[0][j]; if (g[1] != null && g[1] > e._max || e._max == null) { e._max = g[1] } if (g[1] != null && g[1] < e._min || e._min == null) { e._min = g[1] } } for (var j = 0, k = d[1].length; j < k; j++) { g = d[1][j]; if (g[1] != null && g[1] > e._max || e._max == null) { e._max = g[1]; i = 1 } if (g[1] != null && g[1] < e._min || e._min == null) { e._min = g[1]; h = 1 } } if (i === h) { e.show = false } e.hiData = d[i]; e.lowData = d[h] } else if (d[0].length === f.length && d[1].length === f.length) { var l = d[0][0] > d[1][0] ? 0 : 1; var m = l ? 0 : 1; for (var j = 0, k = f.length; j < k; j++) { e.hiData.push([f[j][0], d[l][j]]); e.lowData.push([f[j][0], d[m][j]]) } } else { e.show = false } } else if (d.length > 2 && !a.isArray(d[0][0])) { var l = d[0][0] > d[0][1] ? 0 : 1; var m = l ? 0 : 1; for (var j = 0, k = d.length; j < k; j++) { e.hiData.push([f[j][0], d[j][l]]); e.lowData.push([f[j][0], d[j][m]]) } } else { var n = e.interval; var o = null; var p = null; var q = null; var r = null; if (a.isArray(n)) { o = n[0]; p = n[1] } else { o = n } if (isNaN(o)) { if (o.charAt(o.length - 1) === "%") { q = "multiply"; o = parseFloat(o) / 100 + 1 } } else { o = parseFloat(o); q = "add" } if (p !== null && isNaN(p)) { if (p.charAt(p.length - 1) === "%") { r = "multiply"; p = parseFloat(p) / 100 + 1 } } else if (p !== null) { p = parseFloat(p); r = "add" } if (o !== null) { if (p === null) { p = -o; r = q; if (r === "multiply") { p += 2 } } if (o < p) { var s = o; o = p; p = s; s = q; q = r; r = s } for (var j = 0, k = f.length; j < k; j++) { switch (q) { case "add": e.hiData.push([f[j][0], f[j][1] + o]); break; case "multiply": e.hiData.push([f[j][0], f[j][1] * o]); break } switch (r) { case "add": e.lowData.push([f[j][0], f[j][1] + p]); break; case "multiply": e.lowData.push([f[j][0], f[j][1] * p]); break } } } else { e.show = false } } var t = e.hiData; var u = e.lowData; for (var j = 0, k = t.length; j < k; j++) { if (t[j][1] != null && t[j][1] > e._max || e._max == null) { e._max = t[j][1] } } for (var j = 0, k = u.length; j < k; j++) { if (u[j][1] != null && u[j][1] < e._min || e._min == null) { e._min = u[j][1] } } if (e.fillColor === null) { var v = a.jqplot.getColorComponents(e.color); v[3] = v[3] * .5; e.fillColor = "rgba(" + v[0] + ", " + v[1] + ", " + v[2] + ", " + v[3] + ")" } }; a.jqplot.LineRenderer.prototype.setGridData = function (a) { var b = this._xaxis.series_u2p; var c = this._yaxis.series_u2p; var d = this._plotData; var e = this._prevPlotData; this.gridData = []; this._prevGridData = []; this.renderer._smoothedData = []; this.renderer._smoothedPlotData = []; this.renderer._hiBandGridData = []; this.renderer._lowBandGridData = []; this.renderer._hiBandSmoothedData = []; this.renderer._lowBandSmoothedData = []; var f = this.renderer.bands; var g = false; for (var h = 0, i = this.data.length; h < i; h++) { if (d[h][0] != null && d[h][1] != null) { this.gridData.push([b.call(this._xaxis, d[h][0]), c.call(this._yaxis, d[h][1])]) } else if (d[h][0] == null) { g = true; this.gridData.push([null, c.call(this._yaxis, d[h][1])]) } else if (d[h][1] == null) { g = true; this.gridData.push([b.call(this._xaxis, d[h][0]), null]) } if (e[h] != null && e[h][0] != null && e[h][1] != null) { this._prevGridData.push([b.call(this._xaxis, e[h][0]), c.call(this._yaxis, e[h][1])]) } else if (e[h] != null && e[h][0] == null) { this._prevGridData.push([null, c.call(this._yaxis, e[h][1])]) } else if (e[h] != null && e[h][0] != null && e[h][1] == null) { this._prevGridData.push([b.call(this._xaxis, e[h][0]), null]) } } if (g) { this.renderer.smooth = false; if (this._type === "line") { f.show = false } } if (this._type === "line" && f.show) { for (var h = 0, i = f.hiData.length; h < i; h++) { this.renderer._hiBandGridData.push([b.call(this._xaxis, f.hiData[h][0]), c.call(this._yaxis, f.hiData[h][1])]) } for (var h = 0, i = f.lowData.length; h < i; h++) { this.renderer._lowBandGridData.push([b.call(this._xaxis, f.lowData[h][0]), c.call(this._yaxis, f.lowData[h][1])]) } } if (this._type === "line" && this.renderer.smooth && this.gridData.length > 2) { var j; if (this.renderer.constrainSmoothing) { j = n.call(this, this.gridData); this.renderer._smoothedData = j[0]; this.renderer._smoothedPlotData = j[1]; if (f.show) { j = n.call(this, this.renderer._hiBandGridData); this.renderer._hiBandSmoothedData = j[0]; j = n.call(this, this.renderer._lowBandGridData); this.renderer._lowBandSmoothedData = j[0] } j = null } else { j = o.call(this, this.gridData); this.renderer._smoothedData = j[0]; this.renderer._smoothedPlotData = j[1]; if (f.show) { j = o.call(this, this.renderer._hiBandGridData); this.renderer._hiBandSmoothedData = j[0]; j = o.call(this, this.renderer._lowBandGridData); this.renderer._lowBandSmoothedData = j[0] } j = null } } }; a.jqplot.LineRenderer.prototype.makeGridData = function (a, b) { var c = this._xaxis.series_u2p; var d = this._yaxis.series_u2p; var e = []; var f = []; this.renderer._smoothedData = []; this.renderer._smoothedPlotData = []; this.renderer._hiBandGridData = []; this.renderer._lowBandGridData = []; this.renderer._hiBandSmoothedData = []; this.renderer._lowBandSmoothedData = []; var g = this.renderer.bands; var h = false; for (var i = 0; i < a.length; i++) { if (a[i][0] != null && a[i][1] != null) { e.push([c.call(this._xaxis, a[i][0]), d.call(this._yaxis, a[i][1])]) } else if (a[i][0] == null) { h = true; e.push([null, d.call(this._yaxis, a[i][1])]) } else if (a[i][1] == null) { h = true; e.push([c.call(this._xaxis, a[i][0]), null]) } } if (h) { this.renderer.smooth = false; if (this._type === "line") { g.show = false } } if (this._type === "line" && g.show) { for (var i = 0, j = g.hiData.length; i < j; i++) { this.renderer._hiBandGridData.push([c.call(this._xaxis, g.hiData[i][0]), d.call(this._yaxis, g.hiData[i][1])]) } for (var i = 0, j = g.lowData.length; i < j; i++) { this.renderer._lowBandGridData.push([c.call(this._xaxis, g.lowData[i][0]), d.call(this._yaxis, g.lowData[i][1])]) } } if (this._type === "line" && this.renderer.smooth && e.length > 2) { var k; if (this.renderer.constrainSmoothing) { k = n.call(this, e); this.renderer._smoothedData = k[0]; this.renderer._smoothedPlotData = k[1]; if (g.show) { k = n.call(this, this.renderer._hiBandGridData); this.renderer._hiBandSmoothedData = k[0]; k = n.call(this, this.renderer._lowBandGridData); this.renderer._lowBandSmoothedData = k[0] } k = null } else { k = o.call(this, e); this.renderer._smoothedData = k[0]; this.renderer._smoothedPlotData = k[1]; if (g.show) { k = o.call(this, this.renderer._hiBandGridData); this.renderer._hiBandSmoothedData = k[0]; k = o.call(this, this.renderer._lowBandGridData); this.renderer._lowBandSmoothedData = k[0] } k = null } } return e }; a.jqplot.LineRenderer.prototype.draw = function (c, d, e, f) { var g; var h = a.extend(true, {}, e); var i = h.shadow != b ? h.shadow : this.shadow; var j = h.showLine != b ? h.showLine : this.showLine; var k = h.fill != b ? h.fill : this.fill; var l = h.fillAndStroke != b ? h.fillAndStroke : this.fillAndStroke; var m, n, o, p; c.save(); if (d.length) { if (j) { if (k) { if (this.fillToZero) { var q = this.negativeColor; if (!this.useNegativeColors) { q = h.fillStyle } var r = false; var s = h.fillStyle; if (l) { var t = d.slice(0) } if (this.index == 0 || !this._stack) { var u = []; var v = this.renderer.smooth ? this.renderer._smoothedPlotData : this._plotData; this._areaPoints = []; var w = this._yaxis.series_u2p(this.fillToValue); var x = this._xaxis.series_u2p(this.fillToValue); h.closePath = true; if (this.fillAxis == "y") { u.push([d[0][0], w]); this._areaPoints.push([d[0][0], w]); for (var g = 0; g < d.length - 1; g++) { u.push(d[g]); this._areaPoints.push(d[g]); if (v[g][1] * v[g + 1][1] < 0) { if (v[g][1] < 0) { r = true; h.fillStyle = q } else { r = false; h.fillStyle = s } var y = d[g][0] + (d[g + 1][0] - d[g][0]) * (w - d[g][1]) / (d[g + 1][1] - d[g][1]); u.push([y, w]); this._areaPoints.push([y, w]); if (i) { this.renderer.shadowRenderer.draw(c, u, h) } this.renderer.shapeRenderer.draw(c, u, h); u = [[y, w]] } } if (v[d.length - 1][1] < 0) { r = true; h.fillStyle = q } else { r = false; h.fillStyle = s } u.push(d[d.length - 1]); this._areaPoints.push(d[d.length - 1]); u.push([d[d.length - 1][0], w]); this._areaPoints.push([d[d.length - 1][0], w]) } if (i) { this.renderer.shadowRenderer.draw(c, u, h) } this.renderer.shapeRenderer.draw(c, u, h) } else { var z = this._prevGridData; for (var g = z.length; g > 0; g--) { d.push(z[g - 1]) } if (i) { this.renderer.shadowRenderer.draw(c, d, h) } this._areaPoints = d; this.renderer.shapeRenderer.draw(c, d, h) } } else { if (l) { var t = d.slice(0) } if (this.index == 0 || !this._stack) { var A = c.canvas.height; d.unshift([d[0][0], A]); var B = d.length; d.push([d[B - 1][0], A]) } else { var z = this._prevGridData; for (var g = z.length; g > 0; g--) { d.push(z[g - 1]) } } this._areaPoints = d; if (i) { this.renderer.shadowRenderer.draw(c, d, h) } this.renderer.shapeRenderer.draw(c, d, h) } if (l) { var C = a.extend(true, {}, h, { fill: false, closePath: false }); this.renderer.shapeRenderer.draw(c, t, C); if (this.markerRenderer.show) { if (this.renderer.smooth) { t = this.gridData } for (g = 0; g < t.length; g++) { this.markerRenderer.draw(t[g][0], t[g][1], c, h.markerOptions) } } } } else { if (this.renderer.bands.show) { var D; var E = a.extend(true, {}, h); if (this.renderer.bands.showLines) { D = this.renderer.smooth ? this.renderer._hiBandSmoothedData : this.renderer._hiBandGridData; this.renderer.shapeRenderer.draw(c, D, h); D = this.renderer.smooth ? this.renderer._lowBandSmoothedData : this.renderer._lowBandGridData; this.renderer.shapeRenderer.draw(c, D, E) } if (this.renderer.bands.fill) { if (this.renderer.smooth) { D = this.renderer._hiBandSmoothedData.concat(this.renderer._lowBandSmoothedData.reverse()) } else { D = this.renderer._hiBandGridData.concat(this.renderer._lowBandGridData.reverse()) } this._areaPoints = D; E.closePath = true; E.fill = true; E.fillStyle = this.renderer.bands.fillColor; this.renderer.shapeRenderer.draw(c, D, E) } } if (i) { this.renderer.shadowRenderer.draw(c, d, h) } this.renderer.shapeRenderer.draw(c, d, h) } } var m = o = n = p = null; for (g = 0; g < this._areaPoints.length; g++) { var F = this._areaPoints[g]; if (m > F[0] || m == null) { m = F[0] } if (p < F[1] || p == null) { p = F[1] } if (o < F[0] || o == null) { o = F[0] } if (n > F[1] || n == null) { n = F[1] } } if (this.type === "line" && this.renderer.bands.show) { p = this._yaxis.series_u2p(this.renderer.bands._min); n = this._yaxis.series_u2p(this.renderer.bands._max) } this._boundingBox = [[m, p], [o, n]]; if (this.markerRenderer.show && !k) { if (this.renderer.smooth) { d = this.gridData } for (g = 0; g < d.length; g++) { if (d[g][0] != null && d[g][1] != null) { this.markerRenderer.draw(d[g][0], d[g][1], c, h.markerOptions) } } } } c.restore() }; a.jqplot.LineRenderer.prototype.drawShadow = function (a, b, c) { }; a.jqplot.LinearAxisRenderer = function () { }; a.jqplot.LinearAxisRenderer.prototype.init = function (b) { this.breakPoints = null; this.breakTickLabel = "≈"; this.drawBaseline = true; this.baselineWidth = null; this.baselineColor = null; this.forceTickAt0 = false; this.forceTickAt100 = false; this.tickInset = 0; this.minorTicks = 0; this.alignTicks = false; this._autoFormatString = ""; this._overrideFormatString = false; this._scalefact = 1; a.extend(true, this, b); if (this.breakPoints) { if (!a.isArray(this.breakPoints)) { this.breakPoints = null } else if (this.breakPoints.length < 2 || this.breakPoints[1] <= this.breakPoints[0]) { this.breakPoints = null } } if (this.numberTicks != null && this.numberTicks < 2) { this.numberTicks = 2 } this.resetDataBounds() }; a.jqplot.LinearAxisRenderer.prototype.draw = function (b, c) { if (this.show) { this.renderer.createTicks.call(this, c); var d = 0; var e; if (this._elem) { this._elem.emptyForce(); this._elem = null } this._elem = a(document.createElement("div")); this._elem.addClass("jqplot-axis jqplot-" + this.name); this._elem.css("position", "absolute"); if (this.name == "xaxis" || this.name == "x2axis") { this._elem.width(this._plotDimensions.width) } else { this._elem.height(this._plotDimensions.height) } this.labelOptions.axis = this.name; this._label = new this.labelRenderer(this.labelOptions); if (this._label.show) { var f = this._label.draw(b, c); f.appendTo(this._elem); f = null } var g = this._ticks; var h; for (var i = 0; i < g.length; i++) { h = g[i]; if (h.show && h.showLabel && (!h.isMinorTick || this.showMinorTicks)) { this._elem.append(h.draw(b, c)) } } h = null; g = null } return this._elem }; a.jqplot.LinearAxisRenderer.prototype.reset = function () { this.min = this._options.min; this.max = this._options.max; this.tickInterval = this._options.tickInterval; this.numberTicks = this._options.numberTicks; this._autoFormatString = ""; if (this._overrideFormatString && this.tickOptions && this.tickOptions.formatString) { this.tickOptions.formatString = "" } }; a.jqplot.LinearAxisRenderer.prototype.set = function () { var b = 0; var c; var d = 0; var e = 0; var f = this._label == null ? false : this._label.show; if (this.show) { var g = this._ticks; var h; for (var i = 0; i < g.length; i++) { h = g[i]; if (!h._breakTick && h.show && h.showLabel && (!h.isMinorTick || this.showMinorTicks)) { if (this.name == "xaxis" || this.name == "x2axis") { c = h._elem.outerHeight(true) } else { c = h._elem.outerWidth(true) } if (c > b) { b = c } } } h = null; g = null; if (f) { d = this._label._elem.outerWidth(true); e = this._label._elem.outerHeight(true) } if (this.name == "xaxis") { b = b + e; this._elem.css({ height: b + "px", left: "0px", bottom: "0px" }) } else if (this.name == "x2axis") { b = b + e; this._elem.css({ height: b + "px", left: "0px", top: "0px" }) } else if (this.name == "yaxis") { b = b + d; this._elem.css({ width: b + "px", left: "0px", top: "0px" }); if (f && this._label.constructor == a.jqplot.AxisLabelRenderer) { this._label._elem.css("width", d + "px") } } else { b = b + d; this._elem.css({ width: b + "px", right: "0px", top: "0px" }); if (f && this._label.constructor == a.jqplot.AxisLabelRenderer) { this._label._elem.css("width", d + "px") } } } }; a.jqplot.LinearAxisRenderer.prototype.createTicks = function (b) { var c = this._ticks; var d = this.ticks; var e = this.name; var f = this._dataBounds; var g = this.name.charAt(0) === "x" ? this._plotDimensions.width : this._plotDimensions.height; var h; var i, j; var k, l; var m, n; var o = this.min; var p = this.max; var q = this.numberTicks; var r = this.tickInterval; var s = 30; this._scalefact = (Math.max(g, s + 1) - s) / 300; if (d.length) { for (n = 0; n < d.length; n++) { var t = d[n]; var u = new this.tickRenderer(this.tickOptions); if (a.isArray(t)) { u.value = t[0]; if (this.breakPoints) { if (t[0] == this.breakPoints[0]) { u.label = this.breakTickLabel; u._breakTick = true; u.showGridline = false; u.showMark = false } else if (t[0] > this.breakPoints[0] && t[0] <= this.breakPoints[1]) { u.show = false; u.showGridline = false; u.label = t[1] } else { u.label = t[1] } } else { u.label = t[1] } u.setTick(t[0], this.name); this._ticks.push(u) } else if (a.isPlainObject(t)) { a.extend(true, u, t); u.axis = this.name; this._ticks.push(u) } else { u.value = t; if (this.breakPoints) { if (t == this.breakPoints[0]) { u.label = this.breakTickLabel; u._breakTick = true; u.showGridline = false; u.showMark = false } else if (t > this.breakPoints[0] && t <= this.breakPoints[1]) { u.show = false; u.showGridline = false } } u.setTick(t, this.name); this._ticks.push(u) } } this.numberTicks = d.length; this.min = this._ticks[0].value; this.max = this._ticks[this.numberTicks - 1].value; this.tickInterval = (this.max - this.min) / (this.numberTicks - 1) } else { if (e == "xaxis" || e == "x2axis") { g = this._plotDimensions.width } else { g = this._plotDimensions.height } var v = this.numberTicks; if (this.alignTicks) { if (this.name === "x2axis" && b.axes.xaxis.show) { v = b.axes.xaxis.numberTicks } else if (this.name.charAt(0) === "y" && this.name !== "yaxis" && this.name !== "yMidAxis" && b.axes.yaxis.show) { v = b.axes.yaxis.numberTicks } } i = this.min != null ? this.min : f.min; j = this.max != null ? this.max : f.max; var w = j - i; var x, y; var z; if (this.tickOptions == null || !this.tickOptions.formatString) { this._overrideFormatString = true } if (this.min == null && this.max == null && this.tickInterval == null && !this.autoscale) { if (this.forceTickAt0) { if (i > 0) { i = 0 } if (j < 0) { j = 0 } } if (this.forceTickAt100) { if (i > 100) { i = 100 } if (j < 100) { j = 100 } } var A = a.jqplot.LinearTickGenerator(i, j, this._scalefact, v); var B = i + w * (this.padMin - 1); var C = j - w * (this.padMax - 1); if (i < B || j > C) { B = i - w * (this.padMin - 1); C = j + w * (this.padMax - 1); A = a.jqplot.LinearTickGenerator(B, C, this._scalefact, v) } this.min = A[0]; this.max = A[1]; this.numberTicks = A[2]; this._autoFormatString = A[3]; this.tickInterval = A[4] } else { if (i == j) { var D = .05; if (i > 0) { D = Math.max(Math.log(i) / Math.LN10, .05) } i -= D; j += D } if (this.autoscale && this.min == null && this.max == null) { var E, F, G; var H = false; var I = false; var J = { min: null, max: null, average: null, stddev: null }; for (var n = 0; n < this._series.length; n++) { var K = this._series[n]; var L = K.fillAxis == "x" ? K._xaxis.name : K._yaxis.name; if (this.name == L) { var M = K._plotValues[K.fillAxis]; var N = M[0]; var O = M[0]; for (var P = 1; P < M.length; P++) { if (M[P] < N) { N = M[P] } else if (M[P] > O) { O = M[P] } } var Q = (O - N) / O; if (K.renderer.constructor == a.jqplot.BarRenderer) { if (N >= 0 && (K.fillToZero || Q > .1)) { H = true } else { H = false; if (K.fill && K.fillToZero && N < 0 && O > 0) { I = true } else { I = false } } } else if (K.fill) { if (N >= 0 && (K.fillToZero || Q > .1)) { H = true } else if (N < 0 && O > 0 && K.fillToZero) { H = false; I = true } else { H = false; I = false } } else if (N < 0) { H = false } } } if (H) { this.numberTicks = 2 + Math.ceil((g - (this.tickSpacing - 1)) / this.tickSpacing); this.min = 0; o = 0; F = j / (this.numberTicks - 1); z = Math.pow(10, Math.abs(Math.floor(Math.log(F) / Math.LN10))); if (F / z == parseInt(F / z, 10)) { F += z } this.tickInterval = Math.ceil(F / z) * z; this.max = this.tickInterval * (this.numberTicks - 1) } else if (I) { this.numberTicks = 2 + Math.ceil((g - (this.tickSpacing - 1)) / this.tickSpacing); var R = Math.ceil(Math.abs(i) / w * (this.numberTicks - 1)); var S = this.numberTicks - 1 - R; F = Math.max(Math.abs(i / R), Math.abs(j / S)); z = Math.pow(10, Math.abs(Math.floor(Math.log(F) / Math.LN10))); this.tickInterval = Math.ceil(F / z) * z; this.max = this.tickInterval * S; this.min = -this.tickInterval * R } else { if (this.numberTicks == null) { if (this.tickInterval) { this.numberTicks = 3 + Math.ceil(w / this.tickInterval) } else { this.numberTicks = 2 + Math.ceil((g - (this.tickSpacing - 1)) / this.tickSpacing) } } if (this.tickInterval == null) { F = w / (this.numberTicks - 1); if (F < 1) { z = Math.pow(10, Math.abs(Math.floor(Math.log(F) / Math.LN10))) } else { z = 1 } this.tickInterval = Math.ceil(F * z * this.pad) / z } else { z = 1 / this.tickInterval } E = this.tickInterval * (this.numberTicks - 1); G = (E - w) / 2; if (this.min == null) { this.min = Math.floor(z * (i - G)) / z } if (this.max == null) { this.max = this.min + E } } var T = a.jqplot.getSignificantFigures(this.tickInterval); var U; if (T.digitsLeft >= T.significantDigits) { U = "%d" } else { var z = Math.max(0, 5 - T.digitsLeft); z = Math.min(z, T.digitsRight); U = "%." + z + "f" } this._autoFormatString = U } else { x = this.min != null ? this.min : i - w * (this.padMin - 1); y = this.max != null ? this.max : j + w * (this.padMax - 1); w = y - x; if (this.numberTicks == null) { if (this.tickInterval != null) { this.numberTicks = Math.ceil((y - x) / this.tickInterval) + 1 } else if (g > 100) { this.numberTicks = parseInt(3 + (g - 100) / 75, 10) } else { this.numberTicks = 2 } } if (this.tickInterval == null) { this.tickInterval = w / (this.numberTicks - 1) } if (this.max == null) { y = x + this.tickInterval * (this.numberTicks - 1) } if (this.min == null) { x = y - this.tickInterval * (this.numberTicks - 1) } var T = a.jqplot.getSignificantFigures(this.tickInterval); var U; if (T.digitsLeft >= T.significantDigits) { U = "%d" } else { var z = Math.max(0, 5 - T.digitsLeft); z = Math.min(z, T.digitsRight); U = "%." + z + "f" } this._autoFormatString = U; this.min = x; this.max = y } if (this.renderer.constructor == a.jqplot.LinearAxisRenderer && this._autoFormatString == "") { w = this.max - this.min; var V = new this.tickRenderer(this.tickOptions); var W = V.formatString || a.jqplot.config.defaultTickFormatString; var W = W.match(a.jqplot.sprintf.regex)[0]; var X = 0; if (W) { if (W.search(/[fFeEgGpP]/) > -1) { var Y = W.match(/\%\.(\d{0,})?[eEfFgGpP]/); if (Y) { X = parseInt(Y[1], 10) } else { X = 6 } } else if (W.search(/[di]/) > -1) { X = 0 } var Z = Math.pow(10, -X); if (this.tickInterval < Z) { if (q == null && r == null) { this.tickInterval = Z; if (p == null && o == null) { this.min = Math.floor(this._dataBounds.min / Z) * Z; if (this.min == this._dataBounds.min) { this.min = this._dataBounds.min - this.tickInterval } this.max = Math.ceil(this._dataBounds.max / Z) * Z; if (this.max == this._dataBounds.max) { this.max = this._dataBounds.max + this.tickInterval } var $ = (this.max - this.min) / this.tickInterval; $ = $.toFixed(11); $ = Math.ceil($); this.numberTicks = $ + 1 } else if (p == null) { var $ = (this._dataBounds.max - this.min) / this.tickInterval; $ = $.toFixed(11); this.numberTicks = Math.ceil($) + 2; this.max = this.min + this.tickInterval * (this.numberTicks - 1) } else if (o == null) { var $ = (this.max - this._dataBounds.min) / this.tickInterval; $ = $.toFixed(11); this.numberTicks = Math.ceil($) + 2; this.min = this.max - this.tickInterval * (this.numberTicks - 1) } else { this.numberTicks = Math.ceil((p - o) / this.tickInterval) + 1; this.min = Math.floor(o * Math.pow(10, X)) / Math.pow(10, X); this.max = Math.ceil(p * Math.pow(10, X)) / Math.pow(10, X); this.numberTicks = Math.ceil((this.max - this.min) / this.tickInterval) + 1 } } } } } } if (this._overrideFormatString && this._autoFormatString != "") { this.tickOptions = this.tickOptions || {}; this.tickOptions.formatString = this._autoFormatString } var u, _; for (var n = 0; n < this.numberTicks; n++) { m = this.min + n * this.tickInterval; u = new this.tickRenderer(this.tickOptions); u.setTick(m, this.name); this._ticks.push(u); if (n < this.numberTicks - 1) { for (var P = 0; P < this.minorTicks; P++) { m += this.tickInterval / (this.minorTicks + 1); _ = a.extend(true, {}, this.tickOptions, { name: this.name, value: m, label: "", isMinorTick: true }); u = new this.tickRenderer(_); this._ticks.push(u) } } u = null } } if (this.tickInset) { this.min = this.min - this.tickInset * this.tickInterval; this.max = this.max + this.tickInset * this.tickInterval } c = null }; a.jqplot.LinearAxisRenderer.prototype.resetTickValues = function (b) { if (a.isArray(b) && b.length == this._ticks.length) { var c; for (var d = 0; d < b.length; d++) { c = this._ticks[d]; c.value = b[d]; c.label = c.formatter(c.formatString, b[d]); c.label = c.prefix + c.label; c._elem.html(c.label) } c = null; this.min = a.jqplot.arrayMin(b); this.max = a.jqplot.arrayMax(b); this.pack() } }; a.jqplot.LinearAxisRenderer.prototype.pack = function (b, c) { b = b || {}; c = c || this._offsets; var d = this._ticks; var e = this.max; var f = this.min; var g = c.max; var h = c.min; var i = this._label == null ? false : this._label.show; for (var j in b) { this._elem.css(j, b[j]) } this._offsets = c; var k = g - h; var l = e - f; if (this.breakPoints) { l = l - this.breakPoints[1] + this.breakPoints[0]; this.p2u = function (a) { return (a - h) * l / k + f }; this.u2p = function (a) { if (a > this.breakPoints[0] && a < this.breakPoints[1]) { a = this.breakPoints[0] } if (a <= this.breakPoints[0]) { return (a - f) * k / l + h } else { return (a - this.breakPoints[1] + this.breakPoints[0] - f) * k / l + h } }; if (this.name.charAt(0) == "x") { this.series_u2p = function (a) { if (a > this.breakPoints[0] && a < this.breakPoints[1]) { a = this.breakPoints[0] } if (a <= this.breakPoints[0]) { return (a - f) * k / l } else { return (a - this.breakPoints[1] + this.breakPoints[0] - f) * k / l } }; this.series_p2u = function (a) { return a * l / k + f } } else { this.series_u2p = function (a) { if (a > this.breakPoints[0] && a < this.breakPoints[1]) { a = this.breakPoints[0] } if (a >= this.breakPoints[1]) { return (a - e) * k / l } else { return (a + this.breakPoints[1] - this.breakPoints[0] - e) * k / l } }; this.series_p2u = function (a) { return a * l / k + e } } } else { this.p2u = function (a) { return (a - h) * l / k + f }; this.u2p = function (a) { return (a - f) * k / l + h }; if (this.name == "xaxis" || this.name == "x2axis") { this.series_u2p = function (a) { return (a - f) * k / l }; this.series_p2u = function (a) { return a * l / k + f } } else { this.series_u2p = function (a) { return (a - e) * k / l }; this.series_p2u = function (a) { return a * l / k + e } } } if (this.show) { if (this.name == "xaxis" || this.name == "x2axis") { for (var m = 0; m < d.length; m++) { var n = d[m]; if (n.show && n.showLabel) { var o; if (n.constructor == a.jqplot.CanvasAxisTickRenderer && n.angle) { var p = this.name == "xaxis" ? 1 : -1; switch (n.labelPosition) { case "auto": if (p * n.angle < 0) { o = -n.getWidth() + n._textRenderer.height * Math.sin(-n._textRenderer.angle) / 2 } else { o = -n._textRenderer.height * Math.sin(n._textRenderer.angle) / 2 } break; case "end": o = -n.getWidth() + n._textRenderer.height * Math.sin(-n._textRenderer.angle) / 2; break; case "start": o = -n._textRenderer.height * Math.sin(n._textRenderer.angle) / 2; break; case "middle": o = -n.getWidth() / 2 + n._textRenderer.height * Math.sin(-n._textRenderer.angle) / 2; break; default: o = -n.getWidth() / 2 + n._textRenderer.height * Math.sin(-n._textRenderer.angle) / 2; break } } else { o = -n.getWidth() / 2 } var q = this.u2p(n.value) + o + "px"; n._elem.css("left", q); n.pack() } } if (i) { var r = this._label._elem.outerWidth(true); this._label._elem.css("left", h + k / 2 - r / 2 + "px"); if (this.name == "xaxis") { this._label._elem.css("bottom", "0px") } else { this._label._elem.css("top", "0px") } this._label.pack() } } else { for (var m = 0; m < d.length; m++) { var n = d[m]; if (n.show && n.showLabel) { var o; if (n.constructor == a.jqplot.CanvasAxisTickRenderer && n.angle) { var p = this.name == "yaxis" ? 1 : -1; switch (n.labelPosition) { case "auto": case "end": if (p * n.angle < 0) { o = -n._textRenderer.height * Math.cos(-n._textRenderer.angle) / 2 } else { o = -n.getHeight() + n._textRenderer.height * Math.cos(n._textRenderer.angle) / 2 } break; case "start": if (n.angle > 0) { o = -n._textRenderer.height * Math.cos(-n._textRenderer.angle) / 2 } else { o = -n.getHeight() + n._textRenderer.height * Math.cos(n._textRenderer.angle) / 2 } break; case "middle": o = -n.getHeight() / 2; break; default: o = -n.getHeight() / 2; break } } else { o = -n.getHeight() / 2 } var q = this.u2p(n.value) + o + "px"; n._elem.css("top", q); n.pack() } } if (i) { var s = this._label._elem.outerHeight(true); this._label._elem.css("top", g - k / 2 - s / 2 + "px"); if (this.name == "yaxis") { this._label._elem.css("left", "0px") } else { this._label._elem.css("right", "0px") } this._label.pack() } } } d = null }; var z = [.1, .2, .3, .4, .5, .8, 1, 2, 3, 4, 5]; var A = function (a) { var b = z.indexOf(a); if (b > 0) { return z[b - 1] } else { return z[z.length - 1] / 100 } }; var B = function (a) { var b = z.indexOf(a); if (b < z.length - 1) { return z[b + 1] } else { return z[0] * 100 } }; a.jqplot.LinearTickGenerator = function (a, b, c, d) { if (a === b) { b = b ? 0 : 1 } c = c || 1; if (b < a) { var e = b; b = a; a = e } var f = []; var g = E(b - a, c); if (d == null) { f[0] = Math.floor(a / g) * g; f[1] = Math.ceil(b / g) * g; f[2] = Math.round((f[1] - f[0]) / g + 1); f[3] = y(g); f[4] = g } else { var h = []; h[0] = Math.floor(a / g) * g; h[1] = Math.ceil(b / g) * g; h[2] = Math.round((h[1] - h[0]) / g + 1); h[3] = y(g); h[4] = g; if (h[2] === d) { f = h } else { var i = D(h[1] - h[0], d); f[0] = h[0]; f[2] = d; f[4] = i; f[3] = y(i); f[1] = f[0] + (f[2] - 1) * f[4] } } return f }; a.jqplot.LinearTickGenerator.bestLinearInterval = E; a.jqplot.LinearTickGenerator.bestInterval = D; a.jqplot.LinearTickGenerator.bestLinearComponents = F; a.jqplot.LinearTickGenerator.bestConstrainedInterval = C; a.jqplot.MarkerRenderer = function (b) { this.show = true; this.style = "filledCircle"; this.lineWidth = 2; this.size = 9; this.color = "#666666"; this.shadow = true; this.shadowAngle = 45; this.shadowOffset = 1; this.shadowDepth = 3; this.shadowAlpha = "0.07"; this.shadowRenderer = new a.jqplot.ShadowRenderer; this.shapeRenderer = new a.jqplot.ShapeRenderer; a.extend(true, this, b) }; a.jqplot.MarkerRenderer.prototype.init = function (b) { a.extend(true, this, b); var c = { angle: this.shadowAngle, offset: this.shadowOffset, alpha: this.shadowAlpha, lineWidth: this.lineWidth, depth: this.shadowDepth, closePath: true }; if (this.style.indexOf("filled") != -1) { c.fill = true } if (this.style.indexOf("ircle") != -1) { c.isarc = true; c.closePath = false } this.shadowRenderer.init(c); var d = { fill: false, isarc: false, strokeStyle: this.color, fillStyle: this.color, lineWidth: this.lineWidth, closePath: true }; if (this.style.indexOf("filled") != -1) { d.fill = true } if (this.style.indexOf("ircle") != -1) { d.isarc = true; d.closePath = false } this.shapeRenderer.init(d) }; a.jqplot.MarkerRenderer.prototype.drawDiamond = function (a, b, c, d, e) { var f = 1.2; var g = this.size / 2 / f; var h = this.size / 2 * f; var i = [[a - g, b], [a, b + h], [a + g, b], [a, b - h]]; if (this.shadow) { this.shadowRenderer.draw(c, i) } this.shapeRenderer.draw(c, i, e) }; a.jqplot.MarkerRenderer.prototype.drawPlus = function (b, c, d, e, f) { var g = 1; var h = this.size / 2 * g; var i = this.size / 2 * g; var j = [[b, c - i], [b, c + i]]; var k = [[b + h, c], [b - h, c]]; var l = a.extend(true, {}, this.options, { closePath: false }); if (this.shadow) { this.shadowRenderer.draw(d, j, { closePath: false }); this.shadowRenderer.draw(d, k, { closePath: false }) } this.shapeRenderer.draw(d, j, l); this.shapeRenderer.draw(d, k, l) }; a.jqplot.MarkerRenderer.prototype.drawX = function (b, c, d, e, f) { var g = 1; var h = this.size / 2 * g; var i = this.size / 2 * g; var j = a.extend(true, {}, this.options, { closePath: false }); var k = [[b - h, c - i], [b + h, c + i]]; var l = [[b - h, c + i], [b + h, c - i]]; if (this.shadow) { this.shadowRenderer.draw(d, k, { closePath: false }); this.shadowRenderer.draw(d, l, { closePath: false }) } this.shapeRenderer.draw(d, k, j); this.shapeRenderer.draw(d, l, j) }; a.jqplot.MarkerRenderer.prototype.drawDash = function (a, b, c, d, e) { var f = 1; var g = this.size / 2 * f; var h = this.size / 2 * f; var i = [[a - g, b], [a + g, b]]; if (this.shadow) { this.shadowRenderer.draw(c, i) } this.shapeRenderer.draw(c, i, e) }; a.jqplot.MarkerRenderer.prototype.drawLine = function (a, b, c, d, e) { var f = [a, b]; if (this.shadow) { this.shadowRenderer.draw(c, f) } this.shapeRenderer.draw(c, f, e) }; a.jqplot.MarkerRenderer.prototype.drawSquare = function (a, b, c, d, e) { var f = 1; var g = this.size / 2 / f; var h = this.size / 2 * f; var i = [[a - g, b - h], [a - g, b + h], [a + g, b + h], [a + g, b - h]]; if (this.shadow) { this.shadowRenderer.draw(c, i) } this.shapeRenderer.draw(c, i, e) }; a.jqplot.MarkerRenderer.prototype.drawCircle = function (a, b, c, d, e) { var f = this.size / 2; var g = 2 * Math.PI; var h = [a, b, f, 0, g, true]; if (this.shadow) { this.shadowRenderer.draw(c, h) } this.shapeRenderer.draw(c, h, e) }; a.jqplot.MarkerRenderer.prototype.draw = function (a, b, c, d) { d = d || {}; if (d.show == null || d.show != false) { if (d.color && !d.fillStyle) { d.fillStyle = d.color } if (d.color && !d.strokeStyle) { d.strokeStyle = d.color } switch (this.style) { case "diamond": this.drawDiamond(a, b, c, false, d); break; case "filledDiamond": this.drawDiamond(a, b, c, true, d); break; case "circle": this.drawCircle(a, b, c, false, d); break; case "filledCircle": this.drawCircle(a, b, c, true, d); break; case "square": this.drawSquare(a, b, c, false, d); break; case "filledSquare": this.drawSquare(a, b, c, true, d); break; case "x": this.drawX(a, b, c, true, d); break; case "plus": this.drawPlus(a, b, c, true, d); break; case "dash": this.drawDash(a, b, c, true, d); break; case "line": this.drawLine(a, b, c, false, d); break; default: this.drawDiamond(a, b, c, false, d); break } } }; a.jqplot.ShadowRenderer = function (b) { this.angle = 45; this.offset = 1; this.alpha = .07; this.lineWidth = 1.5; this.lineJoin = "miter"; this.lineCap = "round"; this.closePath = false; this.fill = false; this.depth = 3; this.strokeStyle = "rgba(0,0,0,0.1)"; this.isarc = false; a.extend(true, this, b) }; a.jqplot.ShadowRenderer.prototype.init = function (b) { a.extend(true, this, b) }; a.jqplot.ShadowRenderer.prototype.draw = function (b, c, d) { b.save(); var e = d != null ? d : {}; var f = e.fill != null ? e.fill : this.fill; var g = e.fillRect != null ? e.fillRect : this.fillRect; var h = e.closePath != null ? e.closePath : this.closePath; var i = e.offset != null ? e.offset : this.offset; var j = e.alpha != null ? e.alpha : this.alpha; var k = e.depth != null ? e.depth : this.depth; var l = e.isarc != null ? e.isarc : this.isarc; var m = e.linePattern != null ? e.linePattern : this.linePattern; b.lineWidth = e.lineWidth != null ? e.lineWidth : this.lineWidth; b.lineJoin = e.lineJoin != null ? e.lineJoin : this.lineJoin; b.lineCap = e.lineCap != null ? e.lineCap : this.lineCap; b.strokeStyle = e.strokeStyle || this.strokeStyle || "rgba(0,0,0," + j + ")"; b.fillStyle = e.fillStyle || this.fillStyle || "rgba(0,0,0," + j + ")"; for (var n = 0; n < k; n++) { var o = a.jqplot.LinePattern(b, m); b.translate(Math.cos(this.angle * Math.PI / 180) * i, Math.sin(this.angle * Math.PI / 180) * i); o.beginPath(); if (l) { b.arc(c[0], c[1], c[2], c[3], c[4], true) } else if (g) { if (g) { b.fillRect(c[0], c[1], c[2], c[3]) } } else if (c && c.length) { var p = true; for (var q = 0; q < c.length; q++) { if (c[q][0] != null && c[q][1] != null) { if (p) { o.moveTo(c[q][0], c[q][1]); p = false } else { o.lineTo(c[q][0], c[q][1]) } } else { p = true } } } if (h) { o.closePath() } if (f) { b.fill() } else { b.stroke() } } b.restore() }; a.jqplot.ShapeRenderer = function (b) { this.lineWidth = 1.5; this.linePattern = "solid"; this.lineJoin = "miter"; this.lineCap = "round"; this.closePath = false; this.fill = false; this.isarc = false; this.fillRect = false; this.strokeRect = false; this.clearRect = false; this.strokeStyle = "#999999"; this.fillStyle = "#999999"; a.extend(true, this, b) }; a.jqplot.ShapeRenderer.prototype.init = function (b) { a.extend(true, this, b) }; a.jqplot.ShapeRenderer.prototype.draw = function (b, c, d) { b.save(); var e = d != null ? d : {}; var f = e.fill != null ? e.fill : this.fill; var g = e.closePath != null ? e.closePath : this.closePath; var h = e.fillRect != null ? e.fillRect : this.fillRect; var i = e.strokeRect != null ? e.strokeRect : this.strokeRect; var j = e.clearRect != null ? e.clearRect : this.clearRect; var k = e.isarc != null ? e.isarc : this.isarc; var l = e.linePattern != null ? e.linePattern : this.linePattern; var m = a.jqplot.LinePattern(b, l); b.lineWidth = e.lineWidth || this.lineWidth; b.lineJoin = e.lineJoin || this.lineJoin; b.lineCap = e.lineCap || this.lineCap; b.strokeStyle = e.strokeStyle || e.color || this.strokeStyle; b.fillStyle = e.fillStyle || this.fillStyle; b.beginPath(); if (k) { b.arc(c[0], c[1], c[2], c[3], c[4], true); if (g) { b.closePath() } if (f) { b.fill() } else { b.stroke() } b.restore(); return } else if (j) { b.clearRect(c[0], c[1], c[2], c[3]); b.restore(); return } else if (h || i) { if (h) { b.fillRect(c[0], c[1], c[2], c[3]) } if (i) { b.strokeRect(c[0], c[1], c[2], c[3]); b.restore(); return } } else if (c && c.length) { var n = true; for (var o = 0; o < c.length; o++) { if (c[o][0] != null && c[o][1] != null) { if (n) { m.moveTo(c[o][0], c[o][1]); n = false } else { m.lineTo(c[o][0], c[o][1]) } } else { n = true } } if (g) { m.closePath() } if (f) { b.fill() } else { b.stroke() } } b.restore() }; a.jqplot.TableLegendRenderer = function () { }; a.jqplot.TableLegendRenderer.prototype.init = function (b) { a.extend(true, this, b) }; a.jqplot.TableLegendRenderer.prototype.addrow = function (b, c, d, e) { var f = d ? this.rowSpacing + "px" : "0px"; var g; var h; var i; var j; var k; i = document.createElement("tr"); g = a(i); g.addClass("jqplot-table-legend"); i = null; if (e) { g.prependTo(this._elem) } else { g.appendTo(this._elem) } if (this.showSwatches) { h = a(document.createElement("td")); h.addClass("jqplot-table-legend jqplot-table-legend-swatch"); h.css({ textAlign: "center", paddingTop: f }); j = a(document.createElement("div")); j.addClass("jqplot-table-legend-swatch-outline"); k = a(document.createElement("div")); k.addClass("jqplot-table-legend-swatch"); k.css({ backgroundColor: c, borderColor: c }); g.append(h.append(j.append(k))) } if (this.showLabels) { h = a(document.createElement("td")); h.addClass("jqplot-table-legend jqplot-table-legend-label"); h.css("paddingTop", f); g.append(h); if (this.escapeHtml) { h.text(b) } else { h.html(b) } } h = null; j = null; k = null; g = null; i = null }; a.jqplot.TableLegendRenderer.prototype.draw = function () { if (this._elem) { this._elem.emptyForce(); this._elem = null } if (this.show) { var b = this._series; var c = document.createElement("table"); this._elem = a(c); this._elem.addClass("jqplot-table-legend"); var d = { position: "absolute" }; if (this.background) { d["background"] = this.background } if (this.border) { d["border"] = this.border } if (this.fontSize) { d["fontSize"] = this.fontSize } if (this.fontFamily) { d["fontFamily"] = this.fontFamily } if (this.textColor) { d["textColor"] = this.textColor } if (this.marginTop != null) { d["marginTop"] = this.marginTop } if (this.marginBottom != null) { d["marginBottom"] = this.marginBottom } if (this.marginLeft != null) { d["marginLeft"] = this.marginLeft } if (this.marginRight != null) { d["marginRight"] = this.marginRight } var e = false, f = false, g; for (var h = 0; h < b.length; h++) { g = b[h]; if (g._stack || g.renderer.constructor == a.jqplot.BezierCurveRenderer) { f = true } if (g.show && g.showLabel) { var i = this.labels[h] || g.label.toString(); if (i) { var j = g.color; if (f && h < b.length - 1) { e = true } else if (f && h == b.length - 1) { e = false } this.renderer.addrow.call(this, i, j, e, f); e = true } for (var k = 0; k < a.jqplot.addLegendRowHooks.length; k++) { var l = a.jqplot.addLegendRowHooks[k].call(this, g); if (l) { this.renderer.addrow.call(this, l.label, l.color, e); e = true } } i = null } } } return this._elem }; a.jqplot.TableLegendRenderer.prototype.pack = function (a) { if (this.show) { if (this.placement == "insideGrid") { switch (this.location) { case "nw": var b = a.left; var c = a.top; this._elem.css("left", b); this._elem.css("top", c); break; case "n": var b = (a.left + (this._plotDimensions.width - a.right)) / 2 - this.getWidth() / 2; var c = a.top; this._elem.css("left", b); this._elem.css("top", c); break; case "ne": var b = a.right; var c = a.top; this._elem.css({ right: b, top: c }); break; case "e": var b = a.right; var c = (a.top + (this._plotDimensions.height - a.bottom)) / 2 - this.getHeight() / 2; this._elem.css({ right: b, top: c }); break; case "se": var b = a.right; var c = a.bottom; this._elem.css({ right: b, bottom: c }); break; case "s": var b = (a.left + (this._plotDimensions.width - a.right)) / 2 - this.getWidth() / 2; var c = a.bottom; this._elem.css({ left: b, bottom: c }); break; case "sw": var b = a.left; var c = a.bottom; this._elem.css({ left: b, bottom: c }); break; case "w": var b = a.left; var c = (a.top + (this._plotDimensions.height - a.bottom)) / 2 - this.getHeight() / 2; this._elem.css({ left: b, top: c }); break; default: var b = a.right; var c = a.bottom; this._elem.css({ right: b, bottom: c }); break } } else if (this.placement == "outside") { switch (this.location) { case "nw": var b = this._plotDimensions.width - a.left; var c = a.top; this._elem.css("right", b); this._elem.css("top", c); break; case "n": var b = (a.left + (this._plotDimensions.width - a.right)) / 2 - this.getWidth() / 2; var c = this._plotDimensions.height - a.top; this._elem.css("left", b); this._elem.css("bottom", c); break; case "ne": var b = this._plotDimensions.width - a.right; var c = a.top; this._elem.css({ left: b, top: c }); break; case "e": var b = this._plotDimensions.width - a.right; var c = (a.top + (this._plotDimensions.height - a.bottom)) / 2 - this.getHeight() / 2; this._elem.css({ left: b, top: c }); break; case "se": var b = this._plotDimensions.width - a.right; var c = a.bottom; this._elem.css({ left: b, bottom: c }); break; case "s": var b = (a.left + (this._plotDimensions.width - a.right)) / 2 - this.getWidth() / 2; var c = this._plotDimensions.height - a.bottom; this._elem.css({ left: b, top: c }); break; case "sw": var b = this._plotDimensions.width - a.left; var c = a.bottom; this._elem.css({ right: b, bottom: c }); break; case "w": var b = this._plotDimensions.width - a.left; var c = (a.top + (this._plotDimensions.height - a.bottom)) / 2 - this.getHeight() / 2; this._elem.css({ right: b, top: c }); break; default: var b = a.right; var c = a.bottom; this._elem.css({ right: b, bottom: c }); break } } else { switch (this.location) { case "nw": this._elem.css({ left: 0, top: a.top }); break; case "n": var b = (a.left + (this._plotDimensions.width - a.right)) / 2 - this.getWidth() / 2; this._elem.css({ left: b, top: a.top }); break; case "ne": this._elem.css({ right: 0, top: a.top }); break; case "e": var c = (a.top + (this._plotDimensions.height - a.bottom)) / 2 - this.getHeight() / 2; this._elem.css({ right: a.right, top: c }); break; case "se": this._elem.css({ right: a.right, bottom: a.bottom }); break; case "s": var b = (a.left + (this._plotDimensions.width - a.right)) / 2 - this.getWidth() / 2; this._elem.css({ left: b, bottom: a.bottom }); break; case "sw": this._elem.css({ left: a.left, bottom: a.bottom }); break; case "w": var c = (a.top + (this._plotDimensions.height - a.bottom)) / 2 - this.getHeight() / 2; this._elem.css({ left: a.left, top: c }); break; default: this._elem.css({ right: a.right, bottom: a.bottom }); break } } } }; a.jqplot.ThemeEngine = function () { this.themes = {}; this.activeTheme = null }; a.jqplot.ThemeEngine.prototype.init = function () { var b = new a.jqplot.Theme({ _name: "Default" }); var c, d, e; for (c in b.target) { if (c == "textColor") { b.target[c] = this.target.css("color") } else { b.target[c] = this.target.css(c) } } if (this.title.show && this.title._elem) { for (c in b.title) { if (c == "textColor") { b.title[c] = this.title._elem.css("color") } else { b.title[c] = this.title._elem.css(c) } } } for (c in b.grid) { b.grid[c] = this.grid[c] } if (b.grid.backgroundColor == null && this.grid.background != null) { b.grid.backgroundColor = this.grid.background } if (this.legend.show && this.legend._elem) { for (c in b.legend) { if (c == "textColor") { b.legend[c] = this.legend._elem.css("color") } else { b.legend[c] = this.legend._elem.css(c) } } } var f; for (d = 0; d < this.series.length; d++) { f = this.series[d]; if (f.renderer.constructor == a.jqplot.LineRenderer) { b.series.push(new M) } else if (f.renderer.constructor == a.jqplot.BarRenderer) { b.series.push(new O) } else if (f.renderer.constructor == a.jqplot.PieRenderer) { b.series.push(new P) } else if (f.renderer.constructor == a.jqplot.DonutRenderer) { b.series.push(new Q) } else if (f.renderer.constructor == a.jqplot.FunnelRenderer) { b.series.push(new R) } else if (f.renderer.constructor == a.jqplot.MeterGaugeRenderer) { b.series.push(new S) } else { b.series.push({}) } for (c in b.series[d]) { b.series[d][c] = f[c] } } var g, h; for (c in this.axes) { h = this.axes[c]; g = b.axes[c] = new J; g.borderColor = h.borderColor; g.borderWidth = h.borderWidth; if (h._ticks && h._ticks[0]) { for (e in g.ticks) { if (h._ticks[0].hasOwnProperty(e)) { g.ticks[e] = h._ticks[0][e] } else if (h._ticks[0]._elem) { g.ticks[e] = h._ticks[0]._elem.css(e) } } } if (h._label && h._label.show) { for (e in g.label) { if (h._label[e]) { g.label[e] = h._label[e] } else if (h._label._elem) { if (e == "textColor") { g.label[e] = h._label._elem.css("color") } else { g.label[e] = h._label._elem.css(e) } } } } } this.themeEngine._add(b); this.themeEngine.activeTheme = this.themeEngine.themes[b._name] }; a.jqplot.ThemeEngine.prototype.get = function (a) { if (!a) { return this.activeTheme } else { return this.themes[a] } }; a.jqplot.ThemeEngine.prototype.getThemeNames = function () { var a = []; for (var b in this.themes) { a.push(b) } return a.sort(G) }; a.jqplot.ThemeEngine.prototype.getThemes = function () { var a = []; var b = []; for (var c in this.themes) { a.push(c) } a.sort(G); for (var d = 0; d < a.length; d++) { b.push(this.themes[a[d]]) } return b }; a.jqplot.ThemeEngine.prototype.activate = function (b, c) { var d = false; if (!c && this.activeTheme && this.activeTheme._name) { c = this.activeTheme._name } if (!this.themes.hasOwnProperty(c)) { throw new Error("No theme of that name") } else { var e = this.themes[c]; this.activeTheme = e; var f, g = false, h = false; var i = ["xaxis", "x2axis", "yaxis", "y2axis"]; for (r = 0; r < i.length; r++) { var j = i[r]; if (e.axesStyles.borderColor != null) { b.axes[j].borderColor = e.axesStyles.borderColor } if (e.axesStyles.borderWidth != null) { b.axes[j].borderWidth = e.axesStyles.borderWidth } } for (var k in b.axes) { var l = b.axes[k]; if (l.show) { var m = e.axes[k] || {}; var n = e.axesStyles; var o = a.jqplot.extend(true, {}, m, n); f = e.axesStyles.borderColor != null ? e.axesStyles.borderColor : o.borderColor; if (o.borderColor != null) { l.borderColor = o.borderColor; d = true } f = e.axesStyles.borderWidth != null ? e.axesStyles.borderWidth : o.borderWidth; if (o.borderWidth != null) { l.borderWidth = o.borderWidth; d = true } if (l._ticks && l._ticks[0]) { for (var p in o.ticks) { f = o.ticks[p]; if (f != null) { l.tickOptions[p] = f; l._ticks = []; d = true } } } if (l._label && l._label.show) { for (var p in o.label) { f = o.label[p]; if (f != null) { l.labelOptions[p] = f; d = true } } } } } for (var q in e.grid) { if (e.grid[q] != null) { b.grid[q] = e.grid[q] } } if (!d) { b.grid.draw() } if (b.legend.show) { for (q in e.legend) { if (e.legend[q] != null) { b.legend[q] = e.legend[q] } } } if (b.title.show) { for (q in e.title) { if (e.title[q] != null) { b.title[q] = e.title[q] } } } var r; for (r = 0; r < e.series.length; r++) { var s = {}; var t = false; for (q in e.series[r]) { f = e.seriesStyles[q] != null ? e.seriesStyles[q] : e.series[r][q]; if (f != null) { s[q] = f; if (q == "color") { b.series[r].renderer.shapeRenderer.fillStyle = f; b.series[r].renderer.shapeRenderer.strokeStyle = f; b.series[r][q] = f } else if (q == "lineWidth" || q == "linePattern") { b.series[r].renderer.shapeRenderer[q] = f; b.series[r][q] = f } else if (q == "markerOptions") { I(b.series[r].markerOptions, f); I(b.series[r].markerRenderer, f) } else { b.series[r][q] = f } d = true } } } if (d) { b.target.empty(); b.draw() } for (q in e.target) { if (e.target[q] != null) { b.target.css(q, e.target[q]) } } } }; a.jqplot.ThemeEngine.prototype._add = function (a, b) { if (b) { a._name = b } if (!a._name) { a._name = Date.parse(new Date) } if (!this.themes.hasOwnProperty(a._name)) { this.themes[a._name] = a } else { throw new Error("jqplot.ThemeEngine Error: Theme already in use") } }; a.jqplot.ThemeEngine.prototype.remove = function (a) { if (a == "Default") { return false } return delete this.themes[a] }; a.jqplot.ThemeEngine.prototype.newTheme = function (b, c) { if (typeof b == "object") { c = c || b; b = null } if (c && c._name) { b = c._name } else { b = b || Date.parse(new Date) } var d = this.copy(this.themes["Default"]._name, b); a.jqplot.extend(d, c); return d }; a.jqplot.clone = H; a.jqplot.merge = I; a.jqplot.extend = function () { var c = arguments[0] || {}, d = 1, e = arguments.length, f = false, g; if (typeof c === "boolean") { f = c; c = arguments[1] || {}; d = 2 } if (typeof c !== "object" && !toString.call(c) === "[object Function]") { c = {} } for (; d < e; d++) { if ((g = arguments[d]) != null) { for (var h in g) { var i = c[h], j = g[h]; if (c === j) { continue } if (f && j && typeof j === "object" && !j.nodeType) { c[h] = a.jqplot.extend(f, i || (j.length != null ? [] : {}), j) } else if (j !== b) { c[h] = j } } } } return c }; a.jqplot.ThemeEngine.prototype.rename = function (a, b) { if (a == "Default" || b == "Default") { throw new Error("jqplot.ThemeEngine Error: Cannot rename from/to Default") } if (this.themes.hasOwnProperty(b)) { throw new Error("jqplot.ThemeEngine Error: New name already in use.") } else if (this.themes.hasOwnProperty(a)) { var c = this.copy(a, b); this.remove(a); return c } throw new Error("jqplot.ThemeEngine Error: Old name or new name invalid") }; a.jqplot.ThemeEngine.prototype.copy = function (b, c, d) { if (c == "Default") { throw new Error("jqplot.ThemeEngine Error: Cannot copy over Default theme") } if (!this.themes.hasOwnProperty(b)) { var e = "jqplot.ThemeEngine Error: Source name invalid"; throw new Error(e) } if (this.themes.hasOwnProperty(c)) { var e = "jqplot.ThemeEngine Error: Target name invalid"; throw new Error(e) } else { var f = H(this.themes[b]); f._name = c; a.jqplot.extend(true, f, d); this._add(f); return f } }; a.jqplot.Theme = function (b, c) { if (typeof b == "object") { c = c || b; b = null } b = b || Date.parse(new Date); this._name = b; this.target = { backgroundColor: null }; this.legend = { textColor: null, fontFamily: null, fontSize: null, border: null, background: null }; this.title = { textColor: null, fontFamily: null, fontSize: null, textAlign: null }; this.seriesStyles = {}; this.series = []; this.grid = { drawGridlines: null, gridLineColor: null, gridLineWidth: null, backgroundColor: null, borderColor: null, borderWidth: null, shadow: null }; this.axesStyles = { label: {}, ticks: {} }; this.axes = {}; if (typeof c == "string") { this._name = c } else if (typeof c == "object") { a.jqplot.extend(true, this, c) } }; var J = function () { this.borderColor = null; this.borderWidth = null; this.ticks = new K; this.label = new L }; var K = function () { this.show = null; this.showGridline = null; this.showLabel = null; this.showMark = null; this.size = null; this.textColor = null; this.whiteSpace = null; this.fontSize = null; this.fontFamily = null }; var L = function () { this.textColor = null; this.whiteSpace = null; this.fontSize = null; this.fontFamily = null; this.fontWeight = null }; var M = function () { this.color = null; this.lineWidth = null; this.linePattern = null; this.shadow = null; this.fillColor = null; this.showMarker = null; this.markerOptions = new N }; var N = function () { this.show = null; this.style = null; this.lineWidth = null; this.size = null; this.color = null; this.shadow = null }; var O = function () { this.color = null; this.seriesColors = null; this.lineWidth = null; this.shadow = null; this.barPadding = null; this.barMargin = null; this.barWidth = null; this.highlightColors = null }; var P = function () { this.seriesColors = null; this.padding = null; this.sliceMargin = null; this.fill = null; this.shadow = null; this.startAngle = null; this.lineWidth = null; this.highlightColors = null }; var Q = function () { this.seriesColors = null; this.padding = null; this.sliceMargin = null; this.fill = null; this.shadow = null; this.startAngle = null; this.lineWidth = null; this.innerDiameter = null; this.thickness = null; this.ringMargin = null; this.highlightColors = null }; var R = function () { this.color = null; this.lineWidth = null; this.shadow = null; this.padding = null; this.sectionMargin = null; this.seriesColors = null; this.highlightColors = null }; var S = function () { this.padding = null; this.backgroundColor = null; this.ringColor = null; this.tickColor = null; this.ringWidth = null; this.intervalColors = null; this.intervalInnerRadius = null; this.intervalOuterRadius = null; this.hubRadius = null; this.needleThickness = null; this.needlePad = null }; a.fn.jqplotChildText = function () { return a(this).contents().filter(function () { return this.nodeType == 3 }).text() }; a.fn.jqplotGetComputedFontStyle = function () { var a = window.getComputedStyle ? window.getComputedStyle(this[0]) : this[0].currentStyle; var b = a["font-style"] ? ["font-style", "font-weight", "font-size", "font-family"] : ["fontStyle", "fontWeight", "fontSize", "fontFamily"]; var c = []; for (var d = 0; d < b.length; ++d) { var e = String(a[b[d]]); if (e && e != "normal") { c.push(e) } } return c.join(" ") }; a.fn.jqplotToImageCanvas = function (b) { function w(b, c, d) { var e = b.tagName.toLowerCase(); var g = a(b).position(); var h = window.getComputedStyle ? window.getComputedStyle(b) : b.currentStyle; var i = c + g.left + parseInt(h.marginLeft, 10) + parseInt(h.borderLeftWidth, 10) + parseInt(h.paddingLeft, 10); var j = d + g.top + parseInt(h.marginTop, 10) + parseInt(h.borderTopWidth, 10) + parseInt(h.paddingTop, 10); var k = f.width; if ((e == "div" || e == "span") && !a(b).hasClass("jqplot-highlighter-tooltip")) { a(b).children().each(function () { w(this, i, j) }); var l = a(b).jqplotChildText(); if (l) { t.font = a(b).jqplotGetComputedFontStyle(); t.fillStyle = a(b).css("color"); v(b, t, l, i, j, k) } } else if (e === "table" && a(b).hasClass("jqplot-table-legend")) { t.strokeStyle = a(b).css("border-top-color"); t.fillStyle = a(b).css("background-color"); t.fillRect(i, j, a(b).innerWidth(), a(b).innerHeight()); if (parseInt(a(b).css("border-top-width"), 10) > 0) { t.strokeRect(i, j, a(b).innerWidth(), a(b).innerHeight()) } a(b).find("div.jqplot-table-legend-swatch-outline").each(function () { var b = a(this); t.strokeStyle = b.css("border-top-color"); var c = i + b.position().left; var d = j + b.position().top; t.strokeRect(c, d, b.innerWidth(), b.innerHeight()); c += parseInt(b.css("padding-left"), 10); d += parseInt(b.css("padding-top"), 10); var e = b.innerHeight() - 2 * parseInt(b.css("padding-top"), 10); var f = b.innerWidth() - 2 * parseInt(b.css("padding-left"), 10); var g = b.children("div.jqplot-table-legend-swatch"); t.fillStyle = g.css("background-color"); t.fillRect(c, d, f, e) }); a(b).find("td.jqplot-table-legend-label").each(function () { var b = a(this); var c = i + b.position().left; var d = j + b.position().top + parseInt(b.css("padding-top"), 10); t.font = b.jqplotGetComputedFontStyle(); t.fillStyle = b.css("color"); t.fillText(b.text(), c, d) }); var m = null } else if (e == "canvas") { t.drawImage(b, i, j) } } function v(b, c, d, e, f, g) { var h = u(b); var i = a(b).innerWidth(); var j = a(b).innerHeight(); var k = d.split(/\s+/); var m = k.length; var n = ""; var o = []; var p = f; var q = e; for (var r = 0; r < m; r++) { n += k[r]; if (c.measureText(n).width > i) { o.push(r); n = "" } } if (o.length === 0) { if (a(b).css("textAlign") === "center") { q = e + (g - c.measureText(n).width) / 2 - l } c.fillText(d, q, f) } else { n = k.slice(0, o[0]).join(" "); if (a(b).css("textAlign") === "center") { q = e + (g - c.measureText(n).width) / 2 - l } c.fillText(n, q, p); p += h; for (var r = 1, s = o.length; r < s; r++) { n = k.slice(o[r - 1], o[r]).join(" "); if (a(b).css("textAlign") === "center") { q = e + (g - c.measureText(n).width) / 2 - l } c.fillText(n, q, p); p += h } n = k.slice(o[r - 1], k.length).join(" "); if (a(b).css("textAlign") === "center") { q = e + (g - c.measureText(n).width) / 2 - l } c.fillText(n, q, p) } } function u(b) { var c = parseInt(a(b).css("line-height"), 10); if (isNaN(c)) { c = parseInt(a(b).css("font-size"), 10) * 1.2 } return c } b = b || {}; var c = b.x_offset == null ? 0 : b.x_offset; var d = b.y_offset == null ? 0 : b.y_offset; var e = b.backgroundColor == null ? "rgb(255,255,255)" : b.backgroundColor; if (a(this).width() == 0 || a(this).height() == 0) { return null } if (!a.jqplot.support_canvas) { return null } var f = document.createElement("canvas"); var g = a(this).outerHeight(true); var h = a(this).outerWidth(true); var i = a(this).offset(); var j = i.left; var k = i.top; var l = 0, m = 0; var n = ["jqplot-table-legend", "jqplot-xaxis-tick", "jqplot-x2axis-tick", "jqplot-yaxis-tick", "jqplot-y2axis-tick", "jqplot-y3axis-tick", "jqplot-y4axis-tick", "jqplot-y5axis-tick", "jqplot-y6axis-tick", "jqplot-y7axis-tick", "jqplot-y8axis-tick", "jqplot-y9axis-tick", "jqplot-xaxis-label", "jqplot-x2axis-label", "jqplot-yaxis-label", "jqplot-y2axis-label", "jqplot-y3axis-label", "jqplot-y4axis-label", "jqplot-y5axis-label", "jqplot-y6axis-label", "jqplot-y7axis-label", "jqplot-y8axis-label", "jqplot-y9axis-label"]; var o, p, q, r; for (var s in n) { a(this).find("." + n[s]).each(function () { o = a(this).offset().top - k; p = a(this).offset().left - j; r = p + a(this).outerWidth(true) + l; q = o + a(this).outerHeight(true) + m; if (p < -l) { h = h - l - p; l = -p } if (o < -m) { g = g - m - o; m = -o } if (r > h) { h = r } if (q > g) { g = q } }) } f.width = h + Number(c); f.height = g + Number(d); var t = f.getContext("2d"); t.save(); t.fillStyle = e; t.fillRect(0, 0, f.width, f.height); t.restore(); t.translate(l, m); t.textAlign = "left"; t.textBaseline = "top"; a(this).children().each(function () { w(this, c, d) }); return f }; a.fn.jqplotToImageStr = function (b) { var c = a(this).jqplotToImageCanvas(b); if (c) { return c.toDataURL("image/png") } else { return null } }; a.fn.jqplotToImageElem = function (b) { var c = document.createElement("img"); var d = a(this).jqplotToImageStr(b); c.src = d; return c }; a.fn.jqplotToImageElemStr = function (b) { var c = "<img src=" + a(this).jqplotToImageStr(b) + " />"; return c }; a.fn.jqplotSaveImage = function () { var b = a(this).jqplotToImageStr({}); if (b) { window.location.href = b.replace("image/png", "image/octet-stream") } }; a.fn.jqplotViewImage = function () { var b = a(this).jqplotToImageElemStr({}); var c = a(this).jqplotToImageStr({}); if (b) { var d = window.open(""); d.document.open("image/png"); d.document.write(b); d.document.close(); d = null } }; var T = function () { this.syntax = T.config.syntax; this._type = "jsDate"; this.proxy = new Date; this.options = {}; this.locale = T.regional.getLocale(); this.formatString = ""; this.defaultCentury = T.config.defaultCentury; switch (arguments.length) { case 0: break; case 1: if ($(arguments[0]) == "[object Object]" && arguments[0]._type != "jsDate") { var a = this.options = arguments[0]; this.syntax = a.syntax || this.syntax; this.defaultCentury = a.defaultCentury || this.defaultCentury; this.proxy = T.createDate(a.date) } else { this.proxy = T.createDate(arguments[0]) } break; default: var b = []; for (var c = 0; c < arguments.length; c++) { b.push(arguments[c]) } this.proxy = new Date; this.proxy.setFullYear.apply(this.proxy, b.slice(0, 3)); if (b.slice(3).length) { this.proxy.setHours.apply(this.proxy, b.slice(3)) } break } }; T.config = { defaultLocale: "en", syntax: "perl", defaultCentury: 1900 }; T.prototype.add = function (a, b) { var c = W[b] || W.day; if (typeof c == "number") { this.proxy.setTime(this.proxy.getTime() + c * a) } else { c.add(this, a) } return this }; T.prototype.clone = function () { return new T(this.proxy.getTime()) }; T.prototype.getUtcOffset = function () { return this.proxy.getTimezoneOffset() * 6e4 }; T.prototype.diff = function (a, b, c) { a = new T(a); if (a === null) { return null } var d = W[b] || W.day; if (typeof d == "number") { var e = (this.proxy.getTime() - a.proxy.getTime()) / d } else { var e = d.diff(this.proxy, a.proxy) } return c ? e : Math[e > 0 ? "floor" : "ceil"](e) }; T.prototype.getAbbrDayName = function () { return T.regional[this.locale]["dayNamesShort"][this.proxy.getDay()] }; T.prototype.getAbbrMonthName = function () { return T.regional[this.locale]["monthNamesShort"][this.proxy.getMonth()] }; T.prototype.getAMPM = function () { return this.proxy.getHours() >= 12 ? "PM" : "AM" }; T.prototype.getAmPm = function () { return this.proxy.getHours() >= 12 ? "pm" : "am" }; T.prototype.getCentury = function () { return parseInt(this.proxy.getFullYear() / 100, 10) }; T.prototype.getDate = function () { return this.proxy.getDate() }; T.prototype.getDay = function () { return this.proxy.getDay() }; T.prototype.getDayOfWeek = function () { var a = this.proxy.getDay(); return a === 0 ? 7 : a }; T.prototype.getDayOfYear = function () { var a = this.proxy; var b = a - new Date("" + a.getFullYear() + "/1/1 GMT"); b += a.getTimezoneOffset() * 6e4; a = null; return parseInt(b / 6e4 / 60 / 24, 10) + 1 }; T.prototype.getDayName = function () { return T.regional[this.locale]["dayNames"][this.proxy.getDay()] }; T.prototype.getFullWeekOfYear = function () { var a = this.proxy; var b = this.getDayOfYear(); var c = 6 - a.getDay(); var d = parseInt((b + c) / 7, 10); return d }; T.prototype.getFullYear = function () { return this.proxy.getFullYear() }; T.prototype.getGmtOffset = function () { var a = this.proxy.getTimezoneOffset() / 60; var b = a < 0 ? "+" : "-"; a = Math.abs(a); return b + V(Math.floor(a), 2) + ":" + V(a % 1 * 60, 2) }; T.prototype.getHours = function () { return this.proxy.getHours() }; T.prototype.getHours12 = function () { var a = this.proxy.getHours(); return a > 12 ? a - 12 : a == 0 ? 12 : a }; T.prototype.getIsoWeek = function () { var a = this.proxy; var b = a.getWeekOfYear(); var c = (new Date("" + a.getFullYear() + "/1/1")).getDay(); var d = b + (c > 4 || c <= 1 ? 0 : 1); if (d == 53 && (new Date("" + a.getFullYear() + "/12/31")).getDay() < 4) { d = 1 } else if (d === 0) { a = new T(new Date("" + (a.getFullYear() - 1) + "/12/31")); d = a.getIsoWeek() } a = null; return d }; T.prototype.getMilliseconds = function () { return this.proxy.getMilliseconds() }; T.prototype.getMinutes = function () { return this.proxy.getMinutes() }; T.prototype.getMonth = function () { return this.proxy.getMonth() }; T.prototype.getMonthName = function () { return T.regional[this.locale]["monthNames"][this.proxy.getMonth()] }; T.prototype.getMonthNumber = function () { return this.proxy.getMonth() + 1 }; T.prototype.getSeconds = function () { return this.proxy.getSeconds() }; T.prototype.getShortYear = function () { return this.proxy.getYear() % 100 }; T.prototype.getTime = function () { return this.proxy.getTime() }; T.prototype.getTimezoneAbbr = function () { return this.proxy.toString().replace(/^.*\(([^)]+)\)$/, "$1") }; T.prototype.getTimezoneName = function () { var a = /(?:\((.+)\)$| ([A-Z]{3}) )/.exec(this.toString()); return a[1] || a[2] || "GMT" + this.getGmtOffset() }; T.prototype.getTimezoneOffset = function () { return this.proxy.getTimezoneOffset() }; T.prototype.getWeekOfYear = function () { var a = this.getDayOfYear(); var b = 7 - this.getDayOfWeek(); var c = parseInt((a + b) / 7, 10); return c }; T.prototype.getUnix = function () { return Math.round(this.proxy.getTime() / 1e3, 0) }; T.prototype.getYear = function () { return this.proxy.getYear() }; T.prototype.next = function (a) { a = a || "day"; return this.clone().add(1, a) }; T.prototype.set = function () { switch (arguments.length) { case 0: this.proxy = new Date; break; case 1: if ($(arguments[0]) == "[object Object]" && arguments[0]._type != "jsDate") { var a = this.options = arguments[0]; this.syntax = a.syntax || this.syntax; this.defaultCentury = a.defaultCentury || this.defaultCentury; this.proxy = T.createDate(a.date) } else { this.proxy = T.createDate(arguments[0]) } break; default: var b = []; for (var c = 0; c < arguments.length; c++) { b.push(arguments[c]) } this.proxy = new Date; this.proxy.setFullYear.apply(this.proxy, b.slice(0, 3)); if (b.slice(3).length) { this.proxy.setHours.apply(this.proxy, b.slice(3)) } break } return this }; T.prototype.setDate = function (a) { this.proxy.setDate(a); return this }; T.prototype.setFullYear = function () { this.proxy.setFullYear.apply(this.proxy, arguments); return this }; T.prototype.setHours = function () { this.proxy.setHours.apply(this.proxy, arguments); return this }; T.prototype.setMilliseconds = function (a) { this.proxy.setMilliseconds(a); return this }; T.prototype.setMinutes = function () { this.proxy.setMinutes.apply(this.proxy, arguments); return this }; T.prototype.setMonth = function () { this.proxy.setMonth.apply(this.proxy, arguments); return this }; T.prototype.setSeconds = function () { this.proxy.setSeconds.apply(this.proxy, arguments); return this }; T.prototype.setTime = function (a) { this.proxy.setTime(a); return this }; T.prototype.setYear = function () { this.proxy.setYear.apply(this.proxy, arguments); return this }; T.prototype.strftime = function (a) { a = a || this.formatString || T.regional[this.locale]["formatString"]; return T.strftime(this, a, this.syntax) }; T.prototype.toString = function () { return this.proxy.toString() }; T.prototype.toYmdInt = function () { return this.proxy.getFullYear() * 1e4 + this.getMonthNumber() * 100 + this.proxy.getDate() }; T.regional = { en: { monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], formatString: "%Y-%m-%d %H:%M:%S" }, fr: { monthNames: ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"], monthNamesShort: ["Jan", "Fév", "Mar", "Avr", "Mai", "Jun", "Jul", "Aoû", "Sep", "Oct", "Nov", "Déc"], dayNames: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"], dayNamesShort: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"], formatString: "%Y-%m-%d %H:%M:%S" }, de: { monthNames: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"], monthNamesShort: ["Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"], dayNames: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"], dayNamesShort: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"], formatString: "%Y-%m-%d %H:%M:%S" }, es: { monthNames: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"], monthNamesShort: ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"], dayNames: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"], dayNamesShort: ["Dom", "Lun", "Mar", "Mié", "Juv", "Vie", "Sáb"], formatString: "%Y-%m-%d %H:%M:%S" }, ru: { monthNames: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"], monthNamesShort: ["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"], dayNames: ["воскресенье", "понедельник", "вторник", "среда", "четверг", "пятница", "суббота"], dayNamesShort: ["вск", "пнд", "втр", "срд", "чтв", "птн", "сбт"], formatString: "%Y-%m-%d %H:%M:%S" }, ar: { monthNames: ["كانون الثاني", "شباط", "آذار", "نيسان", "آذار", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول"], monthNamesShort: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], dayNames: ["السبت", "الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة"], dayNamesShort: ["سبت", "أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة"], formatString: "%Y-%m-%d %H:%M:%S" }, pt: { monthNames: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], monthNamesShort: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"], dayNames: ["Domingo", "Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sábado"], dayNamesShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"], formatString: "%Y-%m-%d %H:%M:%S" }, "pt-BR": { monthNames: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], monthNamesShort: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"], dayNames: ["Domingo", "Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sábado"], dayNamesShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"], formatString: "%Y-%m-%d %H:%M:%S"} }; T.regional["en-US"] = T.regional["en-GB"] = T.regional["en"]; T.regional.getLocale = function () { var a = T.config.defaultLocale; if (document && document.getElementsByTagName("html") && document.getElementsByTagName("html")[0].lang) { a = document.getElementsByTagName("html")[0].lang; if (!T.regional.hasOwnProperty(a)) { a = T.config.defaultLocale } } return a }; var U = 24 * 60 * 60 * 1e3; var V = function (a, b) { a = String(a); var c = b - a.length; var d = String(Math.pow(10, c)).slice(1); return d.concat(a) }; var W = { millisecond: 1, second: 1e3, minute: 60 * 1e3, hour: 60 * 60 * 1e3, day: U, week: 7 * U, month: { add: function (a, b) { W.year.add(a, Math[b > 0 ? "floor" : "ceil"](b / 12)); var c = a.getMonth() + b % 12; if (c == 12) { c = 0; a.setYear(a.getFullYear() + 1) } else if (c == -1) { c = 11; a.setYear(a.getFullYear() - 1) } a.setMonth(c) }, diff: function (a, b) { var c = a.getFullYear() - b.getFullYear(); var d = a.getMonth() - b.getMonth() + c * 12; var e = a.getDate() - b.getDate(); return d + e / 30 } }, year: { add: function (a, b) { a.setYear(a.getFullYear() + Math[b > 0 ? "floor" : "ceil"](b)) }, diff: function (a, b) { return W.month.diff(a, b) / 12 } } }; for (var X in W) { if (X.substring(X.length - 1) != "s") { W[X + "s"] = W[X] } } var Y = function (a, b, c) { if (T.formats[c]["shortcuts"][b]) { return T.strftime(a, T.formats[c]["shortcuts"][b], c) } else { var d = (T.formats[c]["codes"][b] || "").split("."); var e = a["get" + d[0]] ? a["get" + d[0]]() : ""; if (d[1]) { e = V(e, d[1]) } return e } }; T.strftime = function (a, b, c, d) { var e = "perl"; var f = T.regional.getLocale(); if (c && T.formats.hasOwnProperty(c)) { e = c } else if (c && T.regional.hasOwnProperty(c)) { f = c } if (d && T.formats.hasOwnProperty(d)) { e = d } else if (d && T.regional.hasOwnProperty(d)) { f = d } if ($(a) != "[object Object]" || a._type != "jsDate") { a = new T(a); a.locale = f } if (!b) { b = a.formatString || T.regional[f]["formatString"] } var g = b || "%Y-%m-%d", h = "", i; while (g.length > 0) { if (i = g.match(T.formats[e].codes.matcher)) { h += g.slice(0, i.index); h += (i[1] || "") + Y(a, i[2], e); g = g.slice(i.index + i[0].length) } else { h += g; g = "" } } return h }; T.formats = { ISO: "%Y-%m-%dT%H:%M:%S.%N%G", SQL: "%Y-%m-%d %H:%M:%S" }; T.formats.perl = { codes: { matcher: /()%(#?(%|[a-z]))/i, Y: "FullYear", y: "ShortYear.2", m: "MonthNumber.2", "#m": "MonthNumber", B: "MonthName", b: "AbbrMonthName", d: "Date.2", "#d": "Date", e: "Date", A: "DayName", a: "AbbrDayName", w: "Day", H: "Hours.2", "#H": "Hours", I: "Hours12.2", "#I": "Hours12", p: "AMPM", M: "Minutes.2", "#M": "Minutes", S: "Seconds.2", "#S": "Seconds", s: "Unix", N: "Milliseconds.3", "#N": "Milliseconds", O: "TimezoneOffset", Z: "TimezoneName", G: "GmtOffset" }, shortcuts: { F: "%Y-%m-%d", T: "%H:%M:%S", X: "%H:%M:%S", x: "%m/%d/%y", D: "%m/%d/%y", "#c": "%a %b %e %H:%M:%S %Y", v: "%e-%b-%Y", R: "%H:%M", r: "%I:%M:%S %p", t: "\t", n: "\n", "%": "%"} }; T.formats.php = { codes: { matcher: /()%((%|[a-z]))/i, a: "AbbrDayName", A: "DayName", d: "Date.2", e: "Date", j: "DayOfYear.3", u: "DayOfWeek", w: "Day", U: "FullWeekOfYear.2", V: "IsoWeek.2", W: "WeekOfYear.2", b: "AbbrMonthName", B: "MonthName", m: "MonthNumber.2", h: "AbbrMonthName", C: "Century.2", y: "ShortYear.2", Y: "FullYear", H: "Hours.2", I: "Hours12.2", l: "Hours12", p: "AMPM", P: "AmPm", M: "Minutes.2", S: "Seconds.2", s: "Unix", O: "TimezoneOffset", z: "GmtOffset", Z: "TimezoneAbbr" }, shortcuts: { D: "%m/%d/%y", F: "%Y-%m-%d", T: "%H:%M:%S", X: "%H:%M:%S", x: "%m/%d/%y", R: "%H:%M", r: "%I:%M:%S %p", t: "\t", n: "\n", "%": "%"} }; T.createDate = function (a) { function f(a, b) { var c = parseFloat(b[1]); var d = parseFloat(b[2]); var e = parseFloat(b[3]); var f = T.config.defaultCentury; var g, h, i, j; if (c > 31) { h = e; i = d; g = f + c } else { h = d; i = c; g = f + e } j = i + "/" + h + "/" + g; return a.replace(/^([0-9]{1,2})[-\/]([0-9]{1,2})[-\/]([0-9]{1,2})/, j) } if (a == null) { return new Date } if (a instanceof Date) { return a } if (typeof a == "number") { return new Date(a) } var b = String(a).replace(/^\s*(.+)\s*$/g, "$1"); b = b.replace(/^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,4})/, "$1/$2/$3"); b = b.replace(/^(3[01]|[0-2]?\d)[-\/]([a-z]{3,})[-\/](\d{4})/i, "$1 $2 $3"); var c = b.match(/^(3[01]|[0-2]?\d)[-\/]([a-z]{3,})[-\/](\d{2})\D*/i); if (c && c.length > 3) { var d = parseFloat(c[3]); var e = T.config.defaultCentury + d; e = String(e); b = b.replace(/^(3[01]|[0-2]?\d)[-\/]([a-z]{3,})[-\/](\d{2})\D*/i, c[1] + " " + c[2] + " " + e) } c = b.match(/^([0-9]{1,2})[-\/]([0-9]{1,2})[-\/]([0-9]{1,2})[^0-9]/); if (c && c.length > 3) { b = f(b, c) } var c = b.match(/^([0-9]{1,2})[-\/]([0-9]{1,2})[-\/]([0-9]{1,2})$/); if (c && c.length > 3) { b = f(b, c) } var g = 0; var h = T.matchers.length; var i, j, k = b, l; while (g < h) { j = Date.parse(k); if (!isNaN(j)) { return new Date(j) } i = T.matchers[g]; if (typeof i == "function") { l = i.call(T, k); if (l instanceof Date) { return l } } else { k = b.replace(i[0], i[1]) } g++ } return NaN }; T.daysInMonth = function (a, c) { if (c == 2) { return (new Date(a, 1, 29)).getDate() == 29 ? 29 : 28 } return [b, 31, b, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][c] }; T.matchers = [[/(3[01]|[0-2]\d)\s*\.\s*(1[0-2]|0\d)\s*\.\s*([1-9]\d{3})/, "$2/$1/$3"], [/([1-9]\d{3})\s*-\s*(1[0-2]|0\d)\s*-\s*(3[01]|[0-2]\d)/, "$2/$3/$1"], function (a) { var b = a.match(/^(?:(.+)\s+)?([012]?\d)(?:\s*\:\s*(\d\d))?(?:\s*\:\s*(\d\d(\.\d*)?))?\s*(am|pm)?\s*$/i); if (b) { if (b[1]) { var c = this.createDate(b[1]); if (isNaN(c)) { return } } else { var c = new Date; c.setMilliseconds(0) } var d = parseFloat(b[2]); if (b[6]) { d = b[6].toLowerCase() == "am" ? d == 12 ? 0 : d : d == 12 ? 12 : d + 12 } c.setHours(d, parseInt(b[3] || 0, 10), parseInt(b[4] || 0, 10), (parseFloat(b[5] || 0) || 0) * 1e3); return c } else { return a } }, function (a) { var b = a.match(/^(?:(.+))[T|\s+]([012]\d)(?:\:(\d\d))(?:\:(\d\d))(?:\.\d+)([\+\-]\d\d\:\d\d)$/i); if (b) { if (b[1]) { var c = this.createDate(b[1]); if (isNaN(c)) { return } } else { var c = new Date; c.setMilliseconds(0) } var d = parseFloat(b[2]); c.setHours(d, parseInt(b[3], 10), parseInt(b[4], 10), parseFloat(b[5]) * 1e3); return c } else { return a } }, function (a) { var b = a.match(/^([0-3]?\d)\s*[-\/.\s]{1}\s*([a-zA-Z]{3,9})\s*[-\/.\s]{1}\s*([0-3]?\d)$/); if (b) { var c = new Date; var d = T.config.defaultCentury; var e = parseFloat(b[1]); var f = parseFloat(b[3]); var g, h, i; if (e > 31) { h = f; g = d + e } else { h = e; g = d + f } var i = Z(b[2], T.regional[T.regional.getLocale()]["monthNamesShort"]); if (i == -1) { i = Z(b[2], T.regional[T.regional.getLocale()]["monthNames"]) } c.setFullYear(g, i, h); c.setHours(0, 0, 0, 0); return c } else { return a } } ]; a.jsDate = T; a.jqplot.sprintf = function () { function f(a, b, c, e, f, g) { if (e != null) { a = a.slice(0, e) } return d(a, "", b, c, f, g) } function e(a, c, e, f, g, h, i, j) { var k = a >>> 0; e = e && k && { 2: "0b", 8: "0", 16: "0x"}[c] || ""; a = e + b(k.toString(c), h || 0, "0", false); return d(a, e, f, g, i, j) } function d(a, c, d, e, f, g) { var h = e - a.length; if (h > 0) { var i = " "; if (g) { i = " " } if (d || !f) { a = b(a, e, i, d) } else { a = a.slice(0, c.length) + b("", h, "0", true) + a.slice(c.length) } } return a } function c(b) { var c = new String(b); for (var d = 10; d > 0; d--) { if (c == (c = c.replace(/^(\d+)(\d{3})/, "$1" + a.jqplot.sprintf.thousandsSeparator + "$2"))) break } return c } function b(a, b, c, d) { var e = a.length >= b ? "" : Array(1 + b - a.length >>> 0).join(c); return d ? a + e : e + a } var g = arguments, h = 0, i = g[h++]; return i.replace(a.jqplot.sprintf.regex, function (a, i, j, k, l, m, n) { if (a == "%%") { return "%" } var o = false, p = "", q = false, r = false, s = false, t = false; for (var u = 0; j && u < j.length; u++) switch (j.charAt(u)) { case " ": p = " "; break; case "+": p = "+"; break; case "-": o = true; break; case "0": q = true; break; case "#": r = true; break; case "&": s = true; break; case "'": t = true; break } if (!k) { k = 0 } else if (k == "*") { k = +g[h++] } else if (k.charAt(0) == "*") { k = +g[k.slice(1, -1)] } else { k = +k } if (k < 0) { k = -k; o = true } if (!isFinite(k)) { throw new Error("$.jqplot.sprintf: (minimum-)width must be finite") } if (!m) { m = "fFeE".indexOf(n) > -1 ? 6 : n == "d" ? 0 : void 0 } else if (m == "*") { m = +g[h++] } else if (m.charAt(0) == "*") { m = +g[m.slice(1, -1)] } else { m = +m } var v = i ? g[i.slice(0, -1)] : g[h++]; switch (n) { case "s": { if (v == null) { return "" } return f(String(v), o, k, m, q, s) }; case "c": return f(String.fromCharCode(+v), o, k, m, q, s); case "b": return e(v, 2, r, o, k, m, q, s); case "o": return e(v, 8, r, o, k, m, q, s); case "x": return e(v, 16, r, o, k, m, q, s); case "X": return e(v, 16, r, o, k, m, q, s).toUpperCase(); case "u": return e(v, 10, r, o, k, m, q, s); case "i": { var w = parseInt(+v, 10); if (isNaN(w)) { return "" } var x = w < 0 ? "-" : p; var y = t ? c(String(Math.abs(w))) : String(Math.abs(w)); v = x + b(y, m, "0", false); return d(v, x, o, k, q, s) }; case "d": { var w = Math.round(+v); if (isNaN(w)) { return "" } var x = w < 0 ? "-" : p; var y = t ? c(String(Math.abs(w))) : String(Math.abs(w)); v = x + b(y, m, "0", false); return d(v, x, o, k, q, s) }; case "e": case "E": case "f": case "F": case "g": case "G": { var w = +v; if (isNaN(w)) { return "" } var x = w < 0 ? "-" : p; var z = ["toExponential", "toFixed", "toPrecision"]["efg".indexOf(n.toLowerCase())]; var A = ["toString", "toUpperCase"]["eEfFgG".indexOf(n) % 2]; var y = Math.abs(w)[z](m); y = t ? c(y) : y; v = x + y; return d(v, x, o, k, q, s)[A]() }; case "p": case "P": { var w = +v; if (isNaN(w)) { return "" } var x = w < 0 ? "-" : p; var B = String(Number(Math.abs(w)).toExponential()).split(/e|E/); var C = B[0].indexOf(".") != -1 ? B[0].length - 1 : B[0].length; var D = B[1] < 0 ? -B[1] - 1 : 0; if (Math.abs(w) < 1) { if (C + D <= m) { v = x + Math.abs(w).toPrecision(C) } else { if (C <= m - 1) { v = x + Math.abs(w).toExponential(C - 1) } else { v = x + Math.abs(w).toExponential(m - 1) } } } else { var E = C <= m ? C : m; v = x + Math.abs(w).toPrecision(E) } var A = ["toString", "toUpperCase"]["pP".indexOf(n) % 2]; return d(v, x, o, k, q, s)[A]() }; case "n": return ""; default: return a } }) }; a.jqplot.sprintf.thousandsSeparator = ","; a.jqplot.sprintf.regex = /%%|%(\d+\$)?([-+#0&\' ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([nAscboxXuidfegpEGP])/g; a.jqplot.getSignificantFigures = function (a) { var b = String(Number(Math.abs(a)).toExponential()).split(/e|E/); var c = b[0].indexOf(".") != -1 ? b[0].length - 1 : b[0].length; var d = b[1] < 0 ? -b[1] - 1 : 0; var e = parseInt(b[1], 10); var f = e + 1 > 0 ? e + 1 : 0; var g = c <= f ? 0 : c - e - 1; return { significantDigits: c, digitsLeft: f, digitsRight: g, zeros: d, exponent: e} }; a.jqplot.getPrecision = function (b) { return a.jqplot.getSignificantFigures(b).digitsRight } })(jQuery); var backCompat = $.uiBackCompat !== false; $.jqplot.effects = { effect: {} }; var dataSpace = "jqplot.storage."; $.extend($.jqplot.effects, { version: "1.9pre", save: function (a, b) { for (var c = 0; c < b.length; c++) { if (b[c] !== null) { a.data(dataSpace + b[c], a[0].style[b[c]]) } } }, restore: function (a, b) { for (var c = 0; c < b.length; c++) { if (b[c] !== null) { a.css(b[c], a.data(dataSpace + b[c])) } } }, setMode: function (a, b) { if (b === "toggle") { b = a.is(":hidden") ? "show" : "hide" } return b }, createWrapper: function (a) { if (a.parent().is(".ui-effects-wrapper")) { return a.parent() } var b = { width: a.outerWidth(true), height: a.outerHeight(true), "float": a.css("float") }, c = $("<div></div>").addClass("ui-effects-wrapper").css({ fontSize: "100%", background: "transparent", border: "none", margin: 0, padding: 0 }), d = { width: a.width(), height: a.height() }, e = document.activeElement; a.wrap(c); if (a[0] === e || $.contains(a[0], e)) { $(e).focus() } c = a.parent(); if (a.css("position") === "static") { c.css({ position: "relative" }); a.css({ position: "relative" }) } else { $.extend(b, { position: a.css("position"), zIndex: a.css("z-index") }); $.each(["top", "left", "bottom", "right"], function (c, d) { b[d] = a.css(d); if (isNaN(parseInt(b[d], 10))) { b[d] = "auto" } }); a.css({ position: "relative", top: 0, left: 0, right: "auto", bottom: "auto" }) } a.css(d); return c.css(b).show() }, removeWrapper: function (a) { var b = document.activeElement; if (a.parent().is(".ui-effects-wrapper")) { a.parent().replaceWith(a); if (a[0] === b || $.contains(a[0], b)) { $(b).focus() } } return a } }); $.fn.extend({ jqplotEffect: function (a, b, c, d) { function j(a) { function f() { if ($.isFunction(c)) { c.call(b[0]) } if ($.isFunction(a)) { a() } } var b = $(this), c = e.complete, d = e.mode; if (b.is(":hidden") ? d === "hide" : d === "show") { f() } else { h.call(b[0], e, f) } } var e = _normalizeArguments.apply(this, arguments), f = e.mode, g = e.queue, h = $.jqplot.effects.effect[e.effect], i = !h && backCompat && $.jqplot.effects[e.effect]; if ($.fx.off || !(h || i)) { if (f) { return this[f](e.duration, e.complete) } else { return this.each(function () { if (e.complete) { e.complete.call(this) } }) } } if (h) { return g === false ? this.each(j) : this.queue(g || "fx", j) } else { return i.call(this, { options: e, duration: e.duration, callback: e.complete, mode: e.mode }) } } }); var rvertical = /up|down|vertical/, rpositivemotion = /up|left|vertical|horizontal/; $.jqplot.effects.effect.blind = function (a, b) { var c = $(this), d = ["position", "top", "bottom", "left", "right", "height", "width"], e = $.jqplot.effects.setMode(c, a.mode || "hide"), f = a.direction || "up", g = rvertical.test(f), h = g ? "height" : "width", i = g ? "top" : "left", j = rpositivemotion.test(f), k = {}, l = e === "show", m, n, o; if (c.parent().is(".ui-effects-wrapper")) { $.jqplot.effects.save(c.parent(), d) } else { $.jqplot.effects.save(c, d) } c.show(); o = parseInt(c.css("top"), 10); m = $.jqplot.effects.createWrapper(c).css({ overflow: "hidden" }); n = g ? m[h]() + o : m[h](); k[h] = l ? String(n) : "0"; if (!j) { c.css(g ? "bottom" : "right", 0).css(g ? "top" : "left", "").css({ position: "absolute" }); k[i] = l ? "0" : String(n) } if (l) { m.css(h, 0); if (!j) { m.css(i, n) } } m.animate(k, { duration: a.duration, easing: a.easing, queue: false, complete: function () { if (e === "hide") { c.hide() } $.jqplot.effects.restore(c, d); $.jqplot.effects.removeWrapper(c); b() } }) }; (function (a) { function l(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; var h = e.plugins.barRenderer.highlightedSeriesIndex; if (h != null && e.series[h].highlightMouseDown) { g(e) } var i = jQuery.Event("jqplotDataRightClick"); i.pageX = a.pageX; i.pageY = a.pageY; e.target.trigger(i, f) } } function k(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; var g = jQuery.Event("jqplotDataClick"); g.pageX = a.pageX; g.pageY = a.pageY; e.target.trigger(g, f) } } function j(a, b, c, d, e) { var f = e.plugins.barRenderer.highlightedSeriesIndex; if (f != null && e.series[f].highlightMouseDown) { g(e) } } function i(a, b, c, d, e) { if (d) { var h = [d.seriesIndex, d.pointIndex, d.data]; if (e.series[h[0]].highlightMouseDown && !(h[0] == e.plugins.barRenderer.highlightedSeriesIndex && h[1] == e.series[h[0]]._highlightedPoint)) { var i = jQuery.Event("jqplotDataHighlight"); i.pageX = a.pageX; i.pageY = a.pageY; e.target.trigger(i, h); f(e, d.seriesIndex, d.pointIndex, d.points) } } else if (d == null) { g(e) } } function h(a, b, c, d, e) { if (d) { var h = [d.seriesIndex, d.pointIndex, d.data]; var i = jQuery.Event("jqplotDataMouseOver"); i.pageX = a.pageX; i.pageY = a.pageY; e.target.trigger(i, h); if (e.series[h[0]].highlightMouseOver && !(h[0] == e.plugins.barRenderer.highlightedSeriesIndex && h[1] == e.series[h[0]]._highlightedPoint)) { var j = jQuery.Event("jqplotDataHighlight"); j.pageX = a.pageX; j.pageY = a.pageY; e.target.trigger(j, h); f(e, d.seriesIndex, d.pointIndex, d.points) } } else if (d == null) { g(e) } } function g(a) { var b = a.plugins.barRenderer.highlightCanvas; b._ctx.clearRect(0, 0, b._ctx.canvas.width, b._ctx.canvas.height); for (var c = 0; c < a.series.length; c++) { a.series[c]._highlightedPoint = null } a.plugins.barRenderer.highlightedSeriesIndex = null; a.target.trigger("jqplotDataUnhighlight"); b = null } function f(a, b, c, d) { var e = a.series[b]; var f = a.plugins.barRenderer.highlightCanvas; f._ctx.clearRect(0, 0, f._ctx.canvas.width, f._ctx.canvas.height); e._highlightedPoint = c; a.plugins.barRenderer.highlightedSeriesIndex = b; var g = { fillStyle: e.highlightColors[c] }; e.renderer.shapeRenderer.draw(f._ctx, d, g); f = null } function e() { if (this.plugins.barRenderer && this.plugins.barRenderer.highlightCanvas) { this.plugins.barRenderer.highlightCanvas.resetCanvas(); this.plugins.barRenderer.highlightCanvas = null } this.plugins.barRenderer = { highlightedSeriesIndex: null }; this.plugins.barRenderer.highlightCanvas = new a.jqplot.GenericCanvas; this.eventCanvas._elem.before(this.plugins.barRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-barRenderer-highlight-canvas", this._plotDimensions, this)); this.plugins.barRenderer.highlightCanvas.setContext(); this.eventCanvas._elem.bind("mouseleave", { plot: this }, function (a) { g(a.data.plot) }) } function d(b, c, d) { for (var e = 0; e < this.series.length; e++) { if (this.series[e].renderer.constructor == a.jqplot.BarRenderer) { if (this.series[e].highlightMouseOver) { this.series[e].highlightMouseDown = false } } } } function c(b) { var c = []; for (var d = 0; d < b.length; d++) { var e = a.jqplot.getColorComponents(b[d]); var f = [e[0], e[1], e[2]]; var g = f[0] + f[1] + f[2]; for (var h = 0; h < 3; h++) { f[h] = g > 570 ? f[h] * .8 : f[h] + .3 * (255 - f[h]); f[h] = parseInt(f[h], 10) } c.push("rgb(" + f[0] + "," + f[1] + "," + f[2] + ")") } return c } function b(b, c, d, e) { if (this.rendererOptions.barDirection == "horizontal") { this._stackAxis = "x"; this._primaryAxis = "_yaxis" } if (this.rendererOptions.waterfall == true) { this._data = a.extend(true, [], this.data); var f = 0; var g = !this.rendererOptions.barDirection || this.rendererOptions.barDirection === "vertical" || this.transposedData === false ? 1 : 0; for (var h = 0; h < this.data.length; h++) { f += this.data[h][g]; if (h > 0) { this.data[h][g] += this.data[h - 1][g] } } this.data[this.data.length] = g == 1 ? [this.data.length + 1, f] : [f, this.data.length + 1]; this._data[this._data.length] = g == 1 ? [this._data.length + 1, f] : [f, this._data.length + 1] } if (this.rendererOptions.groups > 1) { this.breakOnNull = true; var i = this.data.length; var j = parseInt(i / this.rendererOptions.groups, 10); var k = 0; for (var h = j; h < i; h += j) { this.data.splice(h + k, 0, [null, null]); k++ } for (h = 0; h < this.data.length; h++) { if (this._primaryAxis == "_xaxis") { this.data[h][0] = h + 1 } else { this.data[h][1] = h + 1 } } } } a.jqplot.BarRenderer = function () { a.jqplot.LineRenderer.call(this) }; a.jqplot.BarRenderer.prototype = new a.jqplot.LineRenderer; a.jqplot.BarRenderer.prototype.constructor = a.jqplot.BarRenderer; a.jqplot.BarRenderer.prototype.init = function (b, c) { this.barPadding = 8; this.barMargin = 10; this.barDirection = "vertical"; this.barWidth = null; this.shadowOffset = 2; this.shadowDepth = 5; this.shadowAlpha = .08; this.waterfall = false; this.groups = 1; this.varyBarColor = false; this.highlightMouseOver = true; this.highlightMouseDown = false; this.highlightColors = []; this.transposedData = true; this.renderer.animation = { show: false, direction: "down", speed: 3e3, _supported: true }; this._type = "bar"; if (b.highlightMouseDown && b.highlightMouseOver == null) { b.highlightMouseOver = false } a.extend(true, this, b); a.extend(true, this.renderer, b); this.fill = true; if (this.barDirection === "horizontal" && this.rendererOptions.animation && this.rendererOptions.animation.direction == null) { this.renderer.animation.direction = "left" } if (this.waterfall) { this.fillToZero = false; this.disableStack = true } if (this.barDirection == "vertical") { this._primaryAxis = "_xaxis"; this._stackAxis = "y"; this.fillAxis = "y" } else { this._primaryAxis = "_yaxis"; this._stackAxis = "x"; this.fillAxis = "x" } this._highlightedPoint = null; this._plotSeriesInfo = null; this._dataColors = []; this._barPoints = []; var f = { lineJoin: "miter", lineCap: "round", fill: true, isarc: false, strokeStyle: this.color, fillStyle: this.color, closePath: this.fill }; this.renderer.shapeRenderer.init(f); var g = { lineJoin: "miter", lineCap: "round", fill: true, isarc: false, angle: this.shadowAngle, offset: this.shadowOffset, alpha: this.shadowAlpha, depth: this.shadowDepth, closePath: this.fill }; this.renderer.shadowRenderer.init(g); c.postInitHooks.addOnce(d); c.postDrawHooks.addOnce(e); c.eventListenerHooks.addOnce("jqplotMouseMove", h); c.eventListenerHooks.addOnce("jqplotMouseDown", i); c.eventListenerHooks.addOnce("jqplotMouseUp", j); c.eventListenerHooks.addOnce("jqplotClick", k); c.eventListenerHooks.addOnce("jqplotRightClick", l) }; a.jqplot.preSeriesInitHooks.push(b); a.jqplot.BarRenderer.prototype.calcSeriesNumbers = function () { var b = 0; var c = 0; var d = this[this._primaryAxis]; var e, f, g; for (var h = 0; h < d._series.length; h++) { f = d._series[h]; if (f === this) { g = h } if (f.renderer.constructor == a.jqplot.BarRenderer) { b += f.data.length; c += 1 } } return [b, c, g] }; a.jqplot.BarRenderer.prototype.setBarWidth = function () { var a; var b = 0; var c = 0; var d = this[this._primaryAxis]; var e, f, g; var h = this._plotSeriesInfo = this.renderer.calcSeriesNumbers.call(this); b = h[0]; c = h[1]; var i = d.numberTicks; var j = (i - 1) / 2; if (d.name == "xaxis" || d.name == "x2axis") { if (this._stack) { this.barWidth = (d._offsets.max - d._offsets.min) / b * c - this.barMargin } else { this.barWidth = ((d._offsets.max - d._offsets.min) / j - this.barPadding * (c - 1) - this.barMargin * 2) / c } } else { if (this._stack) { this.barWidth = (d._offsets.min - d._offsets.max) / b * c - this.barMargin } else { this.barWidth = ((d._offsets.min - d._offsets.max) / j - this.barPadding * (c - 1) - this.barMargin * 2) / c } } return [b, c] }; a.jqplot.BarRenderer.prototype.draw = function (b, c, d) { var e; var f = a.extend({}, d); var g = f.shadow != undefined ? f.shadow : this.shadow; var h = f.showLine != undefined ? f.showLine : this.showLine; var i = f.fill != undefined ? f.fill : this.fill; var j = this.xaxis; var k = this.yaxis; var l = this._xaxis.series_u2p; var m = this._yaxis.series_u2p; var n, o; this._dataColors = []; this._barPoints = []; if (this.barWidth == null) { this.renderer.setBarWidth.call(this) } var p = this._plotSeriesInfo = this.renderer.calcSeriesNumbers.call(this); var q = p[0]; var r = p[1]; var s = p[2]; var t = []; if (this._stack) { this._barNudge = 0 } else { this._barNudge = (-Math.abs(r / 2 - .5) + s) * (this.barWidth + this.barPadding) } if (h) { var u = new a.jqplot.ColorGenerator(this.negativeSeriesColors); var v = new a.jqplot.ColorGenerator(this.seriesColors); var w = u.get(this.index); if (!this.useNegativeColors) { w = f.fillStyle } var x = f.fillStyle; var y; var z; var A; if (this.barDirection == "vertical") { for (var e = 0; e < c.length; e++) { if (this.data[e][1] == null) { continue } t = []; y = c[e][0] + this._barNudge; A; if (this._stack && this._prevGridData.length) { A = this._prevGridData[e][1] } else { if (this.fillToZero) { A = this._yaxis.series_u2p(0) } else if (this.waterfall && e > 0 && e < this.gridData.length - 1) { A = this.gridData[e - 1][1] } else if (this.waterfall && e == 0 && e < this.gridData.length - 1) { if (this._yaxis.min <= 0 && this._yaxis.max >= 0) { A = this._yaxis.series_u2p(0) } else if (this._yaxis.min > 0) { A = b.canvas.height } else { A = 0 } } else if (this.waterfall && e == this.gridData.length - 1) { if (this._yaxis.min <= 0 && this._yaxis.max >= 0) { A = this._yaxis.series_u2p(0) } else if (this._yaxis.min > 0) { A = b.canvas.height } else { A = 0 } } else { A = b.canvas.height } } if (this.fillToZero && this._plotData[e][1] < 0 || this.waterfall && this._data[e][1] < 0) { if (this.varyBarColor && !this._stack) { if (this.useNegativeColors) { f.fillStyle = u.next() } else { f.fillStyle = v.next() } } else { f.fillStyle = w } } else { if (this.varyBarColor && !this._stack) { f.fillStyle = v.next() } else { f.fillStyle = x } } if (!this.fillToZero || this._plotData[e][1] >= 0) { t.push([y - this.barWidth / 2, A]); t.push([y - this.barWidth / 2, c[e][1]]); t.push([y + this.barWidth / 2, c[e][1]]); t.push([y + this.barWidth / 2, A]) } else { t.push([y - this.barWidth / 2, c[e][1]]); t.push([y - this.barWidth / 2, A]); t.push([y + this.barWidth / 2, A]); t.push([y + this.barWidth / 2, c[e][1]]) } this._barPoints.push(t); if (g && !this._stack) { var B = a.extend(true, {}, f); delete B.fillStyle; this.renderer.shadowRenderer.draw(b, t, B) } var C = f.fillStyle || this.color; this._dataColors.push(C); this.renderer.shapeRenderer.draw(b, t, f) } } else if (this.barDirection == "horizontal") { for (var e = 0; e < c.length; e++) { if (this.data[e][0] == null) { continue } t = []; y = c[e][1] - this._barNudge; z; if (this._stack && this._prevGridData.length) { z = this._prevGridData[e][0] } else { if (this.fillToZero) { z = this._xaxis.series_u2p(0) } else if (this.waterfall && e > 0 && e < this.gridData.length - 1) { z = this.gridData[e - 1][1] } else if (this.waterfall && e == 0 && e < this.gridData.length - 1) { if (this._xaxis.min <= 0 && this._xaxis.max >= 0) { z = this._xaxis.series_u2p(0) } else if (this._xaxis.min > 0) { z = 0 } else { z = b.canvas.width } } else if (this.waterfall && e == this.gridData.length - 1) { if (this._xaxis.min <= 0 && this._xaxis.max >= 0) { z = this._xaxis.series_u2p(0) } else if (this._xaxis.min > 0) { z = 0 } else { z = b.canvas.width } } else { z = 0 } } if (this.fillToZero && this._plotData[e][1] < 0 || this.waterfall && this._data[e][1] < 0) { if (this.varyBarColor && !this._stack) { if (this.useNegativeColors) { f.fillStyle = u.next() } else { f.fillStyle = v.next() } } } else { if (this.varyBarColor && !this._stack) { f.fillStyle = v.next() } else { f.fillStyle = x } } if (!this.fillToZero || this._plotData[e][0] >= 0) { t.push([z, y + this.barWidth / 2]); t.push([z, y - this.barWidth / 2]); t.push([c[e][0], y - this.barWidth / 2]); t.push([c[e][0], y + this.barWidth / 2]) } else { t.push([c[e][0], y + this.barWidth / 2]); t.push([c[e][0], y - this.barWidth / 2]); t.push([z, y - this.barWidth / 2]); t.push([z, y + this.barWidth / 2]) } this._barPoints.push(t); if (g && !this._stack) { var B = a.extend(true, {}, f); delete B.fillStyle; this.renderer.shadowRenderer.draw(b, t, B) } var C = f.fillStyle || this.color; this._dataColors.push(C); this.renderer.shapeRenderer.draw(b, t, f) } } } if (this.highlightColors.length == 0) { this.highlightColors = a.jqplot.computeHighlightColors(this._dataColors) } else if (typeof this.highlightColors == "string") { var p = this.highlightColors; this.highlightColors = []; for (var e = 0; e < this._dataColors.length; e++) { this.highlightColors.push(p) } } }; a.jqplot.BarRenderer.prototype.drawShadow = function (a, b, c) { var d; var e = c != undefined ? c : {}; var f = e.shadow != undefined ? e.shadow : this.shadow; var g = e.showLine != undefined ? e.showLine : this.showLine; var h = e.fill != undefined ? e.fill : this.fill; var i = this.xaxis; var j = this.yaxis; var k = this._xaxis.series_u2p; var l = this._yaxis.series_u2p; var m, n, o, p, q, r; if (this._stack && this.shadow) { if (this.barWidth == null) { this.renderer.setBarWidth.call(this) } var s = this._plotSeriesInfo = this.renderer.calcSeriesNumbers.call(this); p = s[0]; q = s[1]; r = s[2]; if (this._stack) { this._barNudge = 0 } else { this._barNudge = (-Math.abs(q / 2 - .5) + r) * (this.barWidth + this.barPadding) } if (g) { if (this.barDirection == "vertical") { for (var d = 0; d < b.length; d++) { if (this.data[d][1] == null) { continue } n = []; var t = b[d][0] + this._barNudge; var u; if (this._stack && this._prevGridData.length) { u = this._prevGridData[d][1] } else { if (this.fillToZero) { u = this._yaxis.series_u2p(0) } else { u = a.canvas.height } } n.push([t - this.barWidth / 2, u]); n.push([t - this.barWidth / 2, b[d][1]]); n.push([t + this.barWidth / 2, b[d][1]]); n.push([t + this.barWidth / 2, u]); this.renderer.shadowRenderer.draw(a, n, e) } } else if (this.barDirection == "horizontal") { for (var d = 0; d < b.length; d++) { if (this.data[d][0] == null) { continue } n = []; var t = b[d][1] - this._barNudge; var v; if (this._stack && this._prevGridData.length) { v = this._prevGridData[d][0] } else { v = 0 } n.push([v, t + this.barWidth / 2]); n.push([b[d][0], t + this.barWidth / 2]); n.push([b[d][0], t - this.barWidth / 2]); n.push([v, t - this.barWidth / 2]); this.renderer.shadowRenderer.draw(a, n, e) } } } } } })(jQuery); (function (a) { function b(b, c, d) { d = d || {}; d.axesDefaults = a.extend(true, { pad: 0 }, d.axesDefaults); d.legend = a.extend(true, { placement: "outside" }, d.legend); var e = false; if (d.seriesDefaults.renderer == a.jqplot.BezierCurveRenderer) { e = true } else if (d.series) { for (var f = 0; f < d.series.length; f++) { if (d.series[f].renderer == a.jqplot.BezierCurveRenderer) { e = true } } } if (e) { d.axesDefaults.renderer = a.jqplot.BezierAxisRenderer } } a.jqplot.BezierCurveRenderer = function () { a.jqplot.LineRenderer.call(this) }; a.jqplot.BezierCurveRenderer.prototype = new a.jqplot.LineRenderer; a.jqplot.BezierCurveRenderer.prototype.constructor = a.jqplot.BezierCurveRenderer; a.jqplot.BezierCurveRenderer.prototype.setGridData = function (a) { var b = this._xaxis.series_u2p; var c = this._yaxis.series_u2p; var d = this.data; this.gridData = []; this._prevGridData = []; var e = this.index; if (d.length == 2) { if (e == 0) { this.gridData = [[b.call(this._xaxis, d[0][0]), c.call(this._yaxis, d[0][1])], [b.call(this._xaxis, d[1][0]), c.call(this._yaxis, d[1][1]), b.call(this._xaxis, d[1][2]), c.call(this._yaxis, d[1][3]), b.call(this._xaxis, d[1][4]), c.call(this._yaxis, d[1][5])], [b.call(this._xaxis, d[1][4]), c.call(this._yaxis, this._yaxis.min)], [b.call(this._xaxis, d[0][0]), c.call(this._yaxis, this._yaxis.min)]] } else { var f = a.series[e - 1].data; this.gridData = [[b.call(this._xaxis, d[0][0]), c.call(this._yaxis, d[0][1])], [b.call(this._xaxis, d[1][0]), c.call(this._yaxis, d[1][1]), b.call(this._xaxis, d[1][2]), c.call(this._yaxis, d[1][3]), b.call(this._xaxis, d[1][4]), c.call(this._yaxis, d[1][5])], [b.call(this._xaxis, f[1][4]), c.call(this._yaxis, f[1][5])], [b.call(this._xaxis, f[1][2]), c.call(this._yaxis, f[1][3]), b.call(this._xaxis, f[1][0]), c.call(this._yaxis, f[1][1]), b.call(this._xaxis, f[0][0]), c.call(this._yaxis, f[0][1])]] } } else { if (e == 0) { this.gridData = [[b.call(this._xaxis, d[0][0]), c.call(this._yaxis, d[0][1])], [b.call(this._xaxis, d[1][0]), c.call(this._yaxis, d[1][1]), b.call(this._xaxis, d[2][0]), c.call(this._yaxis, d[2][1]), b.call(this._xaxis, d[3][0]), c.call(this._yaxis, d[3][1])], [b.call(this._xaxis, d[3][1]), c.call(this._yaxis, this._yaxis.min)], [b.call(this._xaxis, d[0][0]), c.call(this._yaxis, this._yaxis.min)]] } else { var f = a.series[e - 1].data; this.gridData = [[b.call(this._xaxis, d[0][0]), c.call(this._yaxis, d[0][1])], [b.call(this._xaxis, d[1][0]), c.call(this._yaxis, d[1][1]), b.call(this._xaxis, d[2][0]), c.call(this._yaxis, d[2][1]), b.call(this._xaxis, d[3][0]), c.call(this._yaxis, d[3][1])], [b.call(this._xaxis, f[3][0]), c.call(this._yaxis, f[3][1])], [b.call(this._xaxis, f[2][0]), c.call(this._yaxis, f[2][1]), b.call(this._xaxis, f[1][0]), c.call(this._yaxis, f[1][1]), b.call(this._xaxis, f[0][0]), c.call(this._yaxis, f[0][1])]] } } }; a.jqplot.BezierCurveRenderer.prototype.makeGridData = function (a, b) { var c = this._xaxis.series_u2p; var d = this._yaxis.series_u2p; var e = []; var f = []; var g = this.index; if (a.length == 2) { if (g == 0) { e = [[c.call(this._xaxis, a[0][0]), d.call(this._yaxis, a[0][1])], [c.call(this._xaxis, a[1][0]), d.call(this._yaxis, a[1][1]), c.call(this._xaxis, a[1][2]), d.call(this._yaxis, a[1][3]), c.call(this._xaxis, a[1][4]), d.call(this._yaxis, a[1][5])], [c.call(this._xaxis, a[1][4]), d.call(this._yaxis, this._yaxis.min)], [c.call(this._xaxis, a[0][0]), d.call(this._yaxis, this._yaxis.min)]] } else { var h = b.series[g - 1].data; e = [[c.call(this._xaxis, a[0][0]), d.call(this._yaxis, a[0][1])], [c.call(this._xaxis, a[1][0]), d.call(this._yaxis, a[1][1]), c.call(this._xaxis, a[1][2]), d.call(this._yaxis, a[1][3]), c.call(this._xaxis, a[1][4]), d.call(this._yaxis, a[1][5])], [c.call(this._xaxis, h[1][4]), d.call(this._yaxis, h[1][5])], [c.call(this._xaxis, h[1][2]), d.call(this._yaxis, h[1][3]), c.call(this._xaxis, h[1][0]), d.call(this._yaxis, h[1][1]), c.call(this._xaxis, h[0][0]), d.call(this._yaxis, h[0][1])]] } } else { if (g == 0) { e = [[c.call(this._xaxis, a[0][0]), d.call(this._yaxis, a[0][1])], [c.call(this._xaxis, a[1][0]), d.call(this._yaxis, a[1][1]), c.call(this._xaxis, a[2][0]), d.call(this._yaxis, a[2][1]), c.call(this._xaxis, a[3][0]), d.call(this._yaxis, a[3][1])], [c.call(this._xaxis, a[3][1]), d.call(this._yaxis, this._yaxis.min)], [c.call(this._xaxis, a[0][0]), d.call(this._yaxis, this._yaxis.min)]] } else { var h = b.series[g - 1].data; e = [[c.call(this._xaxis, a[0][0]), d.call(this._yaxis, a[0][1])], [c.call(this._xaxis, a[1][0]), d.call(this._yaxis, a[1][1]), c.call(this._xaxis, a[2][0]), d.call(this._yaxis, a[2][1]), c.call(this._xaxis, a[3][0]), d.call(this._yaxis, a[3][1])], [c.call(this._xaxis, h[3][0]), d.call(this._yaxis, h[3][1])], [c.call(this._xaxis, h[2][0]), d.call(this._yaxis, h[2][1]), c.call(this._xaxis, h[1][0]), d.call(this._yaxis, h[1][1]), c.call(this._xaxis, h[0][0]), d.call(this._yaxis, h[0][1])]] } } return e }; a.jqplot.BezierCurveRenderer.prototype.draw = function (a, b, c) { var d; a.save(); if (b.length) { if (this.showLine) { a.save(); var e = c != null ? c : {}; a.fillStyle = e.fillStyle || this.color; a.beginPath(); a.moveTo(b[0][0], b[0][1]); a.bezierCurveTo(b[1][0], b[1][1], b[1][2], b[1][3], b[1][4], b[1][5]); a.lineTo(b[2][0], b[2][1]); if (b[3].length == 2) { a.lineTo(b[3][0], b[3][1]) } else { a.bezierCurveTo(b[3][0], b[3][1], b[3][2], b[3][3], b[3][4], b[3][5]) } a.closePath(); a.fill(); a.restore() } } a.restore() }; a.jqplot.BezierCurveRenderer.prototype.drawShadow = function (a, b, c) { }; a.jqplot.BezierAxisRenderer = function () { a.jqplot.LinearAxisRenderer.call(this) }; a.jqplot.BezierAxisRenderer.prototype = new a.jqplot.LinearAxisRenderer; a.jqplot.BezierAxisRenderer.prototype.constructor = a.jqplot.BezierAxisRenderer; a.jqplot.BezierAxisRenderer.prototype.init = function (b) { a.extend(true, this, b); var c = this._dataBounds; for (var d = 0; d < this._series.length; d++) { var e = this._series[d]; var f = e.data; if (f.length == 4) { for (var g = 0; g < f.length; g++) { if (this.name == "xaxis" || this.name == "x2axis") { if (f[g][0] < c.min || c.min == null) { c.min = f[g][0] } if (f[g][0] > c.max || c.max == null) { c.max = f[g][0] } } else { if (f[g][1] < c.min || c.min == null) { c.min = f[g][1] } if (f[g][1] > c.max || c.max == null) { c.max = f[g][1] } } } } else { if (this.name == "xaxis" || this.name == "x2axis") { if (f[0][0] < c.min || c.min == null) { c.min = f[0][0] } if (f[0][0] > c.max || c.max == null) { c.max = f[0][0] } for (var g = 0; g < 5; g += 2) { if (f[1][g] < c.min || c.min == null) { c.min = f[1][g] } if (f[1][g] > c.max || c.max == null) { c.max = f[1][g] } } } else { if (f[0][1] < c.min || c.min == null) { c.min = f[0][1] } if (f[0][1] > c.max || c.max == null) { c.max = f[0][1] } for (var g = 1; g < 6; g += 2) { if (f[1][g] < c.min || c.min == null) { c.min = f[1][g] } if (f[1][g] > c.max || c.max == null) { c.max = f[1][g] } } } } } }; a.jqplot.preInitHooks.push(b) })(jQuery); (function (a) { a.jqplot.BlockRenderer = function () { a.jqplot.LineRenderer.call(this) }; a.jqplot.BlockRenderer.prototype = new a.jqplot.LineRenderer; a.jqplot.BlockRenderer.prototype.constructor = a.jqplot.BlockRenderer; a.jqplot.BlockRenderer.prototype.init = function (b) { this.css = { padding: "2px", border: "1px solid #999", textAlign: "center" }; this.escapeHtml = false; this.insertBreaks = true; this.varyBlockColors = false; a.extend(true, this, b); if (this.css.backgroundColor) { this.color = this.css.backgroundColor } else if (this.css.background) { this.color = this.css.background } else if (!this.varyBlockColors) { this.css.background = this.color } this.canvas = new a.jqplot.BlockCanvas; this.shadowCanvas = new a.jqplot.BlockCanvas; this.canvas._plotDimensions = this._plotDimensions; this.shadowCanvas._plotDimensions = this._plotDimensions; this._type = "block"; this.moveBlock = function (a, b, c, d) { var e = this.canvas._elem.children(":eq(" + a + ")"); this.data[a][0] = b; this.data[a][1] = c; this._plotData[a][0] = b; this._plotData[a][1] = c; this._stackData[a][0] = b; this._stackData[a][1] = c; this.gridData[a][0] = this._xaxis.series_u2p(b); this.gridData[a][1] = this._yaxis.series_u2p(c); var f = e.outerWidth(); var g = e.outerHeight(); var h = this.gridData[a][0] - f / 2 + "px"; var i = this.gridData[a][1] - g / 2 + "px"; if (d) { if (parseInt(d, 10)) { d = parseInt(d, 10) } e.animate({ left: h, top: i }, d) } else { e.css({ left: h, top: i }) } e = null } }; a.jqplot.BlockRenderer.prototype.draw = function (b, c, d) { if (this.plugins.pointLabels) { this.plugins.pointLabels.show = false } var e, f, g, c, h, i, j, k, l, m; var n = d != undefined ? d : {}; var o = new a.jqplot.ColorGenerator(this.seriesColors); this.canvas._elem.empty(); for (e = 0; e < this.gridData.length; e++) { g = this.data[e]; c = this.gridData[e]; h = ""; i = {}; if (typeof g[2] == "string") { h = g[2] } else if (typeof g[2] == "object") { i = g[2] } if (typeof g[3] == "object") { i = g[3] } if (this.insertBreaks) { h = h.replace(/ /g, "<br />") } i = a.extend(true, {}, this.css, i); f = a('<div style="position:absolute;margin-left:auto;margin-right:auto;"></div>'); this.canvas._elem.append(f); this.escapeHtml ? f.text(h) : f.html(h); delete i.position; delete i.marginRight; delete i.marginLeft; if (!i.background && !i.backgroundColor && !i.backgroundImage) { i.background = o.next() } f.css(i); j = f.outerWidth(); k = f.outerHeight(); l = c[0] - j / 2 + "px"; m = c[1] - k / 2 + "px"; f.css({ left: l, top: m }); f = null } }; a.jqplot.BlockCanvas = function () { a.jqplot.ElemContainer.call(this); this._ctx }; a.jqplot.BlockCanvas.prototype = new a.jqplot.ElemContainer; a.jqplot.BlockCanvas.prototype.constructor = a.jqplot.BlockCanvas; a.jqplot.BlockCanvas.prototype.createElement = function (b, c, d) { this._offsets = b; var e = "jqplot-blockCanvas"; if (c != undefined) { e = c } var f; if (this._elem) { f = this._elem.get(0) } else { f = document.createElement("div") } if (d != undefined) { this._plotDimensions = d } var g = this._plotDimensions.width - this._offsets.left - this._offsets.right + "px"; var h = this._plotDimensions.height - this._offsets.top - this._offsets.bottom + "px"; this._elem = a(f); this._elem.css({ position: "absolute", width: g, height: h, left: this._offsets.left, top: this._offsets.top }); this._elem.addClass(e); return this._elem }; a.jqplot.BlockCanvas.prototype.setContext = function () { this._ctx = { canvas: { width: 0, height: 0 }, clearRect: function () { return null } }; return this._ctx } })(jQuery); (function (a) { function l(b, c, d) { d = d || {}; d.axesDefaults = d.axesDefaults || {}; d.seriesDefaults = d.seriesDefaults || {}; var e = false; if (d.seriesDefaults.renderer == a.jqplot.BubbleRenderer) { e = true } else if (d.series) { for (var f = 0; f < d.series.length; f++) { if (d.series[f].renderer == a.jqplot.BubbleRenderer) { e = true } } } if (e) { d.axesDefaults.renderer = a.jqplot.BubbleAxisRenderer; d.sortData = false } } function k() { if (this.plugins.bubbleRenderer && this.plugins.bubbleRenderer.highlightCanvas) { this.plugins.bubbleRenderer.highlightCanvas.resetCanvas(); this.plugins.bubbleRenderer.highlightCanvas = null } this.plugins.bubbleRenderer = { highlightedSeriesIndex: null }; this.plugins.bubbleRenderer.highlightCanvas = new a.jqplot.GenericCanvas; this.plugins.bubbleRenderer.highlightLabel = null; this.plugins.bubbleRenderer.highlightLabelCanvas = a('<div style="position:absolute;"></div>'); var b = this._gridPadding.top; var c = this._gridPadding.left; var d = this._plotDimensions.width - this._gridPadding.left - this._gridPadding.right; var e = this._plotDimensions.height - this._gridPadding.top - this._gridPadding.bottom; this.plugins.bubbleRenderer.highlightLabelCanvas.css({ top: b, left: c, width: d + "px", height: e + "px" }); this.eventCanvas._elem.before(this.plugins.bubbleRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-bubbleRenderer-highlight-canvas", this._plotDimensions, this)); this.eventCanvas._elem.before(this.plugins.bubbleRenderer.highlightLabelCanvas); var f = this.plugins.bubbleRenderer.highlightCanvas.setContext() } function j(a, b, c, d, f) { if (d) { var g = d.seriesIndex; var h = d.pointIndex; var i = [g, h, d.data, f.series[g].gridData[h][2]]; var j = f.plugins.bubbleRenderer.highlightedSeriesIndex; if (j != null && f.series[j].highlightMouseDown) { e(f) } var k = jQuery.Event("jqplotDataRightClick"); k.pageX = a.pageX; k.pageY = a.pageY; f.target.trigger(k, i) } } function i(a, b, c, d, e) { if (d) { var f = d.seriesIndex; var g = d.pointIndex; var h = [f, g, d.data, e.series[f].gridData[g][2]]; var i = jQuery.Event("jqplotDataClick"); i.pageX = a.pageX; i.pageY = a.pageY; e.target.trigger(i, h) } } function h(a, b, c, d, f) { var g = f.plugins.bubbleRenderer.highlightedSeriesIndex; if (g != null && f.series[g].highlightMouseDown) { e(f) } } function g(a, b, c, f, g) { if (f) { var h = f.seriesIndex; var i = f.pointIndex; var j = [h, i, f.data, g.series[h].gridData[i][2]]; if (g.series[j[0]].highlightMouseDown && !(j[0] == g.plugins.bubbleRenderer.highlightedSeriesIndex && j[1] == g.series[j[0]]._highlightedPoint)) { var k = jQuery.Event("jqplotDataHighlight"); k.pageX = a.pageX; k.pageY = a.pageY; g.target.trigger(k, j); d(g, j[0], j[1]) } } else if (f == null) { e(g) } } function f(a, b, c, f, g) { if (f) { var h = f.seriesIndex; var i = f.pointIndex; var j = [h, i, f.data, g.series[h].gridData[i][2]]; var k = jQuery.Event("jqplotDataMouseOver"); k.pageX = a.pageX; k.pageY = a.pageY; g.target.trigger(k, j); if (g.series[j[0]].highlightMouseOver && !(j[0] == g.plugins.bubbleRenderer.highlightedSeriesIndex && j[1] == g.series[j[0]]._highlightedPoint)) { var l = jQuery.Event("jqplotDataHighlight"); l.pageX = a.pageX; l.pageY = a.pageY; g.target.trigger(l, j); d(g, j[0], j[1]) } } else if (f == null) { e(g) } } function e(a) { var b = a.plugins.bubbleRenderer.highlightCanvas; var c = a.plugins.bubbleRenderer.highlightedSeriesIndex; a.plugins.bubbleRenderer.highlightLabelCanvas.empty(); b._ctx.clearRect(0, 0, b._ctx.canvas.width, b._ctx.canvas.height); for (var d = 0; d < a.series.length; d++) { a.series[d]._highlightedPoint = null } a.plugins.bubbleRenderer.highlightedSeriesIndex = null; a.target.trigger("jqplotDataUnhighlight") } function d(a, b, c) { a.plugins.bubbleRenderer.highlightLabelCanvas.empty(); var d = a.series[b]; var e = a.plugins.bubbleRenderer.highlightCanvas; var f = e._ctx; f.clearRect(0, 0, f.canvas.width, f.canvas.height); d._highlightedPoint = c; a.plugins.bubbleRenderer.highlightedSeriesIndex = b; var g = d.highlightColorGenerator.get(c); var h = d.gridData[c][0], i = d.gridData[c][1], j = d.gridData[c][2]; f.save(); f.fillStyle = g; f.strokeStyle = g; f.lineWidth = 1; f.beginPath(); f.arc(h, i, j, 0, 2 * Math.PI, 0); f.closePath(); f.fill(); f.restore(); if (d.labels[c]) { a.plugins.bubbleRenderer.highlightLabel = d.labels[c].clone(); a.plugins.bubbleRenderer.highlightLabel.appendTo(a.plugins.bubbleRenderer.highlightLabelCanvas); a.plugins.bubbleRenderer.highlightLabel.addClass("jqplot-bubble-label-highlight") } } var b = function (a) { return Math.max.apply(Math, a) }; var c = function (a) { return Math.min.apply(Math, a) }; a.jqplot.BubbleRenderer = function () { a.jqplot.LineRenderer.call(this) }; a.jqplot.BubbleRenderer.prototype = new a.jqplot.LineRenderer; a.jqplot.BubbleRenderer.prototype.constructor = a.jqplot.BubbleRenderer; a.jqplot.BubbleRenderer.prototype.init = function (b, c) { this.varyBubbleColors = true; this.autoscaleBubbles = true; this.autoscaleMultiplier = 1; this.autoscalePointsFactor = -.07; this.escapeHtml = true; this.highlightMouseOver = true; this.highlightMouseDown = false; this.highlightColors = []; this.bubbleAlpha = 1; this.highlightAlpha = null; this.bubbleGradients = false; this.showLabels = true; this.radii = []; this.maxRadius = 0; this._highlightedPoint = null; this.labels = []; this.bubbleCanvases = []; this._type = "bubble"; if (b.highlightMouseDown && b.highlightMouseOver == null) { b.highlightMouseOver = false } a.extend(true, this, b); if (this.highlightAlpha == null) { this.highlightAlpha = this.bubbleAlpha; if (this.bubbleGradients) { this.highlightAlpha = .35 } } this.autoscaleMultiplier = this.autoscaleMultiplier * Math.pow(this.data.length, this.autoscalePointsFactor); this._highlightedPoint = null; var d; for (var e = 0; e < this.data.length; e++) { var l = null; var m = this.data[e]; this.maxRadius = Math.max(this.maxRadius, m[2]); if (m[3]) { if (typeof m[3] == "object") { l = m[3]["color"] } } if (l == null) { if (this.seriesColors[e] != null) { l = this.seriesColors[e] } } if (l && this.bubbleAlpha < 1) { d = a.jqplot.getColorComponents(l); l = "rgba(" + d[0] + ", " + d[1] + ", " + d[2] + ", " + this.bubbleAlpha + ")" } if (l) { this.seriesColors[e] = l } } if (!this.varyBubbleColors) { this.seriesColors = [this.color] } this.colorGenerator = new a.jqplot.ColorGenerator(this.seriesColors); if (this.highlightColors.length == 0) { for (var e = 0; e < this.seriesColors.length; e++) { var n = a.jqplot.getColorComponents(this.seriesColors[e]); var o = [n[0], n[1], n[2]]; var p = o[0] + o[1] + o[2]; for (var q = 0; q < 3; q++) { o[q] = p > 570 ? o[q] * .8 : o[q] + .3 * (255 - o[q]); o[q] = parseInt(o[q], 10) } this.highlightColors.push("rgba(" + o[0] + "," + o[1] + "," + o[2] + ", " + this.highlightAlpha + ")") } } this.highlightColorGenerator = new a.jqplot.ColorGenerator(this.highlightColors); var r = { fill: true, isarc: true, angle: this.shadowAngle, alpha: this.shadowAlpha, closePath: true }; this.renderer.shadowRenderer.init(r); this.canvas = new a.jqplot.DivCanvas; this.canvas._plotDimensions = this._plotDimensions; c.eventListenerHooks.addOnce("jqplotMouseMove", f); c.eventListenerHooks.addOnce("jqplotMouseDown", g); c.eventListenerHooks.addOnce("jqplotMouseUp", h); c.eventListenerHooks.addOnce("jqplotClick", i); c.eventListenerHooks.addOnce("jqplotRightClick", j); c.postDrawHooks.addOnce(k) }; a.jqplot.BubbleRenderer.prototype.setGridData = function (a) { var c = this._xaxis.series_u2p; var d = this._yaxis.series_u2p; var e = this._plotData; this.gridData = []; var f = []; this.radii = []; var g = Math.min(a._height, a._width); for (var h = 0; h < this.data.length; h++) { if (e[h] != null) { this.gridData.push([c.call(this._xaxis, e[h][0]), d.call(this._yaxis, e[h][1]), e[h][2]]); this.radii.push([h, e[h][2]]); f.push(e[h][2]) } } var i, j, k = this.maxRadius = b(f); var l = this.gridData.length; if (this.autoscaleBubbles) { for (var h = 0; h < l; h++) { j = f[h] / k; i = this.autoscaleMultiplier * g / 6; this.gridData[h][2] = i * j } } this.radii.sort(function (a, b) { return b[1] - a[1] }) }; a.jqplot.BubbleRenderer.prototype.makeGridData = function (a, c) { var d = this._xaxis.series_u2p; var e = this._yaxis.series_u2p; var f = []; var g = []; this.radii = []; var h = Math.min(c._height, c._width); for (var i = 0; i < a.length; i++) { if (a[i] != null) { f.push([d.call(this._xaxis, a[i][0]), e.call(this._yaxis, a[i][1]), a[i][2]]); g.push(a[i][2]); this.radii.push([i, a[i][2]]) } } var j, k, l = this.maxRadius = b(g); var m = this.gridData.length; if (this.autoscaleBubbles) { for (var i = 0; i < m; i++) { k = g[i] / l; j = this.autoscaleMultiplier * h / 6; f[i][2] = j * k } } this.radii.sort(function (a, b) { return b[1] - a[1] }); return f }; a.jqplot.BubbleRenderer.prototype.draw = function (b, c, d) { if (this.plugins.pointLabels) { this.plugins.pointLabels.show = false } var e = d != undefined ? d : {}; var f = e.shadow != undefined ? e.shadow : this.shadow; this.canvas._elem.empty(); for (var g = 0; g < this.radii.length; g++) { var h = this.radii[g][0]; var i = null; var j = null; var k = null; var l = null; var m = this.data[h]; var c = this.gridData[h]; if (m[3]) { if (typeof m[3] == "object") { i = m[3]["label"] } else if (typeof m[3] == "string") { i = m[3] } } j = this.colorGenerator.get(h); var n = c[2]; var o, p; if (this.shadow) { o = (.7 + c[2] / 40).toFixed(1); p = 1 + Math.ceil(c[2] / 15); n += o * p } this.bubbleCanvases[h] = new a.jqplot.BubbleCanvas; this.canvas._elem.append(this.bubbleCanvases[h].createElement(c[0], c[1], n)); this.bubbleCanvases[h].setContext(); var b = this.bubbleCanvases[h]._ctx; var q = b.canvas.width / 2; var r = b.canvas.height / 2; if (this.shadow) { this.renderer.shadowRenderer.draw(b, [q, r, c[2], 0, 2 * Math.PI], { offset: o, depth: p }) } this.bubbleCanvases[h].draw(c[2], j, this.bubbleGradients, this.shadowAngle / 180 * Math.PI); if (i && this.showLabels) { l = a('<div style="position:absolute;" class="jqplot-bubble-label"></div>'); if (this.escapeHtml) { l.text(i) } else { l.html(i) } this.canvas._elem.append(l); var s = a(l).outerHeight(); var t = a(l).outerWidth(); var u = c[1] - .5 * s; var v = c[0] - .5 * t; l.css({ top: u, left: v }); this.labels[h] = a(l) } } }; a.jqplot.DivCanvas = function () { a.jqplot.ElemContainer.call(this); this._ctx }; a.jqplot.DivCanvas.prototype = new a.jqplot.ElemContainer; a.jqplot.DivCanvas.prototype.constructor = a.jqplot.DivCanvas; a.jqplot.DivCanvas.prototype.createElement = function (b, c, d) { this._offsets = b; var e = "jqplot-DivCanvas"; if (c != undefined) { e = c } var f; if (this._elem) { f = this._elem.get(0) } else { f = document.createElement("div") } if (d != undefined) { this._plotDimensions = d } var g = this._plotDimensions.width - this._offsets.left - this._offsets.right + "px"; var h = this._plotDimensions.height - this._offsets.top - this._offsets.bottom + "px"; this._elem = a(f); this._elem.css({ position: "absolute", width: g, height: h, left: this._offsets.left, top: this._offsets.top }); this._elem.addClass(e); return this._elem }; a.jqplot.DivCanvas.prototype.setContext = function () { this._ctx = { canvas: { width: 0, height: 0 }, clearRect: function () { return null } }; return this._ctx }; a.jqplot.BubbleCanvas = function () { a.jqplot.ElemContainer.call(this); this._ctx }; a.jqplot.BubbleCanvas.prototype = new a.jqplot.ElemContainer; a.jqplot.BubbleCanvas.prototype.constructor = a.jqplot.BubbleCanvas; a.jqplot.BubbleCanvas.prototype.createElement = function (b, c, d) { var e = "jqplot-bubble-point"; var f; if (this._elem) { f = this._elem.get(0) } else { f = document.createElement("canvas") } f.width = d != null ? 2 * d : f.width; f.height = d != null ? 2 * d : f.height; this._elem = a(f); var g = b != null && d != null ? b - d : this._elem.css("left"); var h = c != null && d != null ? c - d : this._elem.css("top"); this._elem.css({ position: "absolute", left: g, top: h }); this._elem.addClass(e); if (a.jqplot.use_excanvas) { window.G_vmlCanvasManager.init_(document); f = window.G_vmlCanvasManager.initElement(f) } return this._elem }; a.jqplot.BubbleCanvas.prototype.draw = function (b, c, d, e) { var f = this._ctx; var g = f.canvas.width / 2; var h = f.canvas.height / 2; f.save(); if (d && !a.jqplot.use_excanvas) { b = b * 1.04; var i = a.jqplot.getColorComponents(c); var j = "rgba(" + Math.round(i[0] + .8 * (255 - i[0])) + ", " + Math.round(i[1] + .8 * (255 - i[1])) + ", " + Math.round(i[2] + .8 * (255 - i[2])) + ", " + i[3] + ")"; var k = "rgba(" + i[0] + ", " + i[1] + ", " + i[2] + ", 0)"; var l = .35 * b; var m = g - Math.cos(e) * .33 * b; var n = h - Math.sin(e) * .33 * b; var o = f.createRadialGradient(m, n, l, g, h, b); o.addColorStop(0, j); o.addColorStop(.93, c); o.addColorStop(.96, k); o.addColorStop(1, k); f.fillStyle = o; f.fillRect(0, 0, f.canvas.width, f.canvas.height) } else { f.fillStyle = c; f.strokeStyle = c; f.lineWidth = 1; f.beginPath(); var p = 2 * Math.PI; f.arc(g, h, b, 0, p, 0); f.closePath(); f.fill() } f.restore() }; a.jqplot.BubbleCanvas.prototype.setContext = function () { this._ctx = this._elem.get(0).getContext("2d"); return this._ctx }; a.jqplot.BubbleAxisRenderer = function () { a.jqplot.LinearAxisRenderer.call(this) }; a.jqplot.BubbleAxisRenderer.prototype = new a.jqplot.LinearAxisRenderer; a.jqplot.BubbleAxisRenderer.prototype.constructor = a.jqplot.BubbleAxisRenderer; a.jqplot.BubbleAxisRenderer.prototype.init = function (b) { a.extend(true, this, b); var c = this._dataBounds; var d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0; for (var n = 0; n < this._series.length; n++) { var o = this._series[n]; var p = o._plotData; for (var q = 0; q < p.length; q++) { if (this.name == "xaxis" || this.name == "x2axis") { if (p[q][0] < c.min || c.min == null) { c.min = p[q][0]; d = n; e = q; i = p[q][2]; j = o.maxRadius; m = o.autoscaleMultiplier } if (p[q][0] > c.max || c.max == null) { c.max = p[q][0]; f = n; g = q; h = p[q][2]; k = o.maxRadius; l = o.autoscaleMultiplier } } else { if (p[q][1] < c.min || c.min == null) { c.min = p[q][1]; d = n; e = q; i = p[q][2]; j = o.maxRadius; m = o.autoscaleMultiplier } if (p[q][1] > c.max || c.max == null) { c.max = p[q][1]; f = n; g = q; h = p[q][2]; k = o.maxRadius; l = o.autoscaleMultiplier } } } } var r = i / j; var s = h / k; var t = c.max - c.min; var u = Math.min(this._plotDimensions.width, this._plotDimensions.height); var v = r * m / 3 * t; var w = s * l / 3 * t; c.max += w; c.min -= v }; a.jqplot.preInitHooks.push(l) })(jQuery); (function (a) { a.jqplot.CanvasAxisLabelRenderer = function (b) { this.angle = 0; this.axis; this.show = true; this.showLabel = true; this.label = ""; this.fontFamily = '"Trebuchet MS", Arial, Helvetica, sans-serif'; this.fontSize = "11pt"; this.fontWeight = "normal"; this.fontStretch = 1; this.textColor = "#666666"; this.enableFontSupport = true; this.pt2px = null; this._elem; this._ctx; this._plotWidth; this._plotHeight; this._plotDimensions = { height: null, width: null }; a.extend(true, this, b); if (b.angle == null && this.axis != "xaxis" && this.axis != "x2axis") { this.angle = -90 } var c = { fontSize: this.fontSize, fontWeight: this.fontWeight, fontStretch: this.fontStretch, fillStyle: this.textColor, angle: this.getAngleRad(), fontFamily: this.fontFamily }; if (this.pt2px) { c.pt2px = this.pt2px } if (this.enableFontSupport) { if (a.jqplot.support_canvas_text()) { this._textRenderer = new a.jqplot.CanvasFontRenderer(c) } else { this._textRenderer = new a.jqplot.CanvasTextRenderer(c) } } else { this._textRenderer = new a.jqplot.CanvasTextRenderer(c) } }; a.jqplot.CanvasAxisLabelRenderer.prototype.init = function (b) { a.extend(true, this, b); this._textRenderer.init({ fontSize: this.fontSize, fontWeight: this.fontWeight, fontStretch: this.fontStretch, fillStyle: this.textColor, angle: this.getAngleRad(), fontFamily: this.fontFamily }) }; a.jqplot.CanvasAxisLabelRenderer.prototype.getWidth = function (a) { if (this._elem) { return this._elem.outerWidth(true) } else { var b = this._textRenderer; var c = b.getWidth(a); var d = b.getHeight(a); var e = Math.abs(Math.sin(b.angle) * d) + Math.abs(Math.cos(b.angle) * c); return e } }; a.jqplot.CanvasAxisLabelRenderer.prototype.getHeight = function (a) { if (this._elem) { return this._elem.outerHeight(true) } else { var b = this._textRenderer; var c = b.getWidth(a); var d = b.getHeight(a); var e = Math.abs(Math.cos(b.angle) * d) + Math.abs(Math.sin(b.angle) * c); return e } }; a.jqplot.CanvasAxisLabelRenderer.prototype.getAngleRad = function () { var a = this.angle * Math.PI / 180; return a }; a.jqplot.CanvasAxisLabelRenderer.prototype.draw = function (b, c) { if (this._elem) { if (a.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) { window.G_vmlCanvasManager.uninitElement(this._elem.get(0)) } this._elem.emptyForce(); this._elem = null } var d = c.canvasManager.getCanvas(); this._textRenderer.setText(this.label, b); var e = this.getWidth(b); var f = this.getHeight(b); d.width = e; d.height = f; d.style.width = e; d.style.height = f; d = c.canvasManager.initCanvas(d); this._elem = a(d); this._elem.css({ position: "absolute" }); this._elem.addClass("jqplot-" + this.axis + "-label"); d = null; return this._elem }; a.jqplot.CanvasAxisLabelRenderer.prototype.pack = function () { this._textRenderer.draw(this._elem.get(0).getContext("2d"), this.label) } })(jQuery); (function (a) { a.jqplot.CanvasAxisTickRenderer = function (b) { this.mark = "outside"; this.showMark = true; this.showGridline = true; this.isMinorTick = false; this.angle = 0; this.markSize = 4; this.show = true; this.showLabel = true; this.labelPosition = "auto"; this.label = ""; this.value = null; this._styles = {}; this.formatter = a.jqplot.DefaultTickFormatter; this.formatString = ""; this.prefix = ""; this.fontFamily = '"Trebuchet MS", Arial, Helvetica, sans-serif'; this.fontSize = "10pt"; this.fontWeight = "normal"; this.fontStretch = 1; this.textColor = "#666666"; this.enableFontSupport = true; this.pt2px = null; this._elem; this._ctx; this._plotWidth; this._plotHeight; this._plotDimensions = { height: null, width: null }; a.extend(true, this, b); var c = { fontSize: this.fontSize, fontWeight: this.fontWeight, fontStretch: this.fontStretch, fillStyle: this.textColor, angle: this.getAngleRad(), fontFamily: this.fontFamily }; if (this.pt2px) { c.pt2px = this.pt2px } if (this.enableFontSupport) { if (a.jqplot.support_canvas_text()) { this._textRenderer = new a.jqplot.CanvasFontRenderer(c) } else { this._textRenderer = new a.jqplot.CanvasTextRenderer(c) } } else { this._textRenderer = new a.jqplot.CanvasTextRenderer(c) } }; a.jqplot.CanvasAxisTickRenderer.prototype.init = function (b) { a.extend(true, this, b); this._textRenderer.init({ fontSize: this.fontSize, fontWeight: this.fontWeight, fontStretch: this.fontStretch, fillStyle: this.textColor, angle: this.getAngleRad(), fontFamily: this.fontFamily }) }; a.jqplot.CanvasAxisTickRenderer.prototype.getWidth = function (a) { if (this._elem) { return this._elem.outerWidth(true) } else { var b = this._textRenderer; var c = b.getWidth(a); var d = b.getHeight(a); var e = Math.abs(Math.sin(b.angle) * d) + Math.abs(Math.cos(b.angle) * c); return e } }; a.jqplot.CanvasAxisTickRenderer.prototype.getHeight = function (a) { if (this._elem) { return this._elem.outerHeight(true) } else { var b = this._textRenderer; var c = b.getWidth(a); var d = b.getHeight(a); var e = Math.abs(Math.cos(b.angle) * d) + Math.abs(Math.sin(b.angle) * c); return e } }; a.jqplot.CanvasAxisTickRenderer.prototype.getAngleRad = function () { var a = this.angle * Math.PI / 180; return a }; a.jqplot.CanvasAxisTickRenderer.prototype.setTick = function (a, b, c) { this.value = a; if (c) { this.isMinorTick = true } return this }; a.jqplot.CanvasAxisTickRenderer.prototype.draw = function (b, c) { if (!this.label) { this.label = this.prefix + this.formatter(this.formatString, this.value) } if (this._elem) { if (a.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement !== undefined) { window.G_vmlCanvasManager.uninitElement(this._elem.get(0)) } this._elem.emptyForce(); this._elem = null } var d = c.canvasManager.getCanvas(); this._textRenderer.setText(this.label, b); var e = this.getWidth(b); var f = this.getHeight(b); d.width = e; d.height = f; d.style.width = e; d.style.height = f; d.style.textAlign = "left"; d.style.position = "absolute"; d = c.canvasManager.initCanvas(d); this._elem = a(d); this._elem.css(this._styles); this._elem.addClass("jqplot-" + this.axis + "-tick"); d = null; return this._elem }; a.jqplot.CanvasAxisTickRenderer.prototype.pack = function () { this._textRenderer.draw(this._elem.get(0).getContext("2d"), this.label) } })(jQuery); (function (a) { function k(a, b, c, d, e) { var f = e.plugins.canvasOverlay; var g = f.objects; var h = g.length; var k, l = false; var m; for (var n = 0; n < h; n++) { k = g[n]; if (k.options.showTooltip) { var o = j([b.x, b.y], k.gridStart, k.gridStop, k.tooltipWidthFactor); c = [e.axes[k.options.xaxis].series_p2u(b.x), e.axes[k.options.yaxis].series_p2u(b.y)]; if (o && f.highlightObjectIndex == null) { switch (k.type) { case "line": i(e, k, [b.x, b.y], c); break; case "horizontalLine": case "dashedHorizontalLine": i(e, k, [b.x, k.gridStart[1]], [c[0], k.options.y]); break; case "verticalLine": case "dashedVerticalLine": i(e, k, [k.gridStart[0], b.y], [k.options.x, c[1]]); break; default: break } f.highlightObjectIndex = n; l = true; break } else if (o && f.highlightObjectIndex !== n) { m = f._tooltipElem; if (k.fadeTooltip) { m.fadeOut(k.tooltipFadeSpeed) } else { m.hide() } switch (k.type) { case "line": i(e, k, [b.x, b.y], c); break; case "horizontalLine": case "dashedHorizontalLine": i(e, k, [b.x, k.gridStart[1]], [c[0], k.options.y]); break; case "verticalLine": case "dashedVerticalLine": i(e, k, [k.gridStart[0], b.y], [k.options.x, c[1]]); break; default: break } f.highlightObjectIndex = n; l = true; break } else if (o) { switch (k.type) { case "line": i(e, k, [b.x, b.y], c); break; case "horizontalLine": case "dashedHorizontalLine": i(e, k, [b.x, k.gridStart[1]], [c[0], k.options.y]); break; case "verticalLine": case "dashedVerticalLine": i(e, k, [k.gridStart[0], b.y], [k.options.x, c[1]]); break; default: break } l = true; break } } } if (!l && f.highlightObjectIndex !== null) { m = f._tooltipElem; k = f.getObject(f.highlightObjectIndex); if (k.fadeTooltip) { m.fadeOut(k.tooltipFadeSpeed) } else { m.hide() } f.highlightObjectIndex = null } } function j(a, b, c, d) { var e = a[0]; var f = a[1]; var g = Math.round(c[0]); var h = Math.round(c[1]); var i = Math.round(b[0]); var j = Math.round(b[1]); var k = Math.sqrt(Math.pow(g - i, 2) + Math.pow(h - j, 2)); var l = d * k; var m = Math.abs((i - g) * (f - h) - (j - h) * (e - g)); var n = m < l ? true : false; return n } function i(b, c, d, e) { var f = b.plugins.canvasOverlay; var g = f._tooltipElem; var h = c.options, i, j; g.html(a.jqplot.sprintf(h.tooltipFormatString, e[0], e[1])); switch (h.tooltipLocation) { case "nw": i = d[0] + b._gridPadding.left - g.outerWidth(true) - h.tooltipOffset; j = d[1] + b._gridPadding.top - h.tooltipOffset - g.outerHeight(true); break; case "n": i = d[0] + b._gridPadding.left - g.outerWidth(true) / 2; j = d[1] + b._gridPadding.top - h.tooltipOffset - g.outerHeight(true); break; case "ne": i = d[0] + b._gridPadding.left + h.tooltipOffset; j = d[1] + b._gridPadding.top - h.tooltipOffset - g.outerHeight(true); break; case "e": i = d[0] + b._gridPadding.left + h.tooltipOffset; j = d[1] + b._gridPadding.top - g.outerHeight(true) / 2; break; case "se": i = d[0] + b._gridPadding.left + h.tooltipOffset; j = d[1] + b._gridPadding.top + h.tooltipOffset; break; case "s": i = d[0] + b._gridPadding.left - g.outerWidth(true) / 2; j = d[1] + b._gridPadding.top + h.tooltipOffset; break; case "sw": i = d[0] + b._gridPadding.left - g.outerWidth(true) - h.tooltipOffset; j = d[1] + b._gridPadding.top + h.tooltipOffset; break; case "w": i = d[0] + b._gridPadding.left - g.outerWidth(true) - h.tooltipOffset; j = d[1] + b._gridPadding.top - g.outerHeight(true) / 2; break; default: i = d[0] + b._gridPadding.left - g.outerWidth(true) - h.tooltipOffset; j = d[1] + b._gridPadding.top - h.tooltipOffset - g.outerHeight(true); break } g.css("left", i); g.css("top", j); if (h.fadeTooltip) { g.stop(true, true).fadeIn(h.tooltipFadeSpeed) } else { g.show() } g = null } function h(b) { c.call(this); this.type = "dashedVerticalLine"; this.start = null; this.stop = null; var d = { x: null, ymin: null, ymax: null, yOffset: "6px", yminOffset: null, ymaxOffset: null, dashPattern: [8, 8] }; a.extend(true, this.options, d, b); if (this.options.showTooltipPrecision < .01) { this.options.showTooltipPrecision = .01 } } function g(b) { c.call(this); this.type = "verticalLine"; var d = { x: null, ymin: null, ymax: null, yOffset: "6px", yminOffset: null, ymaxOffset: null }; a.extend(true, this.options, d, b); if (this.options.showTooltipPrecision < .01) { this.options.showTooltipPrecision = .01 } } function f(b) { c.call(this); this.type = "dashedHorizontalLine"; var d = { y: null, xmin: null, xmax: null, xOffset: "6px", xminOffset: null, xmaxOffset: null, dashPattern: [8, 8] }; a.extend(true, this.options, d, b); if (this.options.showTooltipPrecision < .01) { this.options.showTooltipPrecision = .01 } } function e(b) { c.call(this); this.type = "horizontalLine"; var d = { y: null, xmin: null, xmax: null, xOffset: "6px", xminOffset: null, xmaxOffset: null }; a.extend(true, this.options, d, b); if (this.options.showTooltipPrecision < .01) { this.options.showTooltipPrecision = .01 } } function d(b) { c.call(this); this.type = "line"; var d = { start: [], stop: [] }; a.extend(true, this.options, d, b); if (this.options.showTooltipPrecision < .01) { this.options.showTooltipPrecision = .01 } } function c() { this.uid = null; this.type = null; this.gridStart = null; this.gridStop = null; this.tooltipWidthFactor = 0; this.options = { name: null, show: true, lineWidth: 2, lineCap: "round", color: "#666666", shadow: true, shadowAngle: 45, shadowOffset: 1, shadowDepth: 3, shadowAlpha: "0.07", xaxis: "xaxis", yaxis: "yaxis", showTooltip: false, showTooltipPrecision: .6, tooltipLocation: "nw", fadeTooltip: true, tooltipFadeSpeed: "fast", tooltipOffset: 4, tooltipFormatString: "%d, %d"} } var b = 0; a.jqplot.CanvasOverlay = function (b) { var c = b || {}; this.options = { show: a.jqplot.config.enablePlugins, deferDraw: false }; this.objects = []; this.objectNames = []; this.canvas = null; this.markerRenderer = new a.jqplot.MarkerRenderer({ style: "line" }); this.markerRenderer.init(); this.highlightObjectIndex = null; if (c.objects) { var d = c.objects, e; for (var f = 0; f < d.length; f++) { e = d[f]; for (var g in e) { switch (g) { case "line": this.addLine(e[g]); break; case "horizontalLine": this.addHorizontalLine(e[g]); break; case "dashedHorizontalLine": this.addDashedHorizontalLine(e[g]); break; case "verticalLine": this.addVerticalLine(e[g]); break; case "dashedVerticalLine": this.addDashedVerticalLine(e[g]); break; default: break } } } } a.extend(true, this.options, c) }; a.jqplot.CanvasOverlay.postPlotInit = function (b, c, d) { var e = d || {}; this.plugins.canvasOverlay = new a.jqplot.CanvasOverlay(e.canvasOverlay) }; d.prototype = new c; d.prototype.constructor = d; e.prototype = new c; e.prototype.constructor = e; f.prototype = new c; f.prototype.constructor = f; g.prototype = new c; g.prototype.constructor = g; h.prototype = new c; h.prototype.constructor = h; a.jqplot.CanvasOverlay.prototype.addLine = function (a) { var c = new d(a); c.uid = b++; this.objects.push(c); this.objectNames.push(c.options.name) }; a.jqplot.CanvasOverlay.prototype.addHorizontalLine = function (a) { var c = new e(a); c.uid = b++; this.objects.push(c); this.objectNames.push(c.options.name) }; a.jqplot.CanvasOverlay.prototype.addDashedHorizontalLine = function (a) { var c = new f(a); c.uid = b++; this.objects.push(c); this.objectNames.push(c.options.name) }; a.jqplot.CanvasOverlay.prototype.addVerticalLine = function (a) { var c = new g(a); c.uid = b++; this.objects.push(c); this.objectNames.push(c.options.name) }; a.jqplot.CanvasOverlay.prototype.addDashedVerticalLine = function (a) { var c = new h(a); c.uid = b++; this.objects.push(c); this.objectNames.push(c.options.name) }; a.jqplot.CanvasOverlay.prototype.removeObject = function (b) { if (a.type(b) == "number") { this.objects.splice(b, 1); this.objectNames.splice(b, 1) } else { var c = a.inArray(b, this.objectNames); if (c != -1) { this.objects.splice(c, 1); this.objectNames.splice(c, 1) } } }; a.jqplot.CanvasOverlay.prototype.getObject = function (b) { if (a.type(b) == "number") { return this.objects[b] } else { var c = a.inArray(b, this.objectNames); if (c != -1) { return this.objects[c] } } }; a.jqplot.CanvasOverlay.prototype.get = a.jqplot.CanvasOverlay.prototype.getObject; a.jqplot.CanvasOverlay.prototype.clear = function (a) { this.canvas._ctx.clearRect(0, 0, this.canvas.getWidth(), this.canvas.getHeight()) }; a.jqplot.CanvasOverlay.prototype.draw = function (b) { var c, d = this.objects, e = this.markerRenderer, f, g; if (this.options.show) { this.canvas._ctx.clearRect(0, 0, this.canvas.getWidth(), this.canvas.getHeight()); for (var h = 0; h < d.length; h++) { c = d[h]; var i = a.extend(true, {}, c.options); if (c.options.show) { e.shadow = c.options.shadow; c.tooltipWidthFactor = c.options.lineWidth / c.options.showTooltipPrecision; switch (c.type) { case "line": e.style = "line"; i.closePath = false; f = [b.axes[c.options.xaxis].series_u2p(c.options.start[0]), b.axes[c.options.yaxis].series_u2p(c.options.start[1])]; g = [b.axes[c.options.xaxis].series_u2p(c.options.stop[0]), b.axes[c.options.yaxis].series_u2p(c.options.stop[1])]; c.gridStart = f; c.gridStop = g; e.draw(f, g, this.canvas._ctx, i); break; case "horizontalLine": if (c.options.y != null) { e.style = "line"; i.closePath = false; var j = b.axes[c.options.xaxis], k, l, m = b.axes[c.options.yaxis].series_u2p(c.options.y), n = c.options.xminOffset || c.options.xOffset, o = c.options.xmaxOffset || c.options.xOffset; if (c.options.xmin != null) { k = j.series_u2p(c.options.xmin) } else if (n != null) { if (a.type(n) == "number") { k = j.series_u2p(j.min + n) } else if (a.type(n) == "string") { k = j.series_u2p(j.min) + parseFloat(n) } } if (c.options.xmax != null) { l = j.series_u2p(c.options.xmax) } else if (o != null) { if (a.type(o) == "number") { l = j.series_u2p(j.max - o) } else if (a.type(o) == "string") { l = j.series_u2p(j.max) - parseFloat(o) } } if (l != null && k != null) { c.gridStart = [k, m]; c.gridStop = [l, m]; e.draw([k, m], [l, m], this.canvas._ctx, i) } } break; case "dashedHorizontalLine": var p = c.options.dashPattern; var q = 0; for (var r = 0; r < p.length; r++) { q += p[r] } if (c.options.y != null) { e.style = "line"; i.closePath = false; var j = b.axes[c.options.xaxis], k, l, m = b.axes[c.options.yaxis].series_u2p(c.options.y), n = c.options.xminOffset || c.options.xOffset, o = c.options.xmaxOffset || c.options.xOffset; if (c.options.xmin != null) { k = j.series_u2p(c.options.xmin) } else if (n != null) { if (a.type(n) == "number") { k = j.series_u2p(j.min + n) } else if (a.type(n) == "string") { k = j.series_u2p(j.min) + parseFloat(n) } } if (c.options.xmax != null) { l = j.series_u2p(c.options.xmax) } else if (o != null) { if (a.type(o) == "number") { l = j.series_u2p(j.max - o) } else if (a.type(o) == "string") { l = j.series_u2p(j.max) - parseFloat(o) } } if (l != null && k != null) { c.gridStart = [k, m]; c.gridStop = [l, m]; var s = Math.ceil((l - k) / q); var t = k, u; for (var r = 0; r < s; r++) { for (var v = 0; v < p.length; v += 2) { u = t + p[v]; e.draw([t, m], [u, m], this.canvas._ctx, i); t += p[v]; if (v < p.length - 1) { t += p[v + 1] } } } } } break; case "verticalLine": if (c.options.x != null) { e.style = "line"; i.closePath = false; var w = b.axes[c.options.yaxis], x, y, z = b.axes[c.options.xaxis].series_u2p(c.options.x), A = c.options.yminOffset || c.options.yOffset, B = c.options.ymaxOffset || c.options.yOffset; if (c.options.ymin != null) { x = w.series_u2p(c.options.ymin) } else if (A != null) { if (a.type(A) == "number") { x = w.series_u2p(w.min - A) } else if (a.type(A) == "string") { x = w.series_u2p(w.min) - parseFloat(A) } } if (c.options.ymax != null) { y = w.series_u2p(c.options.ymax) } else if (B != null) { if (a.type(B) == "number") { y = w.series_u2p(w.max + B) } else if (a.type(B) == "string") { y = w.series_u2p(w.max) + parseFloat(B) } } if (y != null && x != null) { c.gridStart = [z, x]; c.gridStop = [z, y]; e.draw([z, x], [z, y], this.canvas._ctx, i) } } break; case "dashedVerticalLine": var p = c.options.dashPattern; var q = 0; for (var r = 0; r < p.length; r++) { q += p[r] } if (c.options.x != null) { e.style = "line"; i.closePath = false; var w = b.axes[c.options.yaxis], x, y, z = b.axes[c.options.xaxis].series_u2p(c.options.x), A = c.options.yminOffset || c.options.yOffset, B = c.options.ymaxOffset || c.options.yOffset; if (c.options.ymin != null) { x = w.series_u2p(c.options.ymin) } else if (A != null) { if (a.type(A) == "number") { x = w.series_u2p(w.min - A) } else if (a.type(A) == "string") { x = w.series_u2p(w.min) - parseFloat(A) } } if (c.options.ymax != null) { y = w.series_u2p(c.options.ymax) } else if (B != null) { if (a.type(B) == "number") { y = w.series_u2p(w.max + B) } else if (a.type(B) == "string") { y = w.series_u2p(w.max) + parseFloat(B) } } if (y != null && x != null) { c.gridStart = [z, x]; c.gridStop = [z, y]; var s = Math.ceil((x - y) / q); var C = (s * q - (x - y)) / 2; var t = x, u, D, E; for (var r = 0; r < s; r++) { for (var v = 0; v < p.length; v += 2) { u = t - p[v]; if (u < y) { u = y } if (t < y) { t = y } e.draw([z, t], [z, u], this.canvas._ctx, i); t -= p[v]; if (v < p.length - 1) { t -= p[v + 1] } } } } } break; default: break } } } } }; a.jqplot.CanvasOverlay.postPlotDraw = function () { var b = this.plugins.canvasOverlay; if (b && b.highlightCanvas) { b.highlightCanvas.resetCanvas(); b.highlightCanvas = null } b.canvas = new a.jqplot.GenericCanvas; this.eventCanvas._elem.before(b.canvas.createElement(this._gridPadding, "jqplot-overlayCanvas-canvas", this._plotDimensions, this)); b.canvas.setContext(); if (!b.deferDraw) { b.draw(this) } var c = document.createElement("div"); b._tooltipElem = a(c); c = null; b._tooltipElem.addClass("jqplot-canvasOverlay-tooltip"); b._tooltipElem.css({ position: "absolute", display: "none" }); this.eventCanvas._elem.before(b._tooltipElem); this.eventCanvas._elem.bind("mouseleave", { elem: b._tooltipElem }, function (a) { a.data.elem.hide() }); var b = null }; a.jqplot.postInitHooks.push(a.jqplot.CanvasOverlay.postPlotInit); a.jqplot.postDrawHooks.push(a.jqplot.CanvasOverlay.postPlotDraw); a.jqplot.eventListenerHooks.push(["jqplotMouseMove", k]) })(jQuery); (function (a) { a.jqplot.CanvasTextRenderer = function (b) { this.fontStyle = "normal"; this.fontVariant = "normal"; this.fontWeight = "normal"; this.fontSize = "10px"; this.fontFamily = "sans-serif"; this.fontStretch = 1; this.fillStyle = "#666666"; this.angle = 0; this.textAlign = "start"; this.textBaseline = "alphabetic"; this.text; this.width; this.height; this.pt2px = 1.28; a.extend(true, this, b); this.normalizedFontSize = this.normalizeFontSize(this.fontSize); this.setHeight() }; a.jqplot.CanvasTextRenderer.prototype.init = function (b) { a.extend(true, this, b); this.normalizedFontSize = this.normalizeFontSize(this.fontSize); this.setHeight() }; a.jqplot.CanvasTextRenderer.prototype.normalizeFontSize = function (a) { a = String(a); var b = parseFloat(a); if (a.indexOf("px") > -1) { return b / this.pt2px } else if (a.indexOf("pt") > -1) { return b } else if (a.indexOf("em") > -1) { return b * 12 } else if (a.indexOf("%") > -1) { return b * 12 / 100 } else { return b / this.pt2px } }; a.jqplot.CanvasTextRenderer.prototype.fontWeight2Float = function (a) { if (Number(a)) { return a / 400 } else { switch (a) { case "normal": return 1; break; case "bold": return 1.75; break; case "bolder": return 2.25; break; case "lighter": return .75; break; default: return 1; break } } }; a.jqplot.CanvasTextRenderer.prototype.getText = function () { return this.text }; a.jqplot.CanvasTextRenderer.prototype.setText = function (a, b) { this.text = a; this.setWidth(b); return this }; a.jqplot.CanvasTextRenderer.prototype.getWidth = function (a) { return this.width }; a.jqplot.CanvasTextRenderer.prototype.setWidth = function (a, b) { if (!b) { this.width = this.measure(a, this.text) } else { this.width = b } return this }; a.jqplot.CanvasTextRenderer.prototype.getHeight = function (a) { return this.height }; a.jqplot.CanvasTextRenderer.prototype.setHeight = function (a) { if (!a) { this.height = this.normalizedFontSize * this.pt2px } else { this.height = a } return this }; a.jqplot.CanvasTextRenderer.prototype.letter = function (a) { return this.letters[a] }; a.jqplot.CanvasTextRenderer.prototype.ascent = function () { return this.normalizedFontSize }; a.jqplot.CanvasTextRenderer.prototype.descent = function () { return 7 * this.normalizedFontSize / 25 }; a.jqplot.CanvasTextRenderer.prototype.measure = function (a, b) { var c = 0; var d = b.length; for (var e = 0; e < d; e++) { var f = this.letter(b.charAt(e)); if (f) { c += f.width * this.normalizedFontSize / 25 * this.fontStretch } } return c }; a.jqplot.CanvasTextRenderer.prototype.draw = function (a, b) { var c = 0; var d = this.height * .72; var e = 0; var f = b.length; var g = this.normalizedFontSize / 25; a.save(); var h, i; if (-Math.PI / 2 <= this.angle && this.angle <= 0 || Math.PI * 3 / 2 <= this.angle && this.angle <= Math.PI * 2) { h = 0; i = -Math.sin(this.angle) * this.width } else if (0 < this.angle && this.angle <= Math.PI / 2 || -Math.PI * 2 <= this.angle && this.angle <= -Math.PI * 3 / 2) { h = Math.sin(this.angle) * this.height; i = 0 } else if (-Math.PI < this.angle && this.angle < -Math.PI / 2 || Math.PI <= this.angle && this.angle <= Math.PI * 3 / 2) { h = -Math.cos(this.angle) * this.width; i = -Math.sin(this.angle) * this.width - Math.cos(this.angle) * this.height } else if (-Math.PI * 3 / 2 < this.angle && this.angle < Math.PI || Math.PI / 2 < this.angle && this.angle < Math.PI) { h = Math.sin(this.angle) * this.height - Math.cos(this.angle) * this.width; i = -Math.cos(this.angle) * this.height } a.strokeStyle = this.fillStyle; a.fillStyle = this.fillStyle; a.translate(h, i); a.rotate(this.angle); a.lineCap = "round"; var j = this.normalizedFontSize > 30 ? 2 : 2 + (30 - this.normalizedFontSize) / 20; a.lineWidth = j * g * this.fontWeight2Float(this.fontWeight); for (var k = 0; k < f; k++) { var l = this.letter(b.charAt(k)); if (!l) { continue } a.beginPath(); var m = 1; var n = 0; for (var o = 0; o < l.points.length; o++) { var p = l.points[o]; if (p[0] == -1 && p[1] == -1) { m = 1; continue } if (m) { a.moveTo(c + p[0] * g * this.fontStretch, d - p[1] * g); m = false } else { a.lineTo(c + p[0] * g * this.fontStretch, d - p[1] * g) } } a.stroke(); c += l.width * g * this.fontStretch } a.restore(); return e }; a.jqplot.CanvasTextRenderer.prototype.letters = { " ": { width: 16, points: [] }, "!": { width: 10, points: [[5, 21], [5, 7], [-1, -1], [5, 2], [4, 1], [5, 0], [6, 1], [5, 2]] }, '"': { width: 16, points: [[4, 21], [4, 14], [-1, -1], [12, 21], [12, 14]] }, "#": { width: 21, points: [[11, 25], [4, -7], [-1, -1], [17, 25], [10, -7], [-1, -1], [4, 12], [18, 12], [-1, -1], [3, 6], [17, 6]] }, $: { width: 20, points: [[8, 25], [8, -4], [-1, -1], [12, 25], [12, -4], [-1, -1], [17, 18], [15, 20], [12, 21], [8, 21], [5, 20], [3, 18], [3, 16], [4, 14], [5, 13], [7, 12], [13, 10], [15, 9], [16, 8], [17, 6], [17, 3], [15, 1], [12, 0], [8, 0], [5, 1], [3, 3]] }, "%": { width: 24, points: [[21, 21], [3, 0], [-1, -1], [8, 21], [10, 19], [10, 17], [9, 15], [7, 14], [5, 14], [3, 16], [3, 18], [4, 20], [6, 21], [8, 21], [10, 20], [13, 19], [16, 19], [19, 20], [21, 21], [-1, -1], [17, 7], [15, 6], [14, 4], [14, 2], [16, 0], [18, 0], [20, 1], [21, 3], [21, 5], [19, 7], [17, 7]] }, "&": { width: 26, points: [[23, 12], [23, 13], [22, 14], [21, 14], [20, 13], [19, 11], [17, 6], [15, 3], [13, 1], [11, 0], [7, 0], [5, 1], [4, 2], [3, 4], [3, 6], [4, 8], [5, 9], [12, 13], [13, 14], [14, 16], [14, 18], [13, 20], [11, 21], [9, 20], [8, 18], [8, 16], [9, 13], [11, 10], [16, 3], [18, 1], [20, 0], [22, 0], [23, 1], [23, 2]] }, "'": { width: 10, points: [[5, 19], [4, 20], [5, 21], [6, 20], [6, 18], [5, 16], [4, 15]] }, "(": { width: 14, points: [[11, 25], [9, 23], [7, 20], [5, 16], [4, 11], [4, 7], [5, 2], [7, -2], [9, -5], [11, -7]] }, ")": { width: 14, points: [[3, 25], [5, 23], [7, 20], [9, 16], [10, 11], [10, 7], [9, 2], [7, -2], [5, -5], [3, -7]] }, "*": { width: 16, points: [[8, 21], [8, 9], [-1, -1], [3, 18], [13, 12], [-1, -1], [13, 18], [3, 12]] }, "+": { width: 26, points: [[13, 18], [13, 0], [-1, -1], [4, 9], [22, 9]] }, ",": { width: 10, points: [[6, 1], [5, 0], [4, 1], [5, 2], [6, 1], [6, -1], [5, -3], [4, -4]] }, "-": { width: 18, points: [[6, 9], [12, 9]] }, ".": { width: 10, points: [[5, 2], [4, 1], [5, 0], [6, 1], [5, 2]] }, "/": { width: 22, points: [[20, 25], [2, -7]] }, 0: { width: 20, points: [[9, 21], [6, 20], [4, 17], [3, 12], [3, 9], [4, 4], [6, 1], [9, 0], [11, 0], [14, 1], [16, 4], [17, 9], [17, 12], [16, 17], [14, 20], [11, 21], [9, 21]] }, 1: { width: 20, points: [[6, 17], [8, 18], [11, 21], [11, 0]] }, 2: { width: 20, points: [[4, 16], [4, 17], [5, 19], [6, 20], [8, 21], [12, 21], [14, 20], [15, 19], [16, 17], [16, 15], [15, 13], [13, 10], [3, 0], [17, 0]] }, 3: { width: 20, points: [[5, 21], [16, 21], [10, 13], [13, 13], [15, 12], [16, 11], [17, 8], [17, 6], [16, 3], [14, 1], [11, 0], [8, 0], [5, 1], [4, 2], [3, 4]] }, 4: { width: 20, points: [[13, 21], [3, 7], [18, 7], [-1, -1], [13, 21], [13, 0]] }, 5: { width: 20, points: [[15, 21], [5, 21], [4, 12], [5, 13], [8, 14], [11, 14], [14, 13], [16, 11], [17, 8], [17, 6], [16, 3], [14, 1], [11, 0], [8, 0], [5, 1], [4, 2], [3, 4]] }, 6: { width: 20, points: [[16, 18], [15, 20], [12, 21], [10, 21], [7, 20], [5, 17], [4, 12], [4, 7], [5, 3], [7, 1], [10, 0], [11, 0], [14, 1], [16, 3], [17, 6], [17, 7], [16, 10], [14, 12], [11, 13], [10, 13], [7, 12], [5, 10], [4, 7]] }, 7: { width: 20, points: [[17, 21], [7, 0], [-1, -1], [3, 21], [17, 21]] }, 8: { width: 20, points: [[8, 21], [5, 20], [4, 18], [4, 16], [5, 14], [7, 13], [11, 12], [14, 11], [16, 9], [17, 7], [17, 4], [16, 2], [15, 1], [12, 0], [8, 0], [5, 1], [4, 2], [3, 4], [3, 7], [4, 9], [6, 11], [9, 12], [13, 13], [15, 14], [16, 16], [16, 18], [15, 20], [12, 21], [8, 21]] }, 9: { width: 20, points: [[16, 14], [15, 11], [13, 9], [10, 8], [9, 8], [6, 9], [4, 11], [3, 14], [3, 15], [4, 18], [6, 20], [9, 21], [10, 21], [13, 20], [15, 18], [16, 14], [16, 9], [15, 4], [13, 1], [10, 0], [8, 0], [5, 1], [4, 3]] }, ":": { width: 10, points: [[5, 14], [4, 13], [5, 12], [6, 13], [5, 14], [-1, -1], [5, 2], [4, 1], [5, 0], [6, 1], [5, 2]] }, ";": { width: 10, points: [[5, 14], [4, 13], [5, 12], [6, 13], [5, 14], [-1, -1], [6, 1], [5, 0], [4, 1], [5, 2], [6, 1], [6, -1], [5, -3], [4, -4]] }, "<": { width: 24, points: [[20, 18], [4, 9], [20, 0]] }, "=": { width: 26, points: [[4, 12], [22, 12], [-1, -1], [4, 6], [22, 6]] }, ">": { width: 24, points: [[4, 18], [20, 9], [4, 0]] }, "?": { width: 18, points: [[3, 16], [3, 17], [4, 19], [5, 20], [7, 21], [11, 21], [13, 20], [14, 19], [15, 17], [15, 15], [14, 13], [13, 12], [9, 10], [9, 7], [-1, -1], [9, 2], [8, 1], [9, 0], [10, 1], [9, 2]] }, "@": { width: 27, points: [[18, 13], [17, 15], [15, 16], [12, 16], [10, 15], [9, 14], [8, 11], [8, 8], [9, 6], [11, 5], [14, 5], [16, 6], [17, 8], [-1, -1], [12, 16], [10, 14], [9, 11], [9, 8], [10, 6], [11, 5], [-1, -1], [18, 16], [17, 8], [17, 6], [19, 5], [21, 5], [23, 7], [24, 10], [24, 12], [23, 15], [22, 17], [20, 19], [18, 20], [15, 21], [12, 21], [9, 20], [7, 19], [5, 17], [4, 15], [3, 12], [3, 9], [4, 6], [5, 4], [7, 2], [9, 1], [12, 0], [15, 0], [18, 1], [20, 2], [21, 3], [-1, -1], [19, 16], [18, 8], [18, 6], [19, 5]] }, A: { width: 18, points: [[9, 21], [1, 0], [-1, -1], [9, 21], [17, 0], [-1, -1], [4, 7], [14, 7]] }, B: { width: 21, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [13, 21], [16, 20], [17, 19], [18, 17], [18, 15], [17, 13], [16, 12], [13, 11], [-1, -1], [4, 11], [13, 11], [16, 10], [17, 9], [18, 7], [18, 4], [17, 2], [16, 1], [13, 0], [4, 0]] }, C: { width: 21, points: [[18, 16], [17, 18], [15, 20], [13, 21], [9, 21], [7, 20], [5, 18], [4, 16], [3, 13], [3, 8], [4, 5], [5, 3], [7, 1], [9, 0], [13, 0], [15, 1], [17, 3], [18, 5]] }, D: { width: 21, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [11, 21], [14, 20], [16, 18], [17, 16], [18, 13], [18, 8], [17, 5], [16, 3], [14, 1], [11, 0], [4, 0]] }, E: { width: 19, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [17, 21], [-1, -1], [4, 11], [12, 11], [-1, -1], [4, 0], [17, 0]] }, F: { width: 18, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [17, 21], [-1, -1], [4, 11], [12, 11]] }, G: { width: 21, points: [[18, 16], [17, 18], [15, 20], [13, 21], [9, 21], [7, 20], [5, 18], [4, 16], [3, 13], [3, 8], [4, 5], [5, 3], [7, 1], [9, 0], [13, 0], [15, 1], [17, 3], [18, 5], [18, 8], [-1, -1], [13, 8], [18, 8]] }, H: { width: 22, points: [[4, 21], [4, 0], [-1, -1], [18, 21], [18, 0], [-1, -1], [4, 11], [18, 11]] }, I: { width: 8, points: [[4, 21], [4, 0]] }, J: { width: 16, points: [[12, 21], [12, 5], [11, 2], [10, 1], [8, 0], [6, 0], [4, 1], [3, 2], [2, 5], [2, 7]] }, K: { width: 21, points: [[4, 21], [4, 0], [-1, -1], [18, 21], [4, 7], [-1, -1], [9, 12], [18, 0]] }, L: { width: 17, points: [[4, 21], [4, 0], [-1, -1], [4, 0], [16, 0]] }, M: { width: 24, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [12, 0], [-1, -1], [20, 21], [12, 0], [-1, -1], [20, 21], [20, 0]] }, N: { width: 22, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [18, 0], [-1, -1], [18, 21], [18, 0]] }, O: { width: 22, points: [[9, 21], [7, 20], [5, 18], [4, 16], [3, 13], [3, 8], [4, 5], [5, 3], [7, 1], [9, 0], [13, 0], [15, 1], [17, 3], [18, 5], [19, 8], [19, 13], [18, 16], [17, 18], [15, 20], [13, 21], [9, 21]] }, P: { width: 21, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [13, 21], [16, 20], [17, 19], [18, 17], [18, 14], [17, 12], [16, 11], [13, 10], [4, 10]] }, Q: { width: 22, points: [[9, 21], [7, 20], [5, 18], [4, 16], [3, 13], [3, 8], [4, 5], [5, 3], [7, 1], [9, 0], [13, 0], [15, 1], [17, 3], [18, 5], [19, 8], [19, 13], [18, 16], [17, 18], [15, 20], [13, 21], [9, 21], [-1, -1], [12, 4], [18, -2]] }, R: { width: 21, points: [[4, 21], [4, 0], [-1, -1], [4, 21], [13, 21], [16, 20], [17, 19], [18, 17], [18, 15], [17, 13], [16, 12], [13, 11], [4, 11], [-1, -1], [11, 11], [18, 0]] }, S: { width: 20, points: [[17, 18], [15, 20], [12, 21], [8, 21], [5, 20], [3, 18], [3, 16], [4, 14], [5, 13], [7, 12], [13, 10], [15, 9], [16, 8], [17, 6], [17, 3], [15, 1], [12, 0], [8, 0], [5, 1], [3, 3]] }, T: { width: 16, points: [[8, 21], [8, 0], [-1, -1], [1, 21], [15, 21]] }, U: { width: 22, points: [[4, 21], [4, 6], [5, 3], [7, 1], [10, 0], [12, 0], [15, 1], [17, 3], [18, 6], [18, 21]] }, V: { width: 18, points: [[1, 21], [9, 0], [-1, -1], [17, 21], [9, 0]] }, W: { width: 24, points: [[2, 21], [7, 0], [-1, -1], [12, 21], [7, 0], [-1, -1], [12, 21], [17, 0], [-1, -1], [22, 21], [17, 0]] }, X: { width: 20, points: [[3, 21], [17, 0], [-1, -1], [17, 21], [3, 0]] }, Y: { width: 18, points: [[1, 21], [9, 11], [9, 0], [-1, -1], [17, 21], [9, 11]] }, Z: { width: 20, points: [[17, 21], [3, 0], [-1, -1], [3, 21], [17, 21], [-1, -1], [3, 0], [17, 0]] }, "[": { width: 14, points: [[4, 25], [4, -7], [-1, -1], [5, 25], [5, -7], [-1, -1], [4, 25], [11, 25], [-1, -1], [4, -7], [11, -7]] }, "\\": { width: 14, points: [[0, 21], [14, -3]] }, "]": { width: 14, points: [[9, 25], [9, -7], [-1, -1], [10, 25], [10, -7], [-1, -1], [3, 25], [10, 25], [-1, -1], [3, -7], [10, -7]] }, "^": { width: 16, points: [[6, 15], [8, 18], [10, 15], [-1, -1], [3, 12], [8, 17], [13, 12], [-1, -1], [8, 17], [8, 0]] }, _: { width: 16, points: [[0, -2], [16, -2]] }, "`": { width: 10, points: [[6, 21], [5, 20], [4, 18], [4, 16], [5, 15], [6, 16], [5, 17]] }, a: { width: 19, points: [[15, 14], [15, 0], [-1, -1], [15, 11], [13, 13], [11, 14], [8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3]] }, b: { width: 19, points: [[4, 21], [4, 0], [-1, -1], [4, 11], [6, 13], [8, 14], [11, 14], [13, 13], [15, 11], [16, 8], [16, 6], [15, 3], [13, 1], [11, 0], [8, 0], [6, 1], [4, 3]] }, c: { width: 18, points: [[15, 11], [13, 13], [11, 14], [8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3]] }, d: { width: 19, points: [[15, 21], [15, 0], [-1, -1], [15, 11], [13, 13], [11, 14], [8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3]] }, e: { width: 18, points: [[3, 8], [15, 8], [15, 10], [14, 12], [13, 13], [11, 14], [8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3]] }, f: { width: 12, points: [[10, 21], [8, 21], [6, 20], [5, 17], [5, 0], [-1, -1], [2, 14], [9, 14]] }, g: { width: 19, points: [[15, 14], [15, -2], [14, -5], [13, -6], [11, -7], [8, -7], [6, -6], [-1, -1], [15, 11], [13, 13], [11, 14], [8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3]] }, h: { width: 19, points: [[4, 21], [4, 0], [-1, -1], [4, 10], [7, 13], [9, 14], [12, 14], [14, 13], [15, 10], [15, 0]] }, i: { width: 8, points: [[3, 21], [4, 20], [5, 21], [4, 22], [3, 21], [-1, -1], [4, 14], [4, 0]] }, j: { width: 10, points: [[5, 21], [6, 20], [7, 21], [6, 22], [5, 21], [-1, -1], [6, 14], [6, -3], [5, -6], [3, -7], [1, -7]] }, k: { width: 17, points: [[4, 21], [4, 0], [-1, -1], [14, 14], [4, 4], [-1, -1], [8, 8], [15, 0]] }, l: { width: 8, points: [[4, 21], [4, 0]] }, m: { width: 30, points: [[4, 14], [4, 0], [-1, -1], [4, 10], [7, 13], [9, 14], [12, 14], [14, 13], [15, 10], [15, 0], [-1, -1], [15, 10], [18, 13], [20, 14], [23, 14], [25, 13], [26, 10], [26, 0]] }, n: { width: 19, points: [[4, 14], [4, 0], [-1, -1], [4, 10], [7, 13], [9, 14], [12, 14], [14, 13], [15, 10], [15, 0]] }, o: { width: 19, points: [[8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3], [16, 6], [16, 8], [15, 11], [13, 13], [11, 14], [8, 14]] }, p: { width: 19, points: [[4, 14], [4, -7], [-1, -1], [4, 11], [6, 13], [8, 14], [11, 14], [13, 13], [15, 11], [16, 8], [16, 6], [15, 3], [13, 1], [11, 0], [8, 0], [6, 1], [4, 3]] }, q: { width: 19, points: [[15, 14], [15, -7], [-1, -1], [15, 11], [13, 13], [11, 14], [8, 14], [6, 13], [4, 11], [3, 8], [3, 6], [4, 3], [6, 1], [8, 0], [11, 0], [13, 1], [15, 3]] }, r: { width: 13, points: [[4, 14], [4, 0], [-1, -1], [4, 8], [5, 11], [7, 13], [9, 14], [12, 14]] }, s: { width: 17, points: [[14, 11], [13, 13], [10, 14], [7, 14], [4, 13], [3, 11], [4, 9], [6, 8], [11, 7], [13, 6], [14, 4], [14, 3], [13, 1], [10, 0], [7, 0], [4, 1], [3, 3]] }, t: { width: 12, points: [[5, 21], [5, 4], [6, 1], [8, 0], [10, 0], [-1, -1], [2, 14], [9, 14]] }, u: { width: 19, points: [[4, 14], [4, 4], [5, 1], [7, 0], [10, 0], [12, 1], [15, 4], [-1, -1], [15, 14], [15, 0]] }, v: { width: 16, points: [[2, 14], [8, 0], [-1, -1], [14, 14], [8, 0]] }, w: { width: 22, points: [[3, 14], [7, 0], [-1, -1], [11, 14], [7, 0], [-1, -1], [11, 14], [15, 0], [-1, -1], [19, 14], [15, 0]] }, x: { width: 17, points: [[3, 14], [14, 0], [-1, -1], [14, 14], [3, 0]] }, y: { width: 16, points: [[2, 14], [8, 0], [-1, -1], [14, 14], [8, 0], [6, -4], [4, -6], [2, -7], [1, -7]] }, z: { width: 17, points: [[14, 14], [3, 0], [-1, -1], [3, 14], [14, 14], [-1, -1], [3, 0], [14, 0]] }, "{": { width: 14, points: [[9, 25], [7, 24], [6, 23], [5, 21], [5, 19], [6, 17], [7, 16], [8, 14], [8, 12], [6, 10], [-1, -1], [7, 24], [6, 22], [6, 20], [7, 18], [8, 17], [9, 15], [9, 13], [8, 11], [4, 9], [8, 7], [9, 5], [9, 3], [8, 1], [7, 0], [6, -2], [6, -4], [7, -6], [-1, -1], [6, 8], [8, 6], [8, 4], [7, 2], [6, 1], [5, -1], [5, -3], [6, -5], [7, -6], [9, -7]] }, "|": { width: 8, points: [[4, 25], [4, -7]] }, "}": { width: 14, points: [[5, 25], [7, 24], [8, 23], [9, 21], [9, 19], [8, 17], [7, 16], [6, 14], [6, 12], [8, 10], [-1, -1], [7, 24], [8, 22], [8, 20], [7, 18], [6, 17], [5, 15], [5, 13], [6, 11], [10, 9], [6, 7], [5, 5], [5, 3], [6, 1], [7, 0], [8, -2], [8, -4], [7, -6], [-1, -1], [8, 8], [6, 6], [6, 4], [7, 2], [8, 1], [9, -1], [9, -3], [8, -5], [7, -6], [5, -7]] }, "~": { width: 24, points: [[3, 6], [3, 8], [4, 11], [6, 12], [8, 12], [10, 11], [14, 8], [16, 7], [18, 7], [20, 8], [21, 10], [-1, -1], [3, 8], [4, 10], [6, 11], [8, 11], [10, 10], [14, 7], [16, 6], [18, 6], [20, 7], [21, 10], [21, 12]]} }; a.jqplot.CanvasFontRenderer = function (b) { b = b || {}; if (!b.pt2px) { b.pt2px = 1.5 } a.jqplot.CanvasTextRenderer.call(this, b) }; a.jqplot.CanvasFontRenderer.prototype = new a.jqplot.CanvasTextRenderer({}); a.jqplot.CanvasFontRenderer.prototype.constructor = a.jqplot.CanvasFontRenderer; a.jqplot.CanvasFontRenderer.prototype.measure = function (a, b) { var c = this.fontSize + " " + this.fontFamily; a.save(); a.font = c; var d = a.measureText(b).width; a.restore(); return d }; a.jqplot.CanvasFontRenderer.prototype.draw = function (a, b) { var c = 0; var d = this.height * .72; a.save(); var e, f; if (-Math.PI / 2 <= this.angle && this.angle <= 0 || Math.PI * 3 / 2 <= this.angle && this.angle <= Math.PI * 2) { e = 0; f = -Math.sin(this.angle) * this.width } else if (0 < this.angle && this.angle <= Math.PI / 2 || -Math.PI * 2 <= this.angle && this.angle <= -Math.PI * 3 / 2) { e = Math.sin(this.angle) * this.height; f = 0 } else if (-Math.PI < this.angle && this.angle < -Math.PI / 2 || Math.PI <= this.angle && this.angle <= Math.PI * 3 / 2) { e = -Math.cos(this.angle) * this.width; f = -Math.sin(this.angle) * this.width - Math.cos(this.angle) * this.height } else if (-Math.PI * 3 / 2 < this.angle && this.angle < Math.PI || Math.PI / 2 < this.angle && this.angle < Math.PI) { e = Math.sin(this.angle) * this.height - Math.cos(this.angle) * this.width; f = -Math.cos(this.angle) * this.height } a.strokeStyle = this.fillStyle; a.fillStyle = this.fillStyle; var g = this.fontSize + " " + this.fontFamily; a.font = g; a.translate(e, f); a.rotate(this.angle); a.fillText(b, c, d); a.restore() } })(jQuery); (function (a) { a.jqplot.CategoryAxisRenderer = function (b) { a.jqplot.LinearAxisRenderer.call(this); this.sortMergedLabels = false }; a.jqplot.CategoryAxisRenderer.prototype = new a.jqplot.LinearAxisRenderer; a.jqplot.CategoryAxisRenderer.prototype.constructor = a.jqplot.CategoryAxisRenderer; a.jqplot.CategoryAxisRenderer.prototype.init = function (b) { this.groups = 1; this.groupLabels = []; this._groupLabels = []; this._grouped = false; this._barsPerGroup = null; a.extend(true, this, { tickOptions: { formatString: "%d"} }, b); var c = this._dataBounds; for (var d = 0; d < this._series.length; d++) { var e = this._series[d]; if (e.groups) { this.groups = e.groups } var f = e.data; for (var g = 0; g < f.length; g++) { if (this.name == "xaxis" || this.name == "x2axis") { if (f[g][0] < c.min || c.min == null) { c.min = f[g][0] } if (f[g][0] > c.max || c.max == null) { c.max = f[g][0] } } else { if (f[g][1] < c.min || c.min == null) { c.min = f[g][1] } if (f[g][1] > c.max || c.max == null) { c.max = f[g][1] } } } } if (this.groupLabels.length) { this.groups = this.groupLabels.length } }; a.jqplot.CategoryAxisRenderer.prototype.createTicks = function () { var b = this._ticks; var c = this.ticks; var d = this.name; var e = this._dataBounds; var f, g; var h, i; var j, k; var l, m; if (c.length) { if (this.groups > 1 && !this._grouped) { var n = c.length; var o = parseInt(n / this.groups, 10); var p = 0; for (var m = o; m < n; m += o) { c.splice(m + p, 0, " "); p++ } this._grouped = true } this.min = .5; this.max = c.length + .5; var q = this.max - this.min; this.numberTicks = 2 * c.length + 1; for (m = 0; m < c.length; m++) { l = this.min + 2 * m * q / (this.numberTicks - 1); var r = new this.tickRenderer(this.tickOptions); r.showLabel = false; r.setTick(l, this.name); this._ticks.push(r); var r = new this.tickRenderer(this.tickOptions); r.label = c[m]; r.showMark = false; r.showGridline = false; r.setTick(l + .5, this.name); this._ticks.push(r) } var r = new this.tickRenderer(this.tickOptions); r.showLabel = false; r.setTick(l + 1, this.name); this._ticks.push(r) } else { if (d == "xaxis" || d == "x2axis") { f = this._plotDimensions.width } else { f = this._plotDimensions.height } if (this.min != null && this.max != null && this.numberTicks != null) { this.tickInterval = null } if (this.min != null && this.max != null && this.tickInterval != null) { if (parseInt((this.max - this.min) / this.tickInterval, 10) != (this.max - this.min) / this.tickInterval) { this.tickInterval = null } } var s = []; var t = 0; var h = .5; var i, u; var v = false; for (var m = 0; m < this._series.length; m++) { var w = this._series[m]; for (var x = 0; x < w.data.length; x++) { if (this.name == "xaxis" || this.name == "x2axis") { u = w.data[x][0] } else { u = w.data[x][1] } if (a.inArray(u, s) == -1) { v = true; t += 1; s.push(u) } } } if (v && this.sortMergedLabels) { s.sort(function (a, b) { return a - b }) } this.ticks = s; for (var m = 0; m < this._series.length; m++) { var w = this._series[m]; for (var x = 0; x < w.data.length; x++) { if (this.name == "xaxis" || this.name == "x2axis") { u = w.data[x][0] } else { u = w.data[x][1] } var y = a.inArray(u, s) + 1; if (this.name == "xaxis" || this.name == "x2axis") { w.data[x][0] = y } else { w.data[x][1] = y } } } if (this.groups > 1 && !this._grouped) { var n = s.length; var o = parseInt(n / this.groups, 10); var p = 0; for (var m = o; m < n; m += o + 1) { s[m] = " " } this._grouped = true } i = t + .5; if (this.numberTicks == null) { this.numberTicks = 2 * t + 1 } var q = i - h; this.min = h; this.max = i; var z = 0; var A = parseInt(3 + f / 10, 10); var o = parseInt(t / A, 10); if (this.tickInterval == null) { this.tickInterval = q / (this.numberTicks - 1) } for (var m = 0; m < this.numberTicks; m++) { l = this.min + m * this.tickInterval; var r = new this.tickRenderer(this.tickOptions); if (m / 2 == parseInt(m / 2, 10)) { r.showLabel = false; r.showMark = true } else { if (o > 0 && z < o) { r.showLabel = false; z += 1 } else { r.showLabel = true; z = 0 } r.label = r.formatter(r.formatString, s[(m - 1) / 2]); r.showMark = false; r.showGridline = false } r.setTick(l, this.name); this._ticks.push(r) } } }; a.jqplot.CategoryAxisRenderer.prototype.draw = function (b, c) { if (this.show) { this.renderer.createTicks.call(this); var d = 0; var e; if (this._elem) { this._elem.emptyForce() } this._elem = this._elem || a('<div class="jqplot-axis jqplot-' + this.name + '" style="position:absolute;"></div>'); if (this.name == "xaxis" || this.name == "x2axis") { this._elem.width(this._plotDimensions.width) } else { this._elem.height(this._plotDimensions.height) } this.labelOptions.axis = this.name; this._label = new this.labelRenderer(this.labelOptions); if (this._label.show) { var f = this._label.draw(b, c); f.appendTo(this._elem) } var g = this._ticks; for (var h = 0; h < g.length; h++) { var i = g[h]; if (i.showLabel && (!i.isMinorTick || this.showMinorTicks)) { var f = i.draw(b, c); f.appendTo(this._elem) } } this._groupLabels = []; for (var h = 0; h < this.groupLabels.length; h++) { var f = a('<div style="position:absolute;" class="jqplot-' + this.name + '-groupLabel"></div>'); f.html(this.groupLabels[h]); this._groupLabels.push(f); f.appendTo(this._elem) } } return this._elem }; a.jqplot.CategoryAxisRenderer.prototype.set = function () { var b = 0; var c; var d = 0; var e = 0; var f = this._label == null ? false : this._label.show; if (this.show) { var g = this._ticks; for (var h = 0; h < g.length; h++) { var i = g[h]; if (i.showLabel && (!i.isMinorTick || this.showMinorTicks)) { if (this.name == "xaxis" || this.name == "x2axis") { c = i._elem.outerHeight(true) } else { c = i._elem.outerWidth(true) } if (c > b) { b = c } } } var j = 0; for (var h = 0; h < this._groupLabels.length; h++) { var k = this._groupLabels[h]; if (this.name == "xaxis" || this.name == "x2axis") { c = k.outerHeight(true) } else { c = k.outerWidth(true) } if (c > j) { j = c } } if (f) { d = this._label._elem.outerWidth(true); e = this._label._elem.outerHeight(true) } if (this.name == "xaxis") { b += j + e; this._elem.css({ height: b + "px", left: "0px", bottom: "0px" }) } else if (this.name == "x2axis") { b += j + e; this._elem.css({ height: b + "px", left: "0px", top: "0px" }) } else if (this.name == "yaxis") { b += j + d; this._elem.css({ width: b + "px", left: "0px", top: "0px" }); if (f && this._label.constructor == a.jqplot.AxisLabelRenderer) { this._label._elem.css("width", d + "px") } } else { b += j + d; this._elem.css({ width: b + "px", right: "0px", top: "0px" }); if (f && this._label.constructor == a.jqplot.AxisLabelRenderer) { this._label._elem.css("width", d + "px") } } } }; a.jqplot.CategoryAxisRenderer.prototype.pack = function (b, c) { var d = this._ticks; var e = this.max; var f = this.min; var g = c.max; var h = c.min; var i = this._label == null ? false : this._label.show; var j; for (var k in b) { this._elem.css(k, b[k]) } this._offsets = c; var l = g - h; var m = e - f; this.p2u = function (a) { return (a - h) * m / l + f }; this.u2p = function (a) { return (a - f) * l / m + h }; if (this.name == "xaxis" || this.name == "x2axis") { this.series_u2p = function (a) { return (a - f) * l / m }; this.series_p2u = function (a) { return a * m / l + f } } else { this.series_u2p = function (a) { return (a - e) * l / m }; this.series_p2u = function (a) { return a * m / l + e } } if (this.show) { if (this.name == "xaxis" || this.name == "x2axis") { for (j = 0; j < d.length; j++) { var n = d[j]; if (n.show && n.showLabel) { var o; if (n.constructor == a.jqplot.CanvasAxisTickRenderer && n.angle) { var p = this.name == "xaxis" ? 1 : -1; switch (n.labelPosition) { case "auto": if (p * n.angle < 0) { o = -n.getWidth() + n._textRenderer.height * Math.sin(-n._textRenderer.angle) / 2 } else { o = -n._textRenderer.height * Math.sin(n._textRenderer.angle) / 2 } break; case "end": o = -n.getWidth() + n._textRenderer.height * Math.sin(-n._textRenderer.angle) / 2; break; case "start": o = -n._textRenderer.height * Math.sin(n._textRenderer.angle) / 2; break; case "middle": o = -n.getWidth() / 2 + n._textRenderer.height * Math.sin(-n._textRenderer.angle) / 2; break; default: o = -n.getWidth() / 2 + n._textRenderer.height * Math.sin(-n._textRenderer.angle) / 2; break } } else { o = -n.getWidth() / 2 } var q = this.u2p(n.value) + o + "px"; n._elem.css("left", q); n.pack() } } var r = ["bottom", 0]; if (i) { var s = this._label._elem.outerWidth(true); this._label._elem.css("left", h + l / 2 - s / 2 + "px"); if (this.name == "xaxis") { this._label._elem.css("bottom", "0px"); r = ["bottom", this._label._elem.outerHeight(true)] } else { this._label._elem.css("top", "0px"); r = ["top", this._label._elem.outerHeight(true)] } this._label.pack() } var t = parseInt(this._ticks.length / this.groups, 10); for (j = 0; j < this._groupLabels.length; j++) { var u = 0; var v = 0; for (var w = j * t; w <= (j + 1) * t; w++) { if (this._ticks[w]._elem && this._ticks[w].label != " ") { var n = this._ticks[w]._elem; var k = n.position(); u += k.left + n.outerWidth(true) / 2; v++ } } u = u / v; this._groupLabels[j].css({ left: u - this._groupLabels[j].outerWidth(true) / 2 }); this._groupLabels[j].css(r[0], r[1]) } } else { for (j = 0; j < d.length; j++) { var n = d[j]; if (n.show && n.showLabel) { var o; if (n.constructor == a.jqplot.CanvasAxisTickRenderer && n.angle) { var p = this.name == "yaxis" ? 1 : -1; switch (n.labelPosition) { case "auto": case "end": if (p * n.angle < 0) { o = -n._textRenderer.height * Math.cos(-n._textRenderer.angle) / 2 } else { o = -n.getHeight() + n._textRenderer.height * Math.cos(n._textRenderer.angle) / 2 } break; case "start": if (n.angle > 0) { o = -n._textRenderer.height * Math.cos(-n._textRenderer.angle) / 2 } else { o = -n.getHeight() + n._textRenderer.height * Math.cos(n._textRenderer.angle) / 2 } break; case "middle": o = -n.getHeight() / 2; break; default: o = -n.getHeight() / 2; break } } else { o = -n.getHeight() / 2 } var q = this.u2p(n.value) + o + "px"; n._elem.css("top", q); n.pack() } } var r = ["left", 0]; if (i) { var x = this._label._elem.outerHeight(true); this._label._elem.css("top", g - l / 2 - x / 2 + "px"); if (this.name == "yaxis") { this._label._elem.css("left", "0px"); r = ["left", this._label._elem.outerWidth(true)] } else { this._label._elem.css("right", "0px"); r = ["right", this._label._elem.outerWidth(true)] } this._label.pack() } var t = parseInt(this._ticks.length / this.groups, 10); for (j = 0; j < this._groupLabels.length; j++) { var u = 0; var v = 0; for (var w = j * t; w <= (j + 1) * t; w++) { if (this._ticks[w]._elem && this._ticks[w].label != " ") { var n = this._ticks[w]._elem; var k = n.position(); u += k.top + n.outerHeight() / 2; v++ } } u = u / v; this._groupLabels[j].css({ top: u - this._groupLabels[j].outerHeight() / 2 }); this._groupLabels[j].css(r[0], r[1]) } } } } })(jQuery); (function (a) { a.jqplot.ciParser = function (b, c) { function k(a, b) { var c; if (b != null) { if (b.toString().indexOf("Date") >= 0) { c = /^\/Date\((-?[0-9]+)\)\/$/.exec(b); if (c) { return parseInt(c[1], 10) } } return b } } var d = [], e, f, g, h, i, j; if (typeof b == "string") { b = a.jqplot.JSON.parse(b, k) } else if (typeof b == "object") { for (i in b) { for (g = 0; g < b[i].length; g++) { for (j in b[i][g]) { b[i][g][j] = k(j, b[i][g][j]) } } } } else { return null } for (var l in b) { e = []; f = b[l]; switch (l) { case "PriceTicks": for (g = 0; g < f.length; g++) { e.push([f[g]["TickDate"], f[g]["Price"]]) } break; case "PriceBars": for (g = 0; g < f.length; g++) { e.push([f[g]["BarDate"], f[g]["Open"], f[g]["High"], f[g]["Low"], f[g]["Close"]]) } break } d.push(e) } return d } })(jQuery); (function (a) { function p() { var a = this._zoom.start; var b = this._zoom.end; var c = this.zoomCanvas._ctx; var d, e, f, g; if (b[0] > a[0]) { d = a[0]; g = b[0] - a[0] } else { d = b[0]; g = a[0] - b[0] } if (b[1] > a[1]) { e = a[1]; f = b[1] - a[1] } else { e = b[1]; f = a[1] - b[1] } c.fillStyle = "rgba(0,0,0,0.2)"; c.strokeStyle = "#999999"; c.lineWidth = 1; c.clearRect(0, 0, c.canvas.width, c.canvas.height); c.fillRect(0, 0, c.canvas.width, c.canvas.height); c.clearRect(d, e, g, f); c.strokeRect(d, e, g, f); c = null } function o(b) { var c = b.data.plot; var d = c.plugins.cursor; if (d.zoom && d._zoom.zooming && !d.zoomTarget) { var e = d._zoom.gridpos.x; var f = d._zoom.gridpos.y; var g = d._zoom.datapos; var h = d.zoomCanvas._ctx.canvas.height; var i = d.zoomCanvas._ctx.canvas.width; var j = c.axes; if (d.constrainOutsideZoom && !d.onGrid) { if (e < 0) { e = 0 } else if (e > i) { e = i } if (f < 0) { f = 0 } else if (f > h) { f = h } for (var k in g) { if (g[k]) { if (k.charAt(0) == "x") { g[k] = j[k].series_p2u(e) } else { g[k] = j[k].series_p2u(f) } } } } if (d.constrainZoomTo == "x") { f = h } else if (d.constrainZoomTo == "y") { e = i } d._zoom.end = [e, f]; d._zoom.gridpos = { x: e, y: f }; d.doZoom(d._zoom.gridpos, g, c, d) } d._zoom.started = false; d._zoom.zooming = false; a(document).unbind("mousemove.jqplotCursor", m); if (document.onselectstart != undefined && d._oldHandlers.onselectstart != null) { document.onselectstart = d._oldHandlers.onselectstart; d._oldHandlers.onselectstart = null } if (document.ondrag != undefined && d._oldHandlers.ondrag != null) { document.ondrag = d._oldHandlers.ondrag; d._oldHandlers.ondrag = null } if (document.onmousedown != undefined && d._oldHandlers.onmousedown != null) { document.onmousedown = d._oldHandlers.onmousedown; d._oldHandlers.onmousedown = null } } function n(b, c, d, e, f) { var g = f.plugins.cursor; a(document).one("mouseup.jqplot_cursor", { plot: f }, o); var h = f.axes; if (document.onselectstart != undefined) { g._oldHandlers.onselectstart = document.onselectstart; document.onselectstart = function () { return false } } if (document.ondrag != undefined) { g._oldHandlers.ondrag = document.ondrag; document.ondrag = function () { return false } } if (document.onmousedown != undefined) { g._oldHandlers.onmousedown = document.onmousedown; document.onmousedown = function () { return false } } if (g.zoom) { if (!g.zoomProxy) { var i = g.zoomCanvas._ctx; i.clearRect(0, 0, i.canvas.width, i.canvas.height); i = null } if (g.constrainZoomTo == "x") { g._zoom.start = [c.x, 0] } else if (g.constrainZoomTo == "y") { g._zoom.start = [0, c.y] } else { g._zoom.start = [c.x, c.y] } g._zoom.started = true; for (var j in d) { g._zoom.axes.start[j] = d[j] } a(document).bind("mousemove.jqplotCursor", { plot: f }, m) } } function m(a) { var c = a.data.plot; var d = c.plugins.cursor; if (d.show && d.zoom && d._zoom.started && !d.zoomTarget) { var f = d.zoomCanvas._ctx; var g = l(a); var h = g.gridPos; var i = g.dataPos; d._zoom.gridpos = h; d._zoom.datapos = i; d._zoom.zooming = true; var j = h.x; var k = h.y; var m = f.canvas.height; var n = f.canvas.width; if (d.showTooltip && !d.onGrid && d.showTooltipOutsideZoom) { b(h, i, c); if (d.followMouse) { e(h, c) } } if (d.constrainZoomTo == "x") { d._zoom.end = [j, m] } else if (d.constrainZoomTo == "y") { d._zoom.end = [n, k] } else { d._zoom.end = [j, k] } var o = window.getSelection; if (document.selection && document.selection.empty) { document.selection.empty() } else if (o && !o().isCollapsed) { o().collapse() } p.call(d); f = null } } function l(a) { var b = a.data.plot; var c = b.eventCanvas._elem.offset(); var d = { x: a.pageX - c.left, y: a.pageY - c.top }; var e = { xaxis: null, yaxis: null, x2axis: null, y2axis: null, y3axis: null, y4axis: null, y5axis: null, y6axis: null, y7axis: null, y8axis: null, y9axis: null, yMidAxis: null }; var f = ["xaxis", "yaxis", "x2axis", "y2axis", "y3axis", "y4axis", "y5axis", "y6axis", "y7axis", "y8axis", "y9axis", "yMidAxis"]; var g = b.axes; var h, i; for (h = 11; h > 0; h--) { i = f[h - 1]; if (g[i].show) { e[i] = g[i].series_p2u(d[i.charAt(0)]) } } return { offsets: c, gridPos: d, dataPos: e} } function k(a, d, f, g, h) { var i = h.plugins.cursor; if (i.show) { if (i.showTooltip) { b(d, f, h); if (i.followMouse) { e(d, h) } } if (i.showVerticalLine || i.showHorizontalLine) { c(d, h) } } } function j(a, d, g, h, i) { var j = i.plugins.cursor; j.onGrid = true; if (j.show) { j.previousCursor = a.target.style.cursor; a.target.style.cursor = j.style; if (j.showTooltip) { b(d, g, i); if (j.followMouse) { e(d, i) } else { f(i) } j._tooltipElem.show() } if (j.showVerticalLine || j.showHorizontalLine) { c(d, i) } } } function i(b, c, d, e, f) { var g = f.plugins.cursor; g.onGrid = false; if (g.show) { a(b.target).css("cursor", g.previousCursor); if (g.showTooltip && !(g._zoom.zooming && g.showTooltipOutsideZoom && !g.constrainOutsideZoom)) { g._tooltipElem.hide() } if (g.zoom) { g._zoom.gridpos = c; g._zoom.datapos = d } if (g.showVerticalLine || g.showHorizontalLine) { var h = g.cursorCanvas._ctx; h.clearRect(0, 0, h.canvas.width, h.canvas.height); h = null } if (g.showCursorLegend) { var i = a(f.targetId + " td.jqplot-cursor-legend-label"); for (var j = 0; j < i.length; j++) { var k = a(i[j]).data("seriesIndex"); var l = f.series[k]; var m = l.label.toString(); if (f.legend.escapeHtml) { a(i[j]).text(a.jqplot.sprintf(g.cursorLegendFormatString, m, undefined, undefined)) } else { a(i[j]).html(a.jqplot.sprintf(g.cursorLegendFormatString, m, undefined, undefined)) } } } } } function h(a, b, c, d, e) { a.preventDefault(); a.stopImmediatePropagation(); var f = e.plugins.cursor; if (f.dblClickReset) { f.resetZoom(e, f) } var g = window.getSelection; if (document.selection && document.selection.empty) { document.selection.empty() } else if (g && !g().isCollapsed) { g().collapse() } return false } function g(a, b, c, d, e) { a.preventDefault(); a.stopImmediatePropagation(); var f = e.plugins.cursor; if (f.clickReset) { f.resetZoom(e, f) } var g = window.getSelection; if (document.selection && document.selection.empty) { document.selection.empty() } else if (g && !g().isCollapsed) { g().collapse() } return false } function f(a) { var b = a._gridPadding; var c = a.plugins.cursor; var d = c._tooltipElem; switch (c.tooltipLocation) { case "nw": var e = b.left + c.tooltipOffset; var f = b.top + c.tooltipOffset; d.css("left", e); d.css("top", f); break; case "n": var e = (b.left + (a._plotDimensions.width - b.right)) / 2 - d.outerWidth(true) / 2; var f = b.top + c.tooltipOffset; d.css("left", e); d.css("top", f); break; case "ne": var e = b.right + c.tooltipOffset; var f = b.top + c.tooltipOffset; d.css({ right: e, top: f }); break; case "e": var e = b.right + c.tooltipOffset; var f = (b.top + (a._plotDimensions.height - b.bottom)) / 2 - d.outerHeight(true) / 2; d.css({ right: e, top: f }); break; case "se": var e = b.right + c.tooltipOffset; var f = b.bottom + c.tooltipOffset; d.css({ right: e, bottom: f }); break; case "s": var e = (b.left + (a._plotDimensions.width - b.right)) / 2 - d.outerWidth(true) / 2; var f = b.bottom + c.tooltipOffset; d.css({ left: e, bottom: f }); break; case "sw": var e = b.left + c.tooltipOffset; var f = b.bottom + c.tooltipOffset; d.css({ left: e, bottom: f }); break; case "w": var e = b.left + c.tooltipOffset; var f = (b.top + (a._plotDimensions.height - b.bottom)) / 2 - d.outerHeight(true) / 2; d.css({ left: e, top: f }); break; default: var e = b.right - c.tooltipOffset; var f = b.bottom + c.tooltipOffset; d.css({ right: e, bottom: f }); break } d = null } function e(a, b) { var c = b.plugins.cursor; var d = c._tooltipElem; switch (c.tooltipLocation) { case "nw": var e = a.x + b._gridPadding.left - d.outerWidth(true) - c.tooltipOffset; var f = a.y + b._gridPadding.top - c.tooltipOffset - d.outerHeight(true); break; case "n": var e = a.x + b._gridPadding.left - d.outerWidth(true) / 2; var f = a.y + b._gridPadding.top - c.tooltipOffset - d.outerHeight(true); break; case "ne": var e = a.x + b._gridPadding.left + c.tooltipOffset; var f = a.y + b._gridPadding.top - c.tooltipOffset - d.outerHeight(true); break; case "e": var e = a.x + b._gridPadding.left + c.tooltipOffset; var f = a.y + b._gridPadding.top - d.outerHeight(true) / 2; break; case "se": var e = a.x + b._gridPadding.left + c.tooltipOffset; var f = a.y + b._gridPadding.top + c.tooltipOffset; break; case "s": var e = a.x + b._gridPadding.left - d.outerWidth(true) / 2; var f = a.y + b._gridPadding.top + c.tooltipOffset; break; case "sw": var e = a.x + b._gridPadding.left - d.outerWidth(true) - c.tooltipOffset; var f = a.y + b._gridPadding.top + c.tooltipOffset; break; case "w": var e = a.x + b._gridPadding.left - d.outerWidth(true) - c.tooltipOffset; var f = a.y + b._gridPadding.top - d.outerHeight(true) / 2; break; default: var e = a.x + b._gridPadding.left + c.tooltipOffset; var f = a.y + b._gridPadding.top + c.tooltipOffset; break } d.css("left", e); d.css("top", f); d = null } function d(a, b, c) { var d = { indices: [], data: [] }; var e, f, g, h, i, j, k; var l; var m = a.plugins.cursor; for (var f = 0; f < a.series.length; f++) { e = a.series[f]; j = e.renderer; if (e.show) { l = m.intersectionThreshold; if (e.showMarker) { l += e.markerRenderer.size / 2 } for (var i = 0; i < e.gridData.length; i++) { k = e.gridData[i]; if (m.showVerticalLine) { if (Math.abs(b - k[0]) <= l) { d.indices.push(f); d.data.push({ seriesIndex: f, pointIndex: i, gridData: k, data: e.data[i] }) } } } } } return d } function c(b, c) { var e = c.plugins.cursor; var f = e.cursorCanvas._ctx; f.clearRect(0, 0, f.canvas.width, f.canvas.height); if (e.showVerticalLine) { e.shapeRenderer.draw(f, [[b.x, 0], [b.x, f.canvas.height]]) } if (e.showHorizontalLine) { e.shapeRenderer.draw(f, [[0, b.y], [f.canvas.width, b.y]]) } var g = d(c, b.x, b.y); if (e.showCursorLegend) { var h = a(c.targetId + " td.jqplot-cursor-legend-label"); for (var i = 0; i < h.length; i++) { var j = a(h[i]).data("seriesIndex"); var k = c.series[j]; var l = k.label.toString(); var m = a.inArray(j, g.indices); var n = undefined; var o = undefined; if (m != -1) { var p = g.data[m].data; if (e.useAxesFormatters) { var q = k._xaxis._ticks[0].formatter; var r = k._yaxis._ticks[0].formatter; var s = k._xaxis._ticks[0].formatString; var t = k._yaxis._ticks[0].formatString; n = q(s, p[0]); o = r(t, p[1]) } else { n = p[0]; o = p[1] } } if (c.legend.escapeHtml) { a(h[i]).text(a.jqplot.sprintf(e.cursorLegendFormatString, l, n, o)) } else { a(h[i]).html(a.jqplot.sprintf(e.cursorLegendFormatString, l, n, o)) } } } f = null } function b(b, c, e) { var f = e.plugins.cursor; var g = ""; var h = false; if (f.showTooltipGridPosition) { g = b.x + ", " + b.y; h = true } if (f.showTooltipUnitPosition) { var i; for (var j = 0; j < f.tooltipAxisGroups.length; j++) { i = f.tooltipAxisGroups[j]; if (h) { g += "<br />" } if (f.useAxesFormatters) { var k = e.axes[i[0]]._ticks[0].formatter; var l = e.axes[i[1]]._ticks[0].formatter; var m = e.axes[i[0]]._ticks[0].formatString; var n = e.axes[i[1]]._ticks[0].formatString; g += k(m, c[i[0]]) + ", " + l(n, c[i[1]]) } else { g += a.jqplot.sprintf(f.tooltipFormatString, c[i[0]], c[i[1]]) } h = true } } if (f.showTooltipDataPosition) { var o = e.series; var p = d(e, b.x, b.y); var h = false; for (var j = 0; j < o.length; j++) { if (o[j].show) { var q = o[j].index; var r = o[j].label.toString(); var s = a.inArray(q, p.indices); var t = undefined; var u = undefined; if (s != -1) { var v = p.data[s].data; if (f.useAxesFormatters) { var k = o[j]._xaxis._ticks[0].formatter; var l = o[j]._yaxis._ticks[0].formatter; var m = o[j]._xaxis._ticks[0].formatString; var n = o[j]._yaxis._ticks[0].formatString; t = k(m, v[0]); u = l(n, v[1]) } else { t = v[0]; u = v[1] } if (h) { g += "<br />" } g += a.jqplot.sprintf(f.tooltipFormatString, r, t, u); h = true } } } } f._tooltipElem.html(g) } a.jqplot.Cursor = function (b) { this.style = "crosshair"; this.previousCursor = "auto"; this.show = a.jqplot.config.enablePlugins; this.showTooltip = true; this.followMouse = false; this.tooltipLocation = "se"; this.tooltipOffset = 6; this.showTooltipGridPosition = false; this.showTooltipUnitPosition = true; this.showTooltipDataPosition = false; this.tooltipFormatString = "%.4P, %.4P"; this.useAxesFormatters = true; this.tooltipAxisGroups = []; this.zoom = false; this.zoomProxy = false; this.zoomTarget = false; this.looseZoom = true; this.clickReset = false; this.dblClickReset = true; this.showVerticalLine = false; this.showHorizontalLine = false; this.constrainZoomTo = "none"; this.shapeRenderer = new a.jqplot.ShapeRenderer; this._zoom = { start: [], end: [], started: false, zooming: false, isZoomed: false, axes: { start: {}, end: {} }, gridpos: {}, datapos: {} }; this._tooltipElem; this.zoomCanvas; this.cursorCanvas; this.intersectionThreshold = 2; this.showCursorLegend = false; this.cursorLegendFormatString = a.jqplot.Cursor.cursorLegendFormatString; this._oldHandlers = { onselectstart: null, ondrag: null, onmousedown: null }; this.constrainOutsideZoom = true; this.showTooltipOutsideZoom = false; this.onGrid = false; a.extend(true, this, b) }; a.jqplot.Cursor.cursorLegendFormatString = "%s x:%s, y:%s"; a.jqplot.Cursor.init = function (b, c, d) { var e = d || {}; this.plugins.cursor = new a.jqplot.Cursor(e.cursor); var f = this.plugins.cursor; if (f.show) { a.jqplot.eventListenerHooks.push(["jqplotMouseEnter", j]); a.jqplot.eventListenerHooks.push(["jqplotMouseLeave", i]); a.jqplot.eventListenerHooks.push(["jqplotMouseMove", k]); if (f.showCursorLegend) { d.legend = d.legend || {}; d.legend.renderer = a.jqplot.CursorLegendRenderer; d.legend.formatString = this.plugins.cursor.cursorLegendFormatString; d.legend.show = true } if (f.zoom) { a.jqplot.eventListenerHooks.push(["jqplotMouseDown", n]); if (f.clickReset) { a.jqplot.eventListenerHooks.push(["jqplotClick", g]) } if (f.dblClickReset) { a.jqplot.eventListenerHooks.push(["jqplotDblClick", h]) } } this.resetZoom = function () { var a = this.axes; if (!f.zoomProxy) { for (var b in a) { a[b].reset(); a[b]._ticks = []; if (f._zoom.axes[b] !== undefined) { a[b]._autoFormatString = f._zoom.axes[b].tickFormatString } } this.redraw() } else { var c = this.plugins.cursor.zoomCanvas._ctx; c.clearRect(0, 0, c.canvas.width, c.canvas.height); c = null } this.plugins.cursor._zoom.isZoomed = false; this.target.trigger("jqplotResetZoom", [this, this.plugins.cursor]) }; if (f.showTooltipDataPosition) { f.showTooltipUnitPosition = false; f.showTooltipGridPosition = false; if (e.cursor.tooltipFormatString == undefined) { f.tooltipFormatString = a.jqplot.Cursor.cursorLegendFormatString } } } }; a.jqplot.Cursor.postDraw = function () { var b = this.plugins.cursor; if (b.zoomCanvas) { b.zoomCanvas.resetCanvas(); b.zoomCanvas = null } if (b.cursorCanvas) { b.cursorCanvas.resetCanvas(); b.cursorCanvas = null } if (b._tooltipElem) { b._tooltipElem.emptyForce(); b._tooltipElem = null } if (b.zoom) { b.zoomCanvas = new a.jqplot.GenericCanvas; this.eventCanvas._elem.before(b.zoomCanvas.createElement(this._gridPadding, "jqplot-zoom-canvas", this._plotDimensions, this)); b.zoomCanvas.setContext() } var c = document.createElement("div"); b._tooltipElem = a(c); c = null; b._tooltipElem.addClass("jqplot-cursor-tooltip"); b._tooltipElem.css({ position: "absolute", display: "none" }); if (b.zoomCanvas) { b.zoomCanvas._elem.before(b._tooltipElem) } else { this.eventCanvas._elem.before(b._tooltipElem) } if (b.showVerticalLine || b.showHorizontalLine) { b.cursorCanvas = new a.jqplot.GenericCanvas; this.eventCanvas._elem.before(b.cursorCanvas.createElement(this._gridPadding, "jqplot-cursor-canvas", this._plotDimensions, this)); b.cursorCanvas.setContext() } if (b.showTooltipUnitPosition) { if (b.tooltipAxisGroups.length === 0) { var d = this.series; var e; var f = []; for (var g = 0; g < d.length; g++) { e = d[g]; var h = e.xaxis + "," + e.yaxis; if (a.inArray(h, f) == -1) { f.push(h) } } for (var g = 0; g < f.length; g++) { b.tooltipAxisGroups.push(f[g].split(",")) } } } }; a.jqplot.Cursor.zoomProxy = function (a, b) { function f(b, c, d) { a.resetZoom() } function e(b, d, e, f, g) { c.doZoom(d, e, a, g) } var c = a.plugins.cursor; var d = b.plugins.cursor; c.zoomTarget = true; c.zoom = true; c.style = "auto"; c.dblClickReset = false; d.zoom = true; d.zoomProxy = true; b.target.bind("jqplotZoom", e); b.target.bind("jqplotResetZoom", f) }; a.jqplot.Cursor.prototype.resetZoom = function (a, b) { var c = a.axes; var d = b._zoom.axes; if (!a.plugins.cursor.zoomProxy && b._zoom.isZoomed) { for (var e in c) { c[e].reset(); c[e]._ticks = []; c[e]._autoFormatString = d[e].tickFormatString } a.redraw(); b._zoom.isZoomed = false } else { var f = b.zoomCanvas._ctx; f.clearRect(0, 0, f.canvas.width, f.canvas.height); f = null } a.target.trigger("jqplotResetZoom", [a, b]) }; a.jqplot.Cursor.resetZoom = function (a) { a.resetZoom() }; a.jqplot.Cursor.prototype.doZoom = function (b, c, d, e) { var f = e; var g = d.axes; var h = f._zoom.axes; var i = h.start; var j = h.end; var k, l, m, n, o, p, q, r, s; var t = d.plugins.cursor.zoomCanvas._ctx; if (f.constrainZoomTo == "none" && Math.abs(b.x - f._zoom.start[0]) > 6 && Math.abs(b.y - f._zoom.start[1]) > 6 || f.constrainZoomTo == "x" && Math.abs(b.x - f._zoom.start[0]) > 6 || f.constrainZoomTo == "y" && Math.abs(b.y - f._zoom.start[1]) > 6) { if (!d.plugins.cursor.zoomProxy) { for (var u in c) { if (f._zoom.axes[u] == undefined) { f._zoom.axes[u] = {}; f._zoom.axes[u].numberTicks = g[u].numberTicks; f._zoom.axes[u].tickInterval = g[u].tickInterval; f._zoom.axes[u].daTickInterval = g[u].daTickInterval; f._zoom.axes[u].min = g[u].min; f._zoom.axes[u].max = g[u].max; f._zoom.axes[u].tickFormatString = g[u].tickOptions != null ? g[u].tickOptions.formatString : "" } if (f.constrainZoomTo == "none" || f.constrainZoomTo == "x" && u.charAt(0) == "x" || f.constrainZoomTo == "y" && u.charAt(0) == "y") { m = c[u]; if (m != null) { if (m > i[u]) { o = i[u]; p = m } else { n = i[u] - m; o = m; p = i[u] } q = g[u]; r = null; if (q.alignTicks) { if (q.name === "x2axis" && d.axes.xaxis.show) { r = d.axes.xaxis.numberTicks } else if (q.name.charAt(0) === "y" && q.name !== "yaxis" && q.name !== "yMidAxis" && d.axes.yaxis.show) { r = d.axes.yaxis.numberTicks } } if (this.looseZoom && (g[u].renderer.constructor === a.jqplot.LinearAxisRenderer || g[u].renderer.constructor === a.jqplot.LogAxisRenderer)) { s = a.jqplot.LinearTickGenerator(o, p, q._scalefact, r); if (g[u].tickInset && s[0] < g[u].min + g[u].tickInset * g[u].tickInterval) { s[0] += s[4]; s[2] -= 1 } if (g[u].tickInset && s[1] > g[u].max - g[u].tickInset * g[u].tickInterval) { s[1] -= s[4]; s[2] -= 1 } if (g[u].renderer.constructor === a.jqplot.LogAxisRenderer && s[0] < g[u].min) { s[0] += s[4]; s[2] -= 1 } g[u].min = s[0]; g[u].max = s[1]; g[u]._autoFormatString = s[3]; g[u].numberTicks = s[2]; g[u].tickInterval = s[4]; g[u].daTickInterval = [s[4] / 1e3, "seconds"] } else { g[u].min = o; g[u].max = p; g[u].tickInterval = null; g[u].numberTicks = null; g[u].daTickInterval = null } g[u]._ticks = [] } } } t.clearRect(0, 0, t.canvas.width, t.canvas.height); d.redraw(); f._zoom.isZoomed = true; t = null } d.target.trigger("jqplotZoom", [b, c, d, e]) } }; a.jqplot.preInitHooks.push(a.jqplot.Cursor.init); a.jqplot.postDrawHooks.push(a.jqplot.Cursor.postDraw); a.jqplot.CursorLegendRenderer = function (b) { a.jqplot.TableLegendRenderer.call(this, b); this.formatString = "%s" }; a.jqplot.CursorLegendRenderer.prototype = new a.jqplot.TableLegendRenderer; a.jqplot.CursorLegendRenderer.prototype.constructor = a.jqplot.CursorLegendRenderer; a.jqplot.CursorLegendRenderer.prototype.draw = function () { function k(b, c, d, e) { var f = d ? this.rowSpacing : "0"; var g = a('<tr class="jqplot-legend jqplot-cursor-legend"></tr>').appendTo(this._elem); g.data("seriesIndex", e); a('<td class="jqplot-legend jqplot-cursor-legend-swatch" style="padding-top:' + f + ';">' + '<div style="border:1px solid #cccccc;padding:0.2em;">' + '<div class="jqplot-cursor-legend-swatch" style="background-color:' + c + ';"></div>' + "</div></td>").appendTo(g); var h = a('<td class="jqplot-legend jqplot-cursor-legend-label" style="vertical-align:middle;padding-top:' + f + ';"></td>'); h.appendTo(g); h.data("seriesIndex", e); if (this.escapeHtml) { h.text(b) } else { h.html(b) } g = null; h = null } if (this._elem) { this._elem.emptyForce(); this._elem = null } if (this.show) { var b = this._series, c; var d = document.createElement("div"); this._elem = a(d); d = null; this._elem.addClass("jqplot-legend jqplot-cursor-legend"); this._elem.css("position", "absolute"); var e = false; for (var f = 0; f < b.length; f++) { c = b[f]; if (c.show && c.showLabel) { var g = a.jqplot.sprintf(this.formatString, c.label.toString()); if (g) { var h = c.color; if (c._stack && !c.fill) { h = "" } k.call(this, g, h, e, f); e = true } for (var i = 0; i < a.jqplot.addLegendRowHooks.length; i++) { var j = a.jqplot.addLegendRowHooks[i].call(this, c); if (j) { k.call(this, j.label, j.color, e); e = true } } } } b = c = null; delete b; delete c } return this._elem } })(jQuery); (function (a) { function m(a, b, c) { var d = Number.MAX_VALUE; var e, f, g; for (var h = 0, i = k.length; h < i; h++) { e = Math.abs(c - k[h]); if (e < d) { d = e; f = k[h]; g = j[h] } } return [f, g] } a.jqplot.DateAxisRenderer = function () { a.jqplot.LinearAxisRenderer.call(this); this.date = new a.jsDate }; var b = 1e3; var c = 60 * b; var d = 60 * c; var e = 24 * d; var f = 7 * e; var g = 30.4368499 * e; var h = 365.242199 * e; var i = [31, 28, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30]; var j = ["%M:%S.%#N", "%M:%S.%#N", "%M:%S.%#N", "%M:%S", "%M:%S", "%M:%S", "%M:%S", "%H:%M:%S", "%H:%M:%S", "%H:%M", "%H:%M", "%H:%M", "%H:%M", "%H:%M", "%H:%M", "%a %H:%M", "%a %H:%M", "%b %e %H:%M", "%b %e %H:%M", "%b %e %H:%M", "%b %e %H:%M", "%v", "%v", "%v", "%v", "%v", "%v", "%v"]; var k = [.1 * b, .2 * b, .5 * b, b, 2 * b, 5 * b, 10 * b, 15 * b, 30 * b, c, 2 * c, 5 * c, 10 * c, 15 * c, 30 * c, d, 2 * d, 4 * d, 6 * d, 8 * d, 12 * d, e, 2 * e, 3 * e, 4 * e, 5 * e, f, 2 * f]; var l = []; a.jqplot.DateAxisRenderer.prototype = new a.jqplot.LinearAxisRenderer; a.jqplot.DateAxisRenderer.prototype.constructor = a.jqplot.DateAxisRenderer; a.jqplot.DateTickFormatter = function (b, c) { if (!b) { b = "%Y/%m/%d" } return a.jsDate.strftime(c, b) }; a.jqplot.DateAxisRenderer.prototype.init = function (b) { this.tickOptions.formatter = a.jqplot.DateTickFormatter; this.tickInset = 0; this.drawBaseline = true; this.baselineWidth = null; this.baselineColor = null; this.daTickInterval = null; this._daTickInterval = null; a.extend(true, this, b); var c = this._dataBounds, d, e, f, g, h, i, j; for (var k = 0; k < this._series.length; k++) { d = { intervals: [], frequencies: {}, sortedIntervals: [], min: null, max: null, mean: null }; e = 0; f = this._series[k]; g = f.data; h = f._plotData; i = f._stackData; j = 0; for (var l = 0; l < g.length; l++) { if (this.name == "xaxis" || this.name == "x2axis") { g[l][0] = (new a.jsDate(g[l][0])).getTime(); h[l][0] = (new a.jsDate(g[l][0])).getTime(); i[l][0] = (new a.jsDate(g[l][0])).getTime(); if (g[l][0] != null && g[l][0] < c.min || c.min == null) { c.min = g[l][0] } if (g[l][0] != null && g[l][0] > c.max || c.max == null) { c.max = g[l][0] } if (l > 0) { j = Math.abs(g[l][0] - g[l - 1][0]); d.intervals.push(j); if (d.frequencies.hasOwnProperty(j)) { d.frequencies[j] += 1 } else { d.frequencies[j] = 1 } } e += j } else { g[l][1] = (new a.jsDate(g[l][1])).getTime(); h[l][1] = (new a.jsDate(g[l][1])).getTime(); i[l][1] = (new a.jsDate(g[l][1])).getTime(); if (g[l][1] != null && g[l][1] < c.min || c.min == null) { c.min = g[l][1] } if (g[l][1] != null && g[l][1] > c.max || c.max == null) { c.max = g[l][1] } if (l > 0) { j = Math.abs(g[l][1] - g[l - 1][1]); d.intervals.push(j); if (d.frequencies.hasOwnProperty(j)) { d.frequencies[j] += 1 } else { d.frequencies[j] = 1 } } } e += j } if (f.renderer.bands) { if (f.renderer.bands.hiData.length) { var m = f.renderer.bands.hiData; for (var l = 0, n = m.length; l < n; l++) { if (this.name === "xaxis" || this.name === "x2axis") { m[l][0] = (new a.jsDate(m[l][0])).getTime(); if (m[l][0] != null && m[l][0] > c.max || c.max == null) { c.max = m[l][0] } } else { m[l][1] = (new a.jsDate(m[l][1])).getTime(); if (m[l][1] != null && m[l][1] > c.max || c.max == null) { c.max = m[l][1] } } } } if (f.renderer.bands.lowData.length) { var m = f.renderer.bands.lowData; for (var l = 0, n = m.length; l < n; l++) { if (this.name === "xaxis" || this.name === "x2axis") { m[l][0] = (new a.jsDate(m[l][0])).getTime(); if (m[l][0] != null && m[l][0] < c.min || c.min == null) { c.min = m[l][0] } } else { m[l][1] = (new a.jsDate(m[l][1])).getTime(); if (m[l][1] != null && m[l][1] < c.min || c.min == null) { c.min = m[l][1] } } } } } var o = 0, p = 0; for (var q in d.frequencies) { d.sortedIntervals.push({ interval: q, frequency: d.frequencies[q] }) } d.sortedIntervals.sort(function (a, b) { return b.frequency - a.frequency }); d.min = a.jqplot.arrayMin(d.intervals); d.max = a.jqplot.arrayMax(d.intervals); d.mean = e / g.length; this._intervalStats.push(d); d = e = f = g = h = i = null } c = null }; a.jqplot.DateAxisRenderer.prototype.reset = function () { this.min = this._options.min; this.max = this._options.max; this.tickInterval = this._options.tickInterval; this.numberTicks = this._options.numberTicks; this._autoFormatString = ""; if (this._overrideFormatString && this.tickOptions && this.tickOptions.formatString) { this.tickOptions.formatString = "" } this.daTickInterval = this._daTickInterval }; a.jqplot.DateAxisRenderer.prototype.createTicks = function (b) { var c = this._ticks; var d = this.ticks; var f = this.name; var i = this._dataBounds; var j = this._intervalStats; var k = this.name.charAt(0) === "x" ? this._plotDimensions.width : this._plotDimensions.height; var l; var n, o; var p, q; var r, s; var t = 30; var u = 1; var v = this.tickInterval; n = this.min != null ? (new a.jsDate(this.min)).getTime() : i.min; o = this.max != null ? (new a.jsDate(this.max)).getTime() : i.max; var w = b.plugins.cursor; if (w && w._zoom && w._zoom.zooming) { this.min = null; this.max = null } var x = o - n; if (this.tickOptions == null || !this.tickOptions.formatString) { this._overrideFormatString = true } if (d.length) { for (s = 0; s < d.length; s++) { var y = d[s]; var z = new this.tickRenderer(this.tickOptions); if (y.constructor == Array) { z.value = (new a.jsDate(y[0])).getTime(); z.label = y[1]; if (!this.showTicks) { z.showLabel = false; z.showMark = false } else if (!this.showTickMarks) { z.showMark = false } z.setTick(z.value, this.name); this._ticks.push(z) } else { z.value = (new a.jsDate(y)).getTime(); if (!this.showTicks) { z.showLabel = false; z.showMark = false } else if (!this.showTickMarks) { z.showMark = false } z.setTick(z.value, this.name); this._ticks.push(z) } } this.numberTicks = d.length; this.min = this._ticks[0].value; this.max = this._ticks[this.numberTicks - 1].value; this.daTickInterval = [(this.max - this.min) / (this.numberTicks - 1) / 1e3, "seconds"] } else if (this.min == null && this.max == null) { var A = a.extend(true, {}, this.tickOptions, { name: this.name, value: null }); var B, C; if (!this.tickInterval && !this.numberTicks) { var D = Math.max(k, t + 1); var E = 115; if (this.tickRenderer === a.jqplot.CanvasAxisTickRenderer && this.tickOptions.angle) { E = 115 - 40 * Math.abs(Math.sin(this.tickOptions.angle / 180 * Math.PI)) } B = Math.ceil((D - t) / E + 1); C = (o - n) / (B - 1) } else if (this.tickInterval) { C = this.tickInterval } else if (this.numberTicks) { B = this.numberTicks; C = (o - n) / (B - 1) } if (C <= 19 * e) { var F = m(n, o, C); var G = F[0]; this._autoFormatString = F[1]; n = Math.floor(n / G) * G; n = new a.jsDate(n); n = n.getTime() + n.getUtcOffset(); B = Math.ceil((o - n) / G) + 1; this.min = n; this.max = n + (B - 1) * G; if (this.max < o) { this.max += G; B += 1 } this.tickInterval = G; this.numberTicks = B; for (var s = 0; s < B; s++) { A.value = this.min + s * G; z = new this.tickRenderer(A); if (this._overrideFormatString && this._autoFormatString != "") { z.formatString = this._autoFormatString } if (!this.showTicks) { z.showLabel = false; z.showMark = false } else if (!this.showTickMarks) { z.showMark = false } this._ticks.push(z) } u = this.tickInterval } else if (C <= 9 * g) { this._autoFormatString = "%v"; var H = Math.round(C / g); if (H < 1) { H = 1 } else if (H > 6) { H = 6 } var I = (new a.jsDate(n)).setDate(1).setHours(0, 0, 0, 0); var J = new a.jsDate(o); var K = (new a.jsDate(o)).setDate(1).setHours(0, 0, 0, 0); if (J.getTime() !== K.getTime()) { K = K.add(1, "month") } var L = K.diff(I, "month"); B = Math.ceil(L / H) + 1; this.min = I.getTime(); this.max = I.clone().add((B - 1) * H, "month").getTime(); this.numberTicks = B; for (var s = 0; s < B; s++) { if (s === 0) { A.value = I.getTime() } else { A.value = I.add(H, "month").getTime() } z = new this.tickRenderer(A); if (this._overrideFormatString && this._autoFormatString != "") { z.formatString = this._autoFormatString } if (!this.showTicks) { z.showLabel = false; z.showMark = false } else if (!this.showTickMarks) { z.showMark = false } this._ticks.push(z) } u = H * g } else { this._autoFormatString = "%v"; var H = Math.round(C / h); if (H < 1) { H = 1 } var I = (new a.jsDate(n)).setMonth(0, 1).setHours(0, 0, 0, 0); var K = (new a.jsDate(o)).add(1, "year").setMonth(0, 1).setHours(0, 0, 0, 0); var M = K.diff(I, "year"); B = Math.ceil(M / H) + 1; this.min = I.getTime(); this.max = I.clone().add((B - 1) * H, "year").getTime(); this.numberTicks = B; for (var s = 0; s < B; s++) { if (s === 0) { A.value = I.getTime() } else { A.value = I.add(H, "year").getTime() } z = new this.tickRenderer(A); if (this._overrideFormatString && this._autoFormatString != "") { z.formatString = this._autoFormatString } if (!this.showTicks) { z.showLabel = false; z.showMark = false } else if (!this.showTickMarks) { z.showMark = false } this._ticks.push(z) } u = H * h } } else { if (f == "xaxis" || f == "x2axis") { k = this._plotDimensions.width } else { k = this._plotDimensions.height } if (this.min != null && this.max != null && this.numberTicks != null) { this.tickInterval = null } if (this.tickInterval != null) { if (Number(this.tickInterval)) { this.daTickInterval = [Number(this.tickInterval), "seconds"] } else if (typeof this.tickInterval == "string") { var N = this.tickInterval.split(" "); if (N.length == 1) { this.daTickInterval = [1, N[0]] } else if (N.length == 2) { this.daTickInterval = [N[0], N[1]] } } } if (n == o) { var O = 24 * 60 * 60 * 500; n -= O; o += O } x = o - n; var P = 2 + parseInt(Math.max(0, k - 100) / 100, 10); var Q, R; Q = this.min != null ? (new a.jsDate(this.min)).getTime() : n - x / 2 * (this.padMin - 1); R = this.max != null ? (new a.jsDate(this.max)).getTime() : o + x / 2 * (this.padMax - 1); this.min = Q; this.max = R; x = this.max - this.min; if (this.numberTicks == null) { if (this.daTickInterval != null) { var S = (new a.jsDate(this.max)).diff(this.min, this.daTickInterval[1], true); this.numberTicks = Math.ceil(S / this.daTickInterval[0]) + 1; this.max = (new a.jsDate(this.min)).add((this.numberTicks - 1) * this.daTickInterval[0], this.daTickInterval[1]).getTime() } else if (k > 200) { this.numberTicks = parseInt(3 + (k - 200) / 100, 10) } else { this.numberTicks = 2 } } u = x / (this.numberTicks - 1) / 1e3; if (this.daTickInterval == null) { this.daTickInterval = [u, "seconds"] } for (var s = 0; s < this.numberTicks; s++) { var n = new a.jsDate(this.min); r = n.add(s * this.daTickInterval[0], this.daTickInterval[1]).getTime(); var z = new this.tickRenderer(this.tickOptions); if (!this.showTicks) { z.showLabel = false; z.showMark = false } else if (!this.showTickMarks) { z.showMark = false } z.setTick(r, this.name); this._ticks.push(z) } } if (this.tickInset) { this.min = this.min - this.tickInset * u; this.max = this.max + this.tickInset * u } if (this._daTickInterval == null) { this._daTickInterval = this.daTickInterval } c = null } })(jQuery); (function (a) { function m() { if (this.plugins.donutRenderer && this.plugins.donutRenderer.highlightCanvas) { this.plugins.donutRenderer.highlightCanvas.resetCanvas(); this.plugins.donutRenderer.highlightCanvas = null } this.plugins.donutRenderer = { highlightedSeriesIndex: null }; this.plugins.donutRenderer.highlightCanvas = new a.jqplot.GenericCanvas; var b = a(this.targetId + " .jqplot-data-label"); if (b.length) { a(b[0]).before(this.plugins.donutRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-donutRenderer-highlight-canvas", this._plotDimensions, this)) } else { this.eventCanvas._elem.before(this.plugins.donutRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-donutRenderer-highlight-canvas", this._plotDimensions, this)) } var c = this.plugins.donutRenderer.highlightCanvas.setContext(); this.eventCanvas._elem.bind("mouseleave", { plot: this }, function (a) { g(a.data.plot) }) } function l(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; var h = e.plugins.donutRenderer.highlightedSeriesIndex; if (h != null && e.series[h].highlightMouseDown) { g(e) } var i = jQuery.Event("jqplotDataRightClick"); i.pageX = a.pageX; i.pageY = a.pageY; e.target.trigger(i, f) } } function k(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; var g = jQuery.Event("jqplotDataClick"); g.pageX = a.pageX; g.pageY = a.pageY; e.target.trigger(g, f) } } function j(a, b, c, d, e) { var f = e.plugins.donutRenderer.highlightedSeriesIndex; if (f != null && e.series[f].highlightMouseDown) { g(e) } } function i(a, b, c, d, e) { if (d) { var h = [d.seriesIndex, d.pointIndex, d.data]; if (e.series[h[0]].highlightMouseDown && !(h[0] == e.plugins.donutRenderer.highlightedSeriesIndex && h[1] == e.series[h[0]]._highlightedPoint)) { var i = jQuery.Event("jqplotDataHighlight"); i.pageX = a.pageX; i.pageY = a.pageY; e.target.trigger(i, h); f(e, h[0], h[1]) } } else if (d == null) { g(e) } } function h(a, b, c, d, e) { if (d) { var h = [d.seriesIndex, d.pointIndex, d.data]; var i = jQuery.Event("jqplotDataMouseOver"); i.pageX = a.pageX; i.pageY = a.pageY; e.target.trigger(i, h); if (e.series[h[0]].highlightMouseOver && !(h[0] == e.plugins.donutRenderer.highlightedSeriesIndex && h[1] == e.series[h[0]]._highlightedPoint)) { var j = jQuery.Event("jqplotDataHighlight"); j.pageX = a.pageX; j.pageY = a.pageY; e.target.trigger(j, h); f(e, h[0], h[1]) } } else if (d == null) { g(e) } } function g(a) { var b = a.plugins.donutRenderer.highlightCanvas; b._ctx.clearRect(0, 0, b._ctx.canvas.width, b._ctx.canvas.height); for (var c = 0; c < a.series.length; c++) { a.series[c]._highlightedPoint = null } a.plugins.donutRenderer.highlightedSeriesIndex = null; a.target.trigger("jqplotDataUnhighlight") } function f(a, b, c) { var d = a.series[b]; var e = a.plugins.donutRenderer.highlightCanvas; e._ctx.clearRect(0, 0, e._ctx.canvas.width, e._ctx.canvas.height); d._highlightedPoint = c; a.plugins.donutRenderer.highlightedSeriesIndex = b; d.renderer.drawSlice.call(d, e._ctx, d._sliceAngles[c][0], d._sliceAngles[c][1], d.highlightColors[c], false) } function e(b) { for (var c = 0; c < this.series.length; c++) { this.series[c].seriesColors = this.seriesColors; this.series[c].colorGenerator = a.jqplot.colorGenerator } } function c(b, c, d) { for (var e = 1; e < this.series.length; e++) { if (!this.series[e]._previousSeries.length) { for (var f = 0; f < e; f++) { if (this.series[e].renderer.constructor == a.jqplot.DonutRenderer && this.series[f].renderer.constructor == a.jqplot.DonutRenderer) { this.series[e]._previousSeries.push(this.series[f]) } } } } for (e = 0; e < this.series.length; e++) { if (this.series[e].renderer.constructor == a.jqplot.DonutRenderer) { this.series[e]._numberSeries = this.series.length; if (this.series[e].highlightMouseOver) { this.series[e].highlightMouseDown = false } } } } function b(b, c, d) { d = d || {}; d.axesDefaults = d.axesDefaults || {}; d.legend = d.legend || {}; d.seriesDefaults = d.seriesDefaults || {}; var e = false; if (d.seriesDefaults.renderer == a.jqplot.DonutRenderer) { e = true } else if (d.series) { for (var f = 0; f < d.series.length; f++) { if (d.series[f].renderer == a.jqplot.DonutRenderer) { e = true } } } if (e) { d.axesDefaults.renderer = a.jqplot.DonutAxisRenderer; d.legend.renderer = a.jqplot.DonutLegendRenderer; d.legend.preDraw = true; d.seriesDefaults.pointLabels = { show: false} } } a.jqplot.DonutRenderer = function () { a.jqplot.LineRenderer.call(this) }; a.jqplot.DonutRenderer.prototype = new a.jqplot.LineRenderer; a.jqplot.DonutRenderer.prototype.constructor = a.jqplot.DonutRenderer; a.jqplot.DonutRenderer.prototype.init = function (b, d) { this.diameter = null; this.innerDiameter = null; this.thickness = null; this.padding = 20; this.sliceMargin = 0; this.ringMargin = null; this.fill = true; this.shadowOffset = 2; this.shadowAlpha = .07; this.shadowDepth = 5; this.highlightMouseOver = true; this.highlightMouseDown = false; this.highlightColors = []; this.dataLabels = "percent"; this.showDataLabels = false; this.dataLabelFormatString = null; this.dataLabelThreshold = 3; this.dataLabelPositionFactor = .4; this.dataLabelNudge = 0; this.startAngle = 0; this.tickRenderer = a.jqplot.DonutTickRenderer; this._drawData = true; this._type = "donut"; if (b.highlightMouseDown && b.highlightMouseOver == null) { b.highlightMouseOver = false } a.extend(true, this, b); if (this.diameter != null) { this.diameter = this.diameter - this.sliceMargin } this._diameter = null; this._innerDiameter = null; this._radius = null; this._innerRadius = null; this._thickness = null; this._previousSeries = []; this._numberSeries = 1; this._sliceAngles = []; this._highlightedPoint = null; if (this.highlightColors.length == 0) { for (var f = 0; f < this.seriesColors.length; f++) { var g = a.jqplot.getColorComponents(this.seriesColors[f]); var n = [g[0], g[1], g[2]]; var o = n[0] + n[1] + n[2]; for (var p = 0; p < 3; p++) { n[p] = o > 570 ? n[p] * .8 : n[p] + .3 * (255 - n[p]); n[p] = parseInt(n[p], 10) } this.highlightColors.push("rgb(" + n[0] + "," + n[1] + "," + n[2] + ")") } } d.postParseOptionsHooks.addOnce(e); d.postInitHooks.addOnce(c); d.eventListenerHooks.addOnce("jqplotMouseMove", h); d.eventListenerHooks.addOnce("jqplotMouseDown", i); d.eventListenerHooks.addOnce("jqplotMouseUp", j); d.eventListenerHooks.addOnce("jqplotClick", k); d.eventListenerHooks.addOnce("jqplotRightClick", l); d.postDrawHooks.addOnce(m) }; a.jqplot.DonutRenderer.prototype.setGridData = function (a) { var b = []; var c = []; var d = this.startAngle / 180 * Math.PI; var e = 0; this._drawData = false; for (var f = 0; f < this.data.length; f++) { if (this.data[f][1] != 0) { this._drawData = true } b.push(this.data[f][1]); c.push([this.data[f][0]]); if (f > 0) { b[f] += b[f - 1] } e += this.data[f][1] } var g = Math.PI * 2 / b[b.length - 1]; for (var f = 0; f < b.length; f++) { c[f][1] = b[f] * g; c[f][2] = this.data[f][1] / e } this.gridData = c }; a.jqplot.DonutRenderer.prototype.makeGridData = function (a, b) { var c = []; var d = []; var e = 0; var f = this.startAngle / 180 * Math.PI; this._drawData = false; for (var g = 0; g < a.length; g++) { if (this.data[g][1] != 0) { this._drawData = true } c.push(a[g][1]); d.push([a[g][0]]); if (g > 0) { c[g] += c[g - 1] } e += a[g][1] } var h = Math.PI * 2 / c[c.length - 1]; for (var g = 0; g < c.length; g++) { d[g][1] = c[g] * h; d[g][2] = a[g][1] / e } return d }; a.jqplot.DonutRenderer.prototype.drawSlice = function (a, b, c, d, e) { function j() { if (c > 6.282 + this.startAngle) { c = 6.282 + this.startAngle; if (b > c) { b = 6.281 + this.startAngle } } if (b >= c) { return } a.beginPath(); a.fillStyle = d; a.strokeStyle = d; a.arc(0, 0, f, b, c, false); a.lineTo(g * Math.cos(c), g * Math.sin(c)); a.arc(0, 0, g, c, b, true); a.closePath(); if (h) { a.fill() } else { a.stroke() } } var f = this._diameter / 2; var g = f - this._thickness; var h = this.fill; a.save(); a.translate(this._center[0], this._center[1]); if (e) { for (var i = 0; i < this.shadowDepth; i++) { a.save(); a.translate(this.shadowOffset * Math.cos(this.shadowAngle / 180 * Math.PI), this.shadowOffset * Math.sin(this.shadowAngle / 180 * Math.PI)); j() } } else { j() } if (e) { for (var i = 0; i < this.shadowDepth; i++) { a.restore() } } a.restore() }; a.jqplot.DonutRenderer.prototype.draw = function (b, c, d, e) { var f; var g = d != undefined ? d : {}; var h = 0; var i = 0; var j = 1; if (d.legendInfo && d.legendInfo.placement == "insideGrid") { var k = d.legendInfo; switch (k.location) { case "nw": h = k.width + k.xoffset; break; case "w": h = k.width + k.xoffset; break; case "sw": h = k.width + k.xoffset; break; case "ne": h = k.width + k.xoffset; j = -1; break; case "e": h = k.width + k.xoffset; j = -1; break; case "se": h = k.width + k.xoffset; j = -1; break; case "n": i = k.height + k.yoffset; break; case "s": i = k.height + k.yoffset; j = -1; break; default: break } } var l = g.shadow != undefined ? g.shadow : this.shadow; var m = g.showLine != undefined ? g.showLine : this.showLine; var n = g.fill != undefined ? g.fill : this.fill; var o = b.canvas.width; var p = b.canvas.height; var q = o - h - 2 * this.padding; var r = p - i - 2 * this.padding; var s = Math.min(q, r); var t = s; var u = this.ringMargin == null ? this.sliceMargin * 2 : this.ringMargin; for (var f = 0; f < this._previousSeries.length; f++) { t -= 2 * this._previousSeries[f]._thickness + 2 * u } this._diameter = this.diameter || t; if (this.innerDiameter != null) { var v = this._numberSeries > 1 && this.index > 0 ? this._previousSeries[0]._diameter : this._diameter; this._thickness = this.thickness || (v - this.innerDiameter - 2 * u * this._numberSeries) / this._numberSeries / 2 } else { this._thickness = this.thickness || s / 2 / (this._numberSeries + 1) * .85 } var w = this._radius = this._diameter / 2; this._innerRadius = this._radius - this._thickness; var x = this.startAngle / 180 * Math.PI; this._center = [(o - j * h) / 2 + j * h, (p - j * i) / 2 + j * i]; if (this.shadow) { var y = "rgba(0,0,0," + this.shadowAlpha + ")"; for (var f = 0; f < c.length; f++) { var z = f == 0 ? x : c[f - 1][1] + x; z += this.sliceMargin / 180 * Math.PI; this.renderer.drawSlice.call(this, b, z, c[f][1] + x, y, true) } } for (var f = 0; f < c.length; f++) { var z = f == 0 ? x : c[f - 1][1] + x; z += this.sliceMargin / 180 * Math.PI; var A = c[f][1] + x; this._sliceAngles.push([z, A]); this.renderer.drawSlice.call(this, b, z, A, this.seriesColors[f], false); if (this.showDataLabels && c[f][2] * 100 >= this.dataLabelThreshold) { var B, C = (z + A) / 2, D; if (this.dataLabels == "label") { B = this.dataLabelFormatString || "%s"; D = a.jqplot.sprintf(B, c[f][0]) } else if (this.dataLabels == "value") { B = this.dataLabelFormatString || "%d"; D = a.jqplot.sprintf(B, this.data[f][1]) } else if (this.dataLabels == "percent") { B = this.dataLabelFormatString || "%d%%"; D = a.jqplot.sprintf(B, c[f][2] * 100) } else if (this.dataLabels.constructor == Array) { B = this.dataLabelFormatString || "%s"; D = a.jqplot.sprintf(B, this.dataLabels[f]) } var E = this._innerRadius + this._thickness * this.dataLabelPositionFactor + this.sliceMargin + this.dataLabelNudge; var F = this._center[0] + Math.cos(C) * E + this.canvas._offsets.left; var G = this._center[1] + Math.sin(C) * E + this.canvas._offsets.top; var H = a('<span class="jqplot-donut-series jqplot-data-label" style="position:absolute;">' + D + "</span>").insertBefore(e.eventCanvas._elem); F -= H.width() / 2; G -= H.height() / 2; F = Math.round(F); G = Math.round(G); H.css({ left: F, top: G }) } } }; a.jqplot.DonutAxisRenderer = function () { a.jqplot.LinearAxisRenderer.call(this) }; a.jqplot.DonutAxisRenderer.prototype = new a.jqplot.LinearAxisRenderer; a.jqplot.DonutAxisRenderer.prototype.constructor = a.jqplot.DonutAxisRenderer; a.jqplot.DonutAxisRenderer.prototype.init = function (b) { this.tickRenderer = a.jqplot.DonutTickRenderer; a.extend(true, this, b); this._dataBounds = { min: 0, max: 100 }; this.min = 0; this.max = 100; this.showTicks = false; this.ticks = []; this.showMark = false; this.show = false }; a.jqplot.DonutLegendRenderer = function () { a.jqplot.TableLegendRenderer.call(this) }; a.jqplot.DonutLegendRenderer.prototype = new a.jqplot.TableLegendRenderer; a.jqplot.DonutLegendRenderer.prototype.constructor = a.jqplot.DonutLegendRenderer; a.jqplot.DonutLegendRenderer.prototype.init = function (b) { this.numberRows = null; this.numberColumns = null; a.extend(true, this, b) }; a.jqplot.DonutLegendRenderer.prototype.draw = function () { var b = this; if (this.show) { var c = this._series; var d = "position:absolute;"; d += this.background ? "background:" + this.background + ";" : ""; d += this.border ? "border:" + this.border + ";" : ""; d += this.fontSize ? "font-size:" + this.fontSize + ";" : ""; d += this.fontFamily ? "font-family:" + this.fontFamily + ";" : ""; d += this.textColor ? "color:" + this.textColor + ";" : ""; d += this.marginTop != null ? "margin-top:" + this.marginTop + ";" : ""; d += this.marginBottom != null ? "margin-bottom:" + this.marginBottom + ";" : ""; d += this.marginLeft != null ? "margin-left:" + this.marginLeft + ";" : ""; d += this.marginRight != null ? "margin-right:" + this.marginRight + ";" : ""; this._elem = a('<table class="jqplot-table-legend" style="' + d + '"></table>'); var e = false, f = false, g, h; var i = c[0]; var j = new a.jqplot.ColorGenerator(i.seriesColors); if (i.show) { var k = i.data; if (this.numberRows) { g = this.numberRows; if (!this.numberColumns) { h = Math.ceil(k.length / g) } else { h = this.numberColumns } } else if (this.numberColumns) { h = this.numberColumns; g = Math.ceil(k.length / this.numberColumns) } else { g = k.length; h = 1 } var l, m, n, o, p, q, r, s; var t = 0; for (l = 0; l < g; l++) { if (f) { n = a('<tr class="jqplot-table-legend"></tr>').prependTo(this._elem) } else { n = a('<tr class="jqplot-table-legend"></tr>').appendTo(this._elem) } for (m = 0; m < h; m++) { if (t < k.length) { q = this.labels[t] || k[t][0].toString(); s = j.next(); if (!f) { if (l > 0) { e = true } else { e = false } } else { if (l == g - 1) { e = false } else { e = true } } r = e ? this.rowSpacing : "0"; o = a('<td class="jqplot-table-legend" style="text-align:center;padding-top:' + r + ';">' + '<div><div class="jqplot-table-legend-swatch" style="border-color:' + s + ';"></div>' + "</div></td>"); p = a('<td class="jqplot-table-legend" style="padding-top:' + r + ';"></td>'); if (this.escapeHtml) { p.text(q) } else { p.html(q) } if (f) { p.prependTo(n); o.prependTo(n) } else { o.appendTo(n); p.appendTo(n) } e = true } t++ } } } } return this._elem }; var d = false; a.jqplot.preInitHooks.push(b); a.jqplot.DonutTickRenderer = function () { a.jqplot.AxisTickRenderer.call(this) }; a.jqplot.DonutTickRenderer.prototype = new a.jqplot.AxisTickRenderer; a.jqplot.DonutTickRenderer.prototype.constructor = a.jqplot.DonutTickRenderer })(jQuery); (function (a) { function f(a, b, c, d, e) { if (e.plugins.dragable.dragCanvas.isDragging) { var f = e.plugins.dragable.dragCanvas; var g = f._ctx; g.clearRect(0, 0, g.canvas.width, g.canvas.height); f.isDragging = false; var h = f._neighbor; var i = e.series[h.seriesIndex]; var j = i.plugins.dragable; var k = j.constrainTo == "y" ? h.data[0] : c[i.xaxis]; var l = j.constrainTo == "x" ? h.data[1] : c[i.yaxis]; i.data[h.pointIndex][0] = k; i.data[h.pointIndex][1] = l; e.drawSeries({ preventJqPlotSeriesDrawTrigger: true }, h.seriesIndex); f._neighbor = null; a.target.style.cursor = f._cursors.pop(); e.target.trigger("jqplotDragStop", [b, c]) } } function e(a, b, d, e, f) { var g = f.plugins.dragable.dragCanvas; g._cursors.push(a.target.style.cursor); if (e != null) { var h = f.series[e.seriesIndex]; var i = h.plugins.dragable; if (h.isDragable && !g.isDragging) { g._neighbor = e; g.isDragging = true; c(f, e); i.markerRenderer.draw(h.gridData[e.pointIndex][0], h.gridData[e.pointIndex][1], g._ctx); a.target.style.cursor = "move"; f.target.trigger("jqplotDragStart", [e.seriesIndex, e.pointIndex, b, d]) } } else { var j = g._ctx; j.clearRect(0, 0, j.canvas.width, j.canvas.height); g.isDragging = false } } function d(a, b, c, d, e) { if (e.plugins.dragable.dragCanvas.isDragging) { var f = e.plugins.dragable.dragCanvas; var g = f._neighbor; var h = e.series[g.seriesIndex]; var i = h.plugins.dragable; var j = h.gridData; var k = i.constrainTo == "y" ? g.gridData[0] : b.x; var l = i.constrainTo == "x" ? g.gridData[1] : b.y; var m = h._xaxis.series_p2u(k); var n = h._yaxis.series_p2u(l); var o = f._ctx; o.clearRect(0, 0, o.canvas.width, o.canvas.height); if (g.pointIndex > 0) { i._gridData[1] = [k, l] } else { i._gridData[0] = [k, l] } e.series[g.seriesIndex].draw(f._ctx, { gridData: i._gridData, shadow: false, preventJqPlotSeriesDrawTrigger: true, color: i.color, markerOptions: { color: i.color, shadow: false }, trendline: { show: false} }); e.target.trigger("jqplotSeriesPointChange", [g.seriesIndex, g.pointIndex, [m, n], [k, l]]) } else if (d != null) { var p = e.series[d.seriesIndex]; if (p.isDragable) { var f = e.plugins.dragable.dragCanvas; if (!f.isOver) { f._cursors.push(a.target.style.cursor); a.target.style.cursor = "pointer" } f.isOver = true } } else if (d == null) { var f = e.plugins.dragable.dragCanvas; if (f.isOver) { a.target.style.cursor = f._cursors.pop(); f.isOver = false } } } function c(b, c) { var d = b.series[c.seriesIndex]; var e = d.plugins.dragable; var f = d.markerRenderer; var g = e.markerRenderer; g.style = f.style; g.lineWidth = f.lineWidth + 2.5; g.size = f.size + 5; if (!e.color) { var h = a.jqplot.getColorComponents(f.color); var i = [h[0], h[1], h[2]]; var j = h[3] >= .6 ? h[3] * .6 : h[3] * (2 - h[3]); e.color = "rgba(" + i[0] + "," + i[1] + "," + i[2] + "," + j + ")" } g.color = e.color; g.init(); var k = c.pointIndex > 0 ? c.pointIndex - 1 : 0; var l = c.pointIndex + 2; e._gridData = d.gridData.slice(k, l) } function b() { a.jqplot.GenericCanvas.call(this); this.isDragging = false; this.isOver = false; this._neighbor; this._cursors = [] } a.jqplot.Dragable = function (b) { this.markerRenderer = new a.jqplot.MarkerRenderer({ shadow: false }); this.shapeRenderer = new a.jqplot.ShapeRenderer; this.isDragging = false; this.isOver = false; this._ctx; this._elem; this._point; this._gridData; this.color; this.constrainTo = "none"; a.extend(true, this, b) }; b.prototype = new a.jqplot.GenericCanvas; b.prototype.constructor = b; a.jqplot.Dragable.parseOptions = function (b, c) { var d = c || {}; this.plugins.dragable = new a.jqplot.Dragable(d.dragable); this.isDragable = a.jqplot.config.enablePlugins }; a.jqplot.Dragable.postPlotDraw = function () { if (this.plugins.dragable && this.plugins.dragable.highlightCanvas) { this.plugins.dragable.highlightCanvas.resetCanvas(); this.plugins.dragable.highlightCanvas = null } this.plugins.dragable = { previousCursor: "auto", isOver: false }; this.plugins.dragable.dragCanvas = new b; this.eventCanvas._elem.before(this.plugins.dragable.dragCanvas.createElement(this._gridPadding, "jqplot-dragable-canvas", this._plotDimensions, this)); var a = this.plugins.dragable.dragCanvas.setContext() }; a.jqplot.preParseSeriesOptionsHooks.push(a.jqplot.Dragable.parseOptions); a.jqplot.postDrawHooks.push(a.jqplot.Dragable.postPlotDraw); a.jqplot.eventListenerHooks.push(["jqplotMouseMove", d]); a.jqplot.eventListenerHooks.push(["jqplotMouseDown", e]); a.jqplot.eventListenerHooks.push(["jqplotMouseUp", f]) })(jQuery); (function (a) { a.jqplot.EnhancedLegendRenderer = function () { a.jqplot.TableLegendRenderer.call(this) }; a.jqplot.EnhancedLegendRenderer.prototype = new a.jqplot.TableLegendRenderer; a.jqplot.EnhancedLegendRenderer.prototype.constructor = a.jqplot.EnhancedLegendRenderer; a.jqplot.EnhancedLegendRenderer.prototype.init = function (b) { this.numberRows = null; this.numberColumns = null; this.seriesToggle = "normal"; this.disableIEFading = true; a.extend(true, this, b); if (this.seriesToggle) { a.jqplot.postDrawHooks.push(c) } }; a.jqplot.EnhancedLegendRenderer.prototype.draw = function () { var c = this; if (this.show) { var d = this._series; var e; var f = "position:absolute;"; f += this.background ? "background:" + this.background + ";" : ""; f += this.border ? "border:" + this.border + ";" : ""; f += this.fontSize ? "font-size:" + this.fontSize + ";" : ""; f += this.fontFamily ? "font-family:" + this.fontFamily + ";" : ""; f += this.textColor ? "color:" + this.textColor + ";" : ""; f += this.marginTop != null ? "margin-top:" + this.marginTop + ";" : ""; f += this.marginBottom != null ? "margin-bottom:" + this.marginBottom + ";" : ""; f += this.marginLeft != null ? "margin-left:" + this.marginLeft + ";" : ""; f += this.marginRight != null ? "margin-right:" + this.marginRight + ";" : ""; this._elem = a('<table class="jqplot-table-legend" style="' + f + '"></table>'); if (this.seriesToggle) { this._elem.css("z-index", "3") } var g = false, h = false, i, j; if (this.numberRows) { i = this.numberRows; if (!this.numberColumns) { j = Math.ceil(d.length / i) } else { j = this.numberColumns } } else if (this.numberColumns) { j = this.numberColumns; i = Math.ceil(d.length / this.numberColumns) } else { i = d.length; j = 1 } var k, l, m, n, o, p, q, r, s, t; var u = 0; for (k = d.length - 1; k >= 0; k--) { if (j == 1 && d[k]._stack || d[k].renderer.constructor == a.jqplot.BezierCurveRenderer) { h = true } } for (k = 0; k < i; k++) { m = a(document.createElement("tr")); m.addClass("jqplot-table-legend"); if (h) { m.prependTo(this._elem) } else { m.appendTo(this._elem) } for (l = 0; l < j; l++) { if (u < d.length && d[u].show && d[u].showLabel) { e = d[u]; p = this.labels[u] || e.label.toString(); if (p) { var v = e.color; if (!h) { if (k > 0) { g = true } else { g = false } } else { if (k == i - 1) { g = false } else { g = true } } q = g ? this.rowSpacing : "0"; n = a(document.createElement("td")); n.addClass("jqplot-table-legend jqplot-table-legend-swatch"); n.css({ textAlign: "center", paddingTop: q }); s = a(document.createElement("div")); s.addClass("jqplot-table-legend-swatch-outline"); t = a(document.createElement("div")); t.addClass("jqplot-table-legend-swatch"); t.css({ backgroundColor: v, borderColor: v }); n.append(s.append(t)); o = a(document.createElement("td")); o.addClass("jqplot-table-legend jqplot-table-legend-label"); o.css("paddingTop", q); if (this.escapeHtml) { o.text(p) } else { o.html(p) } if (h) { if (this.showLabels) { o.prependTo(m) } if (this.showSwatches) { n.prependTo(m) } } else { if (this.showSwatches) { n.appendTo(m) } if (this.showLabels) { o.appendTo(m) } } if (this.seriesToggle) { var w; if (typeof this.seriesToggle == "string" || typeof this.seriesToggle == "number") { if (!a.jqplot.use_excanvas || !this.disableIEFading) { w = this.seriesToggle } } if (this.showSwatches) { n.bind("click", { series: e, speed: w }, b); n.addClass("jqplot-seriesToggle") } if (this.showLabels) { o.bind("click", { series: e, speed: w }, b); o.addClass("jqplot-seriesToggle") } } g = true } } u++ } n = o = s = t = null } } return this._elem }; var b = function (b) { b.data.series.toggleDisplay(b); if (b.data.series.canvas._elem.hasClass("jqplot-series-hidden")) { a(this).addClass("jqplot-series-hidden"); a(this).next(".jqplot-table-legend-label").addClass("jqplot-series-hidden"); a(this).prev(".jqplot-table-legend-swatch").addClass("jqplot-series-hidden") } else { a(this).removeClass("jqplot-series-hidden"); a(this).next(".jqplot-table-legend-label").removeClass("jqplot-series-hidden"); a(this).prev(".jqplot-table-legend-swatch").removeClass("jqplot-series-hidden") } }; var c = function () { if (this.legend.renderer.constructor == a.jqplot.EnhancedLegendRenderer && this.legend.seriesToggle) { var b = this.legend._elem.detach(); this.eventCanvas._elem.after(b) } } })(jQuery); (function (a) { function l() { if (this.plugins.funnelRenderer && this.plugins.funnelRenderer.highlightCanvas) { this.plugins.funnelRenderer.highlightCanvas.resetCanvas(); this.plugins.funnelRenderer.highlightCanvas = null } this.plugins.funnelRenderer = {}; this.plugins.funnelRenderer.highlightCanvas = new a.jqplot.GenericCanvas; var b = a(this.targetId + " .jqplot-data-label"); if (b.length) { a(b[0]).before(this.plugins.funnelRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-funnelRenderer-highlight-canvas", this._plotDimensions, this)) } else { this.eventCanvas._elem.before(this.plugins.funnelRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-funnelRenderer-highlight-canvas", this._plotDimensions, this)) } var c = this.plugins.funnelRenderer.highlightCanvas.setContext(); this.eventCanvas._elem.bind("mouseleave", { plot: this }, function (a) { f(a.data.plot) }) } function k(a, b, c, d, e) { if (d) { var g = [d.seriesIndex, d.pointIndex, d.data]; var h = e.plugins.funnelRenderer.highlightedSeriesIndex; if (h != null && e.series[h].highlightMouseDown) { f(e) } var i = jQuery.Event("jqplotDataRightClick"); i.pageX = a.pageX; i.pageY = a.pageY; e.target.trigger(i, g) } } function j(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; var g = jQuery.Event("jqplotDataClick"); g.pageX = a.pageX; g.pageY = a.pageY; e.target.trigger(g, f) } } function i(a, b, c, d, e) { var g = e.plugins.funnelRenderer.highlightedSeriesIndex; if (g != null && e.series[g].highlightMouseDown) { f(e) } } function h(a, b, c, d, g) { if (d) { var h = [d.seriesIndex, d.pointIndex, d.data]; if (g.series[h[0]].highlightMouseDown && !(h[0] == g.plugins.funnelRenderer.highlightedSeriesIndex && h[1] == g.series[h[0]]._highlightedPoint)) { var i = jQuery.Event("jqplotDataHighlight"); i.pageX = a.pageX; i.pageY = a.pageY; g.target.trigger(i, h); e(g, h[0], h[1]) } } else if (d == null) { f(g) } } function g(a, b, c, d, g) { if (d) { var h = [d.seriesIndex, d.pointIndex, d.data]; var i = jQuery.Event("jqplotDataMouseOver"); i.pageX = a.pageX; i.pageY = a.pageY; g.target.trigger(i, h); if (g.series[h[0]].highlightMouseOver && !(h[0] == g.plugins.funnelRenderer.highlightedSeriesIndex && h[1] == g.series[h[0]]._highlightedPoint)) { var j = jQuery.Event("jqplotDataHighlight"); j.pageX = a.pageX; j.pageY = a.pageY; g.target.trigger(j, h); e(g, h[0], h[1]) } } else if (d == null) { f(g) } } function f(a) { var b = a.plugins.funnelRenderer.highlightCanvas; b._ctx.clearRect(0, 0, b._ctx.canvas.width, b._ctx.canvas.height); for (var c = 0; c < a.series.length; c++) { a.series[c]._highlightedPoint = null } a.plugins.funnelRenderer.highlightedSeriesIndex = null; a.target.trigger("jqplotDataUnhighlight") } function e(a, b, c) { var d = a.series[b]; var e = a.plugins.funnelRenderer.highlightCanvas; e._ctx.clearRect(0, 0, e._ctx.canvas.width, e._ctx.canvas.height); d._highlightedPoint = c; a.plugins.funnelRenderer.highlightedSeriesIndex = b; d.renderer.drawSection.call(d, e._ctx, d._vertices[c], d.highlightColors[c], false) } function d(b) { for (var c = 0; c < this.series.length; c++) { this.series[c].seriesColors = this.seriesColors; this.series[c].colorGenerator = a.jqplot.colorGenerator } } function c(b, c, d) { for (var e = 0; e < this.series.length; e++) { if (this.series[e].renderer.constructor == a.jqplot.FunnelRenderer) { if (this.series[e].highlightMouseOver) { this.series[e].highlightMouseDown = false } } } } function b(b, c, d) { d = d || {}; d.axesDefaults = d.axesDefaults || {}; d.legend = d.legend || {}; d.seriesDefaults = d.seriesDefaults || {}; var e = false; if (d.seriesDefaults.renderer == a.jqplot.FunnelRenderer) { e = true } else if (d.series) { for (var f = 0; f < d.series.length; f++) { if (d.series[f].renderer == a.jqplot.FunnelRenderer) { e = true } } } if (e) { d.axesDefaults.renderer = a.jqplot.FunnelAxisRenderer; d.legend.renderer = a.jqplot.FunnelLegendRenderer; d.legend.preDraw = true; d.sortData = false; d.seriesDefaults.pointLabels = { show: false} } } a.jqplot.FunnelRenderer = function () { a.jqplot.LineRenderer.call(this) }; a.jqplot.FunnelRenderer.prototype = new a.jqplot.LineRenderer; a.jqplot.FunnelRenderer.prototype.constructor = a.jqplot.FunnelRenderer; a.jqplot.FunnelRenderer.prototype.init = function (b, e) { this.padding = { top: 20, right: 20, bottom: 20, left: 20 }; this.sectionMargin = 6; this.fill = true; this.shadowOffset = 2; this.shadowAlpha = .07; this.shadowDepth = 5; this.highlightMouseOver = true; this.highlightMouseDown = false; this.highlightColors = []; this.widthRatio = .2; this.lineWidth = 2; this.dataLabels = "percent"; this.showDataLabels = false; this.dataLabelFormatString = null; this.dataLabelThreshold = 3; this._type = "funnel"; this.tickRenderer = a.jqplot.FunnelTickRenderer; if (b.highlightMouseDown && b.highlightMouseOver == null) { b.highlightMouseOver = false } a.extend(true, this, b); this._highlightedPoint = null; this._bases = []; this._atot; this._areas = []; this._lengths = []; this._angle; this._dataIndices = []; this._unorderedData = a.extend(true, [], this.data); var f = a.extend(true, [], this.data); for (var m = 0; m < f.length; m++) { f[m].push(m) } this.data.sort(function (a, b) { return b[1] - a[1] }); f.sort(function (a, b) { return b[1] - a[1] }); for (var m = 0; m < f.length; m++) { this._dataIndices.push(f[m][2]) } if (this.highlightColors.length == 0) { for (var m = 0; m < this.seriesColors.length; m++) { var n = a.jqplot.getColorComponents(this.seriesColors[m]); var o = [n[0], n[1], n[2]]; var p = o[0] + o[1] + o[2]; for (var q = 0; q < 3; q++) { o[q] = p > 570 ? o[q] * .8 : o[q] + .4 * (255 - o[q]); o[q] = parseInt(o[q], 10) } this.highlightColors.push("rgb(" + o[0] + "," + o[1] + "," + o[2] + ")") } } e.postParseOptionsHooks.addOnce(d); e.postInitHooks.addOnce(c); e.eventListenerHooks.addOnce("jqplotMouseMove", g); e.eventListenerHooks.addOnce("jqplotMouseDown", h); e.eventListenerHooks.addOnce("jqplotMouseUp", i); e.eventListenerHooks.addOnce("jqplotClick", j); e.eventListenerHooks.addOnce("jqplotRightClick", k); e.postDrawHooks.addOnce(l) }; a.jqplot.FunnelRenderer.prototype.setGridData = function (a) { var b = 0; var c = []; for (var d = 0; d < this.data.length; d++) { b += this.data[d][1]; c.push([this.data[d][0], this.data[d][1]]) } for (var d = 0; d < c.length; d++) { c[d][1] = c[d][1] / b } this._bases = new Array(c.length + 1); this._lengths = new Array(c.length); this.gridData = c }; a.jqplot.FunnelRenderer.prototype.makeGridData = function (a, b) { var c = 0; var d = []; for (var e = 0; e < this.data.length; e++) { c += this.data[e][1]; d.push([this.data[e][0], this.data[e][1]]) } for (var e = 0; e < d.length; e++) { d[e][1] = d[e][1] / c } this._bases = new Array(d.length + 1); this._lengths = new Array(d.length); return d }; a.jqplot.FunnelRenderer.prototype.drawSection = function (a, b, c, d) { function h() { a.beginPath(); a.fillStyle = c; a.strokeStyle = c; a.lineWidth = f; a.moveTo(b[0][0], b[0][1]); for (var d = 1; d < 4; d++) { a.lineTo(b[d][0], b[d][1]) } a.closePath(); if (e) { a.fill() } else { a.stroke() } } var e = this.fill; var f = this.lineWidth; a.save(); if (d) { for (var g = 0; g < this.shadowDepth; g++) { a.save(); a.translate(this.shadowOffset * Math.cos(this.shadowAngle / 180 * Math.PI), this.shadowOffset * Math.sin(this.shadowAngle / 180 * Math.PI)); h() } } else { h() } if (d) { for (var g = 0; g < this.shadowDepth; g++) { a.restore() } } a.restore() }; a.jqplot.FunnelRenderer.prototype.draw = function (b, c, d, e) { function G(a) { var b = (C[1] - E[1]) / (C[0] - E[0]); var c = C[1] - b * C[0]; var d = a + C[1]; return [(d - c) / b, d] } function F(a) { var b = (B[1] - D[1]) / (B[0] - D[0]); var c = B[1] - b * B[0]; var d = a + B[1]; return [(d - c) / b, d] } var f; var g = d != undefined ? d : {}; var h = 0; var i = 0; var j = 1; this._areas = []; if (d.legendInfo && d.legendInfo.placement == "insideGrid") { var k = d.legendInfo; switch (k.location) { case "nw": h = k.width + k.xoffset; break; case "w": h = k.width + k.xoffset; break; case "sw": h = k.width + k.xoffset; break; case "ne": h = k.width + k.xoffset; j = -1; break; case "e": h = k.width + k.xoffset; j = -1; break; case "se": h = k.width + k.xoffset; j = -1; break; case "n": i = k.height + k.yoffset; break; case "s": i = k.height + k.yoffset; j = -1; break; default: break } } var l = j == 1 ? this.padding.left + h : this.padding.left; var m = j == 1 ? this.padding.top + i : this.padding.top; var n = j == -1 ? this.padding.right + h : this.padding.right; var o = j == -1 ? this.padding.bottom + i : this.padding.bottom; var p = g.shadow != undefined ? g.shadow : this.shadow; var q = g.showLine != undefined ? g.showLine : this.showLine; var r = g.fill != undefined ? g.fill : this.fill; var s = b.canvas.width; var t = b.canvas.height; this._bases[0] = s - l - n; var u = this._length = t - m - o; var v = this._bases[0] * this.widthRatio; this._atot = u / 2 * (this._bases[0] + this._bases[0] * this.widthRatio); this._angle = Math.atan((this._bases[0] - v) / 2 / u); for (f = 0; f < c.length; f++) { this._areas.push(c[f][1] * this._atot) } var w, x, y, z = 0; var A = 1e-4; for (f = 0; f < this._areas.length; f++) { w = this._areas[f] / this._bases[f]; x = 999999; this._lengths[f] = w; y = 0; while (x > this._lengths[f] * A && y < 100) { this._lengths[f] = this._areas[f] / (this._bases[f] - this._lengths[f] * Math.tan(this._angle)); x = Math.abs(this._lengths[f] - w); this._bases[f + 1] = this._bases[f] - 2 * this._lengths[f] * Math.tan(this._angle); w = this._lengths[f]; y++ } z += this._lengths[f] } this._vertices = new Array(c.length); var B = [l, m], C = [l + this._bases[0], m], D = [l + (this._bases[0] - this._bases[this._bases.length - 1]) / 2, m + this._length], E = [D[0] + this._bases[this._bases.length - 1], D[1]]; var H = h, I = i; var J = 0, K = 0; for (f = 0; f < c.length; f++) { this._vertices[f] = new Array; var L = this._vertices[f]; var M = this.sectionMargin; if (f == 0) { K = 0 } if (f == 1) { K = M / 3 } else if (f > 0 && f < c.length - 1) { K = M / 2 } else if (f == c.length - 1) { K = 2 * M / 3 } L.push(F(J + K)); L.push(G(J + K)); J += this._lengths[f]; if (f == 0) { K = -2 * M / 3 } else if (f > 0 && f < c.length - 1) { K = -M / 2 } else if (f == c.length - 1) { K = 0 } L.push(G(J + K)); L.push(F(J + K)) } if (this.shadow) { var N = "rgba(0,0,0," + this.shadowAlpha + ")"; for (var f = 0; f < c.length; f++) { this.renderer.drawSection.call(this, b, this._vertices[f], N, true) } } for (var f = 0; f < c.length; f++) { var L = this._vertices[f]; this.renderer.drawSection.call(this, b, L, this.seriesColors[f]); if (this.showDataLabels && c[f][1] * 100 >= this.dataLabelThreshold) { var O, P; if (this.dataLabels == "label") { O = this.dataLabelFormatString || "%s"; P = a.jqplot.sprintf(O, c[f][0]) } else if (this.dataLabels == "value") { O = this.dataLabelFormatString || "%d"; P = a.jqplot.sprintf(O, this.data[f][1]) } else if (this.dataLabels == "percent") { O = this.dataLabelFormatString || "%d%%"; P = a.jqplot.sprintf(O, c[f][1] * 100) } else if (this.dataLabels.constructor == Array) { O = this.dataLabelFormatString || "%s"; P = a.jqplot.sprintf(O, this.dataLabels[this._dataIndices[f]]) } var Q = this._radius * this.dataLabelPositionFactor + this.sliceMargin + this.dataLabelNudge; var H = (L[0][0] + L[1][0]) / 2 + this.canvas._offsets.left; var I = (L[1][1] + L[2][1]) / 2 + this.canvas._offsets.top; var R = a('<span class="jqplot-funnel-series jqplot-data-label" style="position:absolute;">' + P + "</span>").insertBefore(e.eventCanvas._elem); H -= R.width() / 2; I -= R.height() / 2; H = Math.round(H); I = Math.round(I); R.css({ left: H, top: I }) } } }; a.jqplot.FunnelAxisRenderer = function () { a.jqplot.LinearAxisRenderer.call(this) }; a.jqplot.FunnelAxisRenderer.prototype = new a.jqplot.LinearAxisRenderer; a.jqplot.FunnelAxisRenderer.prototype.constructor = a.jqplot.FunnelAxisRenderer; a.jqplot.FunnelAxisRenderer.prototype.init = function (b) { this.tickRenderer = a.jqplot.FunnelTickRenderer; a.extend(true, this, b); this._dataBounds = { min: 0, max: 100 }; this.min = 0; this.max = 100; this.showTicks = false; this.ticks = []; this.showMark = false; this.show = false }; a.jqplot.FunnelLegendRenderer = function () { a.jqplot.TableLegendRenderer.call(this) }; a.jqplot.FunnelLegendRenderer.prototype = new a.jqplot.TableLegendRenderer; a.jqplot.FunnelLegendRenderer.prototype.constructor = a.jqplot.FunnelLegendRenderer; a.jqplot.FunnelLegendRenderer.prototype.init = function (b) { this.numberRows = null; this.numberColumns = null; a.extend(true, this, b) }; a.jqplot.FunnelLegendRenderer.prototype.draw = function () { var b = this; if (this.show) { var c = this._series; var d = "position:absolute;"; d += this.background ? "background:" + this.background + ";" : ""; d += this.border ? "border:" + this.border + ";" : ""; d += this.fontSize ? "font-size:" + this.fontSize + ";" : ""; d += this.fontFamily ? "font-family:" + this.fontFamily + ";" : ""; d += this.textColor ? "color:" + this.textColor + ";" : ""; d += this.marginTop != null ? "margin-top:" + this.marginTop + ";" : ""; d += this.marginBottom != null ? "margin-bottom:" + this.marginBottom + ";" : ""; d += this.marginLeft != null ? "margin-left:" + this.marginLeft + ";" : ""; d += this.marginRight != null ? "margin-right:" + this.marginRight + ";" : ""; this._elem = a('<table class="jqplot-table-legend" style="' + d + '"></table>'); var e = false, f = false, g, h; var i = c[0]; var j = new a.jqplot.ColorGenerator(i.seriesColors); if (i.show) { var k = i.data; if (this.numberRows) { g = this.numberRows; if (!this.numberColumns) { h = Math.ceil(k.length / g) } else { h = this.numberColumns } } else if (this.numberColumns) { h = this.numberColumns; g = Math.ceil(k.length / this.numberColumns) } else { g = k.length; h = 1 } var l, m, n, o, p, q, r, s; var t = 0; for (l = 0; l < g; l++) { if (f) { n = a('<tr class="jqplot-table-legend"></tr>').prependTo(this._elem) } else { n = a('<tr class="jqplot-table-legend"></tr>').appendTo(this._elem) } for (m = 0; m < h; m++) { if (t < k.length) { q = this.labels[t] || k[t][0].toString(); s = j.next(); if (!f) { if (l > 0) { e = true } else { e = false } } else { if (l == g - 1) { e = false } else { e = true } } r = e ? this.rowSpacing : "0"; o = a('<td class="jqplot-table-legend" style="text-align:center;padding-top:' + r + ';">' + '<div><div class="jqplot-table-legend-swatch" style="border-color:' + s + ';"></div>' + "</div></td>"); p = a('<td class="jqplot-table-legend" style="padding-top:' + r + ';"></td>'); if (this.escapeHtml) { p.text(q) } else { p.html(q) } if (f) { p.prependTo(n); o.prependTo(n) } else { o.appendTo(n); p.appendTo(n) } e = true } t++ } } } } return this._elem }; a.jqplot.preInitHooks.push(b); a.jqplot.FunnelTickRenderer = function () { a.jqplot.AxisTickRenderer.call(this) }; a.jqplot.FunnelTickRenderer.prototype = new a.jqplot.AxisTickRenderer; a.jqplot.FunnelTickRenderer.prototype.constructor = a.jqplot.FunnelTickRenderer })(jQuery); (function (a) { function g(a, b, c, d, g) { var h = g.plugins.highlighter; var i = g.plugins.cursor; if (h.show) { if (d == null && h.isHighlighting) { var j = h.highlightCanvas._ctx; j.clearRect(0, 0, j.canvas.width, j.canvas.height); if (h.fadeTooltip) { h._tooltipElem.fadeOut(h.tooltipFadeSpeed) } else { h._tooltipElem.hide() } if (h.bringSeriesToFront) { g.restorePreviousSeriesOrder() } h.isHighlighting = false; h.currentNeighbor = null; j = null } else if (d != null && g.series[d.seriesIndex].showHighlight && !h.isHighlighting) { h.isHighlighting = true; h.currentNeighbor = d; if (h.showMarker) { e(g, d) } if (h.showTooltip && (!i || !i._zoom.started)) { f(g, g.series[d.seriesIndex], d) } if (h.bringSeriesToFront) { g.moveSeriesToFront(d.seriesIndex) } } else if (d != null && h.isHighlighting && h.currentNeighbor != d) { if (g.series[d.seriesIndex].showHighlight) { var j = h.highlightCanvas._ctx; j.clearRect(0, 0, j.canvas.width, j.canvas.height); h.isHighlighting = true; h.currentNeighbor = d; if (h.showMarker) { e(g, d) } if (h.showTooltip && (!i || !i._zoom.started)) { f(g, g.series[d.seriesIndex], d) } if (h.bringSeriesToFront) { g.moveSeriesToFront(d.seriesIndex) } } } } } function f(e, f, g) { var h = e.plugins.highlighter; var i = h._tooltipElem; var j = f.highlighter || {}; var k = a.extend(true, {}, h, j); if (k.useAxesFormatters) { var l = f._xaxis._ticks[0].formatter; var m = f._yaxis._ticks[0].formatter; var n = f._xaxis._ticks[0].formatString; var o = f._yaxis._ticks[0].formatString; var p; var q = l(n, g.data[0]); var r = []; for (var s = 1; s < k.yvalues + 1; s++) { r.push(m(o, g.data[s])) } if (typeof k.formatString === "string") { switch (k.tooltipAxes) { case "both": case "xy": r.unshift(q); r.unshift(k.formatString); p = a.jqplot.sprintf.apply(a.jqplot.sprintf, r); break; case "yx": r.push(q); r.unshift(k.formatString); p = a.jqplot.sprintf.apply(a.jqplot.sprintf, r); break; case "x": p = a.jqplot.sprintf.apply(a.jqplot.sprintf, [k.formatString, q]); break; case "y": r.unshift(k.formatString); p = a.jqplot.sprintf.apply(a.jqplot.sprintf, r); break; default: r.unshift(q); r.unshift(k.formatString); p = a.jqplot.sprintf.apply(a.jqplot.sprintf, r); break } } else { switch (k.tooltipAxes) { case "both": case "xy": p = q; for (var s = 0; s < r.length; s++) { p += k.tooltipSeparator + r[s] } break; case "yx": p = ""; for (var s = 0; s < r.length; s++) { p += r[s] + k.tooltipSeparator } p += q; break; case "x": p = q; break; case "y": p = r.join(k.tooltipSeparator); break; default: p = q; for (var s = 0; s < r.length; s++) { p += k.tooltipSeparator + r[s] } break } } } else { var p; if (typeof k.formatString === "string") { p = a.jqplot.sprintf.apply(a.jqplot.sprintf, [k.formatString].concat(g.data)) } else { if (k.tooltipAxes == "both" || k.tooltipAxes == "xy") { p = a.jqplot.sprintf(k.tooltipFormatString, g.data[0]) + k.tooltipSeparator + a.jqplot.sprintf(k.tooltipFormatString, g.data[1]) } else if (k.tooltipAxes == "yx") { p = a.jqplot.sprintf(k.tooltipFormatString, g.data[1]) + k.tooltipSeparator + a.jqplot.sprintf(k.tooltipFormatString, g.data[0]) } else if (k.tooltipAxes == "x") { p = a.jqplot.sprintf(k.tooltipFormatString, g.data[0]) } else if (k.tooltipAxes == "y") { p = a.jqplot.sprintf(k.tooltipFormatString, g.data[1]) } } } if (a.isFunction(k.tooltipContentEditor)) { p = k.tooltipContentEditor(p, g.seriesIndex, g.pointIndex, e) } i.html(p); var t = { x: g.gridData[0], y: g.gridData[1] }; var u = 0; var v = .707; if (f.markerRenderer.show == true) { u = (f.markerRenderer.size + k.sizeAdjust) / 2 } var w = b; if (f.fillToZero && f.fill && g.data[1] < 0) { w = d } switch (w[c[k.tooltipLocation]]) { case "nw": var x = t.x + e._gridPadding.left - i.outerWidth(true) - k.tooltipOffset - v * u; var y = t.y + e._gridPadding.top - k.tooltipOffset - i.outerHeight(true) - v * u; break; case "n": var x = t.x + e._gridPadding.left - i.outerWidth(true) / 2; var y = t.y + e._gridPadding.top - k.tooltipOffset - i.outerHeight(true) - u; break; case "ne": var x = t.x + e._gridPadding.left + k.tooltipOffset + v * u; var y = t.y + e._gridPadding.top - k.tooltipOffset - i.outerHeight(true) - v * u; break; case "e": var x = t.x + e._gridPadding.left + k.tooltipOffset + u; var y = t.y + e._gridPadding.top - i.outerHeight(true) / 2; break; case "se": var x = t.x + e._gridPadding.left + k.tooltipOffset + v * u; var y = t.y + e._gridPadding.top + k.tooltipOffset + v * u; break; case "s": var x = t.x + e._gridPadding.left - i.outerWidth(true) / 2; var y = t.y + e._gridPadding.top + k.tooltipOffset + u; break; case "sw": var x = t.x + e._gridPadding.left - i.outerWidth(true) - k.tooltipOffset - v * u; var y = t.y + e._gridPadding.top + k.tooltipOffset + v * u; break; case "w": var x = t.x + e._gridPadding.left - i.outerWidth(true) - k.tooltipOffset - u; var y = t.y + e._gridPadding.top - i.outerHeight(true) / 2; break; default: var x = t.x + e._gridPadding.left - i.outerWidth(true) - k.tooltipOffset - v * u; var y = t.y + e._gridPadding.top - k.tooltipOffset - i.outerHeight(true) - v * u; break } i.css("left", x); i.css("top", y); if (k.fadeTooltip) { i.stop(true, true).fadeIn(k.tooltipFadeSpeed) } else { i.show() } i = null } function e(b, c) { var d = b.plugins.highlighter; var e = b.series[c.seriesIndex]; var f = e.markerRenderer; var g = d.markerRenderer; g.style = f.style; g.lineWidth = f.lineWidth + d.lineWidthAdjust; g.size = f.size + d.sizeAdjust; var h = a.jqplot.getColorComponents(f.color); var i = [h[0], h[1], h[2]]; var j = h[3] >= .6 ? h[3] * .6 : h[3] * (2 - h[3]); g.color = "rgba(" + i[0] + "," + i[1] + "," + i[2] + "," + j + ")"; g.init(); g.draw(e.gridData[c.pointIndex][0], e.gridData[c.pointIndex][1], d.highlightCanvas._ctx) } a.jqplot.eventListenerHooks.push(["jqplotMouseMove", g]); a.jqplot.Highlighter = function (b) { this.show = a.jqplot.config.enablePlugins; this.markerRenderer = new a.jqplot.MarkerRenderer({ shadow: false }); this.showMarker = true; this.lineWidthAdjust = 2.5; this.sizeAdjust = 5; this.showTooltip = true; this.tooltipLocation = "nw"; this.fadeTooltip = true; this.tooltipFadeSpeed = "fast"; this.tooltipOffset = 2; this.tooltipAxes = "both"; this.tooltipSeparator = ", "; this.tooltipContentEditor = null; this.useAxesFormatters = true; this.tooltipFormatString = "%.5P"; this.formatString = null; this.yvalues = 1; this.bringSeriesToFront = false; this._tooltipElem; this.isHighlighting = false; this.currentNeighbor = null; a.extend(true, this, b) }; var b = ["nw", "n", "ne", "e", "se", "s", "sw", "w"]; var c = { nw: 0, n: 1, ne: 2, e: 3, se: 4, s: 5, sw: 6, w: 7 }; var d = ["se", "s", "sw", "w", "nw", "n", "ne", "e"]; a.jqplot.Highlighter.init = function (b, c, d) { var e = d || {}; this.plugins.highlighter = new a.jqplot.Highlighter(e.highlighter) }; a.jqplot.Highlighter.parseOptions = function (a, b) { this.showHighlight = true }; a.jqplot.Highlighter.postPlotDraw = function () { if (this.plugins.highlighter && this.plugins.highlighter.highlightCanvas) { this.plugins.highlighter.highlightCanvas.resetCanvas(); this.plugins.highlighter.highlightCanvas = null } if (this.plugins.highlighter && this.plugins.highlighter._tooltipElem) { this.plugins.highlighter._tooltipElem.emptyForce(); this.plugins.highlighter._tooltipElem = null } this.plugins.highlighter.highlightCanvas = new a.jqplot.GenericCanvas; this.eventCanvas._elem.before(this.plugins.highlighter.highlightCanvas.createElement(this._gridPadding, "jqplot-highlight-canvas", this._plotDimensions, this)); this.plugins.highlighter.highlightCanvas.setContext(); var b = document.createElement("div"); this.plugins.highlighter._tooltipElem = a(b); b = null; this.plugins.highlighter._tooltipElem.addClass("jqplot-highlighter-tooltip"); this.plugins.highlighter._tooltipElem.css({ position: "absolute", display: "none" }); this.eventCanvas._elem.before(this.plugins.highlighter._tooltipElem) }; a.jqplot.preInitHooks.push(a.jqplot.Highlighter.init); a.jqplot.preParseSeriesOptionsHooks.push(a.jqplot.Highlighter.parseOptions); a.jqplot.postDrawHooks.push(a.jqplot.Highlighter.postPlotDraw) })(jQuery); (function (a) { a.jqplot.LogAxisRenderer = function () { a.jqplot.LinearAxisRenderer.call(this); this.axisDefaults = { base: 10, tickDistribution: "power"} }; a.jqplot.LogAxisRenderer.prototype = new a.jqplot.LinearAxisRenderer; a.jqplot.LogAxisRenderer.prototype.constructor = a.jqplot.LogAxisRenderer; a.jqplot.LogAxisRenderer.prototype.init = function (b) { this.drawBaseline = true; this.minorTicks = "auto"; this._scalefact = 1; a.extend(true, this, b); this._autoFormatString = "%d"; this._overrideFormatString = false; for (var c in this.renderer.axisDefaults) { if (this[c] == null) { this[c] = this.renderer.axisDefaults[c] } } this.resetDataBounds() }; a.jqplot.LogAxisRenderer.prototype.createTicks = function (b) { var c = this._ticks; var d = this.ticks; var e = this.name; var f = this._dataBounds; var g = this.name.charAt(0) === "x" ? this._plotDimensions.width : this._plotDimensions.height; var h; var i, j; var k, l; var m, n; var o = 30; this._scalefact = (Math.max(g, o + 1) - o) / 300; if (d.length) { for (n = 0; n < d.length; n++) { var p = d[n]; var q = new this.tickRenderer(this.tickOptions); if (p.constructor == Array) { q.value = p[0]; q.label = p[1]; if (!this.showTicks) { q.showLabel = false; q.showMark = false } else if (!this.showTickMarks) { q.showMark = false } q.setTick(p[0], this.name); this._ticks.push(q) } else if (a.isPlainObject(p)) { a.extend(true, q, p); q.axis = this.name; this._ticks.push(q) } else { q.value = p; if (!this.showTicks) { q.showLabel = false; q.showMark = false } else if (!this.showTickMarks) { q.showMark = false } q.setTick(p, this.name); this._ticks.push(q) } } this.numberTicks = d.length; this.min = this._ticks[0].value; this.max = this._ticks[this.numberTicks - 1].value } else if (this.min == null && this.max == null) { i = f.min * (2 - this.padMin); j = f.max * this.padMax; if (i == j) { var r = .05; i = i * (1 - r); j = j * (1 + r) } if (this.min != null && this.min <= 0) { throw "log axis minimum must be greater than 0" } if (this.max != null && this.max <= 0) { throw "log axis maximum must be greater than 0" } function s(a) { var b = Math.pow(10, Math.floor(Math.log(a) / Math.LN10)); return Math.ceil(a / b) * b } function t(a) { var b = Math.pow(10, Math.floor(Math.log(a) / Math.LN10)); return Math.floor(a / b) * b } var u, v; u = Math.pow(this.base, Math.floor(Math.log(i) / Math.log(this.base))); v = Math.pow(this.base, Math.ceil(Math.log(j) / Math.log(this.base))); var w = Math.round(Math.log(u) / Math.LN10); if (this.tickOptions == null || !this.tickOptions.formatString) { this._overrideFormatString = true } this.min = u; this.max = v; var x = this.max - this.min; var y = this.minorTicks === "auto" ? 0 : this.minorTicks; var z; if (this.numberTicks == null) { if (g > 140) { z = Math.round(Math.log(this.max / this.min) / Math.log(this.base) + 1); if (z < 2) { z = 2 } if (y === 0) { var A = g / (z - 1); if (A < 100) { y = 0 } else if (A < 190) { y = 1 } else if (A < 250) { y = 3 } else if (A < 600) { y = 4 } else { y = 9 } } } else { z = 2; if (y === 0) { y = 1 } y = 0 } } else { z = this.numberTicks } if (w >= 0 && y !== 3) { this._autoFormatString = "%d" } else if (w <= 0 && y === 3) { var A = -(w - 1); this._autoFormatString = "%." + Math.abs(w - 1) + "f" } else if (w < 0) { var A = -w; this._autoFormatString = "%." + Math.abs(w) + "f" } else { this._autoFormatString = "%d" } var B, q, C, D, E, h; for (var n = 0; n < z; n++) { m = Math.pow(this.base, n - z + 1) * this.max; q = new this.tickRenderer(this.tickOptions); if (this._overrideFormatString) { q.formatString = this._autoFormatString } if (!this.showTicks) { q.showLabel = false; q.showMark = false } else if (!this.showTickMarks) { q.showMark = false } q.setTick(m, this.name); this._ticks.push(q); if (y && n < z - 1) { D = Math.pow(this.base, n - z + 2) * this.max; E = D - m; h = D / (y + 1); for (var F = y - 1; F >= 0; F--) { C = D - h * (F + 1); q = new this.tickRenderer(this.tickOptions); if (this._overrideFormatString && this._autoFormatString != "") { q.formatString = this._autoFormatString } if (!this.showTicks) { q.showLabel = false; q.showMark = false } else if (!this.showTickMarks) { q.showMark = false } q.setTick(C, this.name); this._ticks.push(q) } } } } else if (this.min != null && this.max != null) { var G = a.extend(true, {}, this.tickOptions, { name: this.name, value: null }); var H, I; if (this.numberTicks == null && this.tickInterval == null) { var J = Math.max(g, o + 1); var K = Math.ceil((J - o) / 35 + 1); var L = a.jqplot.LinearTickGenerator.bestConstrainedInterval(this.min, this.max, K); this._autoFormatString = L[3]; H = L[2]; I = L[4]; for (var n = 0; n < H; n++) { G.value = this.min + n * I; q = new this.tickRenderer(G); if (this._overrideFormatString && this._autoFormatString != "") { q.formatString = this._autoFormatString } if (!this.showTicks) { q.showLabel = false; q.showMark = false } else if (!this.showTickMarks) { q.showMark = false } this._ticks.push(q) } } else if (this.numberTicks != null && this.tickInterval != null) { H = this.numberTicks; for (var n = 0; n < H; n++) { G.value = this.min + n * this.tickInterval; q = new this.tickRenderer(G); if (this._overrideFormatString && this._autoFormatString != "") { q.formatString = this._autoFormatString } if (!this.showTicks) { q.showLabel = false; q.showMark = false } else if (!this.showTickMarks) { q.showMark = false } this._ticks.push(q) } } } }; a.jqplot.LogAxisRenderer.prototype.pack = function (b, c) { var d = parseInt(this.base, 10); var e = this._ticks; var f = function (a) { return Math.log(a) / Math.log(d) }; var g = function (a) { return Math.pow(Math.E, Math.log(d) * a) }; var h = f(this.max); var i = f(this.min); var j = c.max; var k = c.min; var l = this._label == null ? false : this._label.show; for (var m in b) { this._elem.css(m, b[m]) } this._offsets = c; var n = j - k; var o = h - i; this.p2u = function (a) { return g((a - k) * o / n + i) }; this.u2p = function (a) { return (f(a) - i) * n / o + k }; if (this.name == "xaxis" || this.name == "x2axis") { this.series_u2p = function (a) { return (f(a) - i) * n / o }; this.series_p2u = function (a) { return g(a * o / n + i) } } else { this.series_u2p = function (a) { return (f(a) - h) * n / o }; this.series_p2u = function (a) { return g(a * o / n + h) } } if (this.show) { if (this.name == "xaxis" || this.name == "x2axis") { for (var p = 0; p < e.length; p++) { var q = e[p]; if (q.show && q.showLabel) { var r; if (q.constructor == a.jqplot.CanvasAxisTickRenderer && q.angle) { switch (q.labelPosition) { case "auto": if (q.angle < 0) { r = -q.getWidth() + q._textRenderer.height * Math.sin(-q._textRenderer.angle) / 2 } else { r = -q._textRenderer.height * Math.sin(q._textRenderer.angle) / 2 } break; case "end": r = -q.getWidth() + q._textRenderer.height * Math.sin(-q._textRenderer.angle) / 2; break; case "start": r = -q._textRenderer.height * Math.sin(q._textRenderer.angle) / 2; break; case "middle": r = -q.getWidth() / 2 + q._textRenderer.height * Math.sin(-q._textRenderer.angle) / 2; break; default: r = -q.getWidth() / 2 + q._textRenderer.height * Math.sin(-q._textRenderer.angle) / 2; break } } else { r = -q.getWidth() / 2 } var s = this.u2p(q.value) + r + "px"; q._elem.css("left", s); q.pack() } } if (l) { var t = this._label._elem.outerWidth(true); this._label._elem.css("left", k + n / 2 - t / 2 + "px"); if (this.name == "xaxis") { this._label._elem.css("bottom", "0px") } else { this._label._elem.css("top", "0px") } this._label.pack() } } else { for (var p = 0; p < e.length; p++) { var q = e[p]; if (q.show && q.showLabel) { var r; if (q.constructor == a.jqplot.CanvasAxisTickRenderer && q.angle) { switch (q.labelPosition) { case "auto": case "end": if (q.angle < 0) { r = -q._textRenderer.height * Math.cos(-q._textRenderer.angle) / 2 } else { r = -q.getHeight() + q._textRenderer.height * Math.cos(q._textRenderer.angle) / 2 } break; case "start": if (q.angle > 0) { r = -q._textRenderer.height * Math.cos(-q._textRenderer.angle) / 2 } else { r = -q.getHeight() + q._textRenderer.height * Math.cos(q._textRenderer.angle) / 2 } break; case "middle": r = -q.getHeight() / 2; break; default: r = -q.getHeight() / 2; break } } else { r = -q.getHeight() / 2 } var s = this.u2p(q.value) + r + "px"; q._elem.css("top", s); q.pack() } } if (l) { var u = this._label._elem.outerHeight(true); this._label._elem.css("top", j - n / 2 - u / 2 + "px"); if (this.name == "yaxis") { this._label._elem.css("left", "0px") } else { this._label._elem.css("right", "0px") } this._label.pack() } } } } })(jQuery); (function (a) { a.jqplot.MekkoAxisRenderer = function () { }; a.jqplot.MekkoAxisRenderer.prototype.init = function (b) { this.tickMode; this.barLabelRenderer = a.jqplot.AxisLabelRenderer; this.barLabels = this.barLabels || []; this.barLabelOptions = {}; this.tickOptions = a.extend(true, { showGridline: false }, this.tickOptions); this._barLabels = []; a.extend(true, this, b); if (this.name == "yaxis") { this.tickOptions.formatString = this.tickOptions.formatString || "%d%" } var c = this._dataBounds; c.min = 0; if (this.name == "yaxis" || this.name == "y2axis") { c.max = 100; this.tickMode = "even" } else if (this.name == "xaxis") { this.tickMode = this.tickMode == null ? "bar" : this.tickMode; for (var d = 0; d < this._series.length; d++) { c.max += this._series[d]._sumy } } else if (this.name == "x2axis") { this.tickMode = this.tickMode == null ? "even" : this.tickMode; for (var d = 0; d < this._series.length; d++) { c.max += this._series[d]._sumy } } }; a.jqplot.MekkoAxisRenderer.prototype.draw = function (b, c) { if (this.show) { this.renderer.createTicks.call(this); var d = 0; var e; var f = document.createElement("div"); this._elem = a(f); this._elem.addClass("jqplot-axis jqplot-" + this.name); this._elem.css("position", "absolute"); f = null; if (this.name == "xaxis" || this.name == "x2axis") { this._elem.width(this._plotDimensions.width) } else { this._elem.height(this._plotDimensions.height) } this.labelOptions.axis = this.name; this._label = new this.labelRenderer(this.labelOptions); if (this._label.show) { this._elem.append(this._label.draw(b)) } var g, h, f; if (this.showTicks) { g = this._ticks; for (var i = 0; i < g.length; i++) { h = g[i]; if (h.showLabel && (!h.isMinorTick || this.showMinorTicks)) { this._elem.append(h.draw(b)) } } } for (i = 0; i < this.barLabels.length; i++) { this.barLabelOptions.axis = this.name; this.barLabelOptions.label = this.barLabels[i]; this._barLabels.push(new this.barLabelRenderer(this.barLabelOptions)); if (this.tickMode != "bar") { this._barLabels[i].show = false } if (this._barLabels[i].show) { var f = this._barLabels[i].draw(b, c); f.removeClass("jqplot-" + this.name + "-label"); f.addClass("jqplot-" + this.name + "-tick"); f.addClass("jqplot-mekko-barLabel"); f.appendTo(this._elem); f = null } } } return this._elem }; a.jqplot.MekkoAxisRenderer.prototype.reset = function () { this.min = this._min; this.max = this._max; this.tickInterval = this._tickInterval; this.numberTicks = this._numberTicks }; a.jqplot.MekkoAxisRenderer.prototype.set = function () { var b = 0; var c; var d = 0; var e = 0; var f = this._label == null ? false : this._label.show; if (this.show && this.showTicks) { var g = this._ticks; for (var h = 0; h < g.length; h++) { var i = g[h]; if (i.showLabel && (!i.isMinorTick || this.showMinorTicks)) { if (this.name == "xaxis" || this.name == "x2axis") { c = i._elem.outerHeight(true) } else { c = i._elem.outerWidth(true) } if (c > b) { b = c } } } if (f) { d = this._label._elem.outerWidth(true); e = this._label._elem.outerHeight(true) } if (this.name == "xaxis") { b = b + e; this._elem.css({ height: b + "px", left: "0px", bottom: "0px" }) } else if (this.name == "x2axis") { b = b + e; this._elem.css({ height: b + "px", left: "0px", top: "0px" }) } else if (this.name == "yaxis") { b = b + d; this._elem.css({ width: b + "px", left: "0px", top: "0px" }); if (f && this._label.constructor == a.jqplot.AxisLabelRenderer) { this._label._elem.css("width", d + "px") } } else { b = b + d; this._elem.css({ width: b + "px", right: "0px", top: "0px" }); if (f && this._label.constructor == a.jqplot.AxisLabelRenderer) { this._label._elem.css("width", d + "px") } } } }; a.jqplot.MekkoAxisRenderer.prototype.createTicks = function () { var a = this._ticks; var b = this.ticks; var c = this.name; var d = this._dataBounds; var e, f; var g, h; var i, j; var k, l, m, n; if (b.length) { for (m = 0; m < b.length; m++) { var o = b[m]; var k = new this.tickRenderer(this.tickOptions); if (o.constructor == Array) { k.value = o[0]; k.label = o[1]; if (!this.showTicks) { k.showLabel = false; k.showMark = false } else if (!this.showTickMarks) { k.showMark = false } k.setTick(o[0], this.name); this._ticks.push(k) } else { k.value = o; if (!this.showTicks) { k.showLabel = false; k.showMark = false } else if (!this.showTickMarks) { k.showMark = false } k.setTick(o, this.name); this._ticks.push(k) } } this.numberTicks = b.length; this.min = this._ticks[0].value; this.max = this._ticks[this.numberTicks - 1].value; this.tickInterval = (this.max - this.min) / (this.numberTicks - 1) } else { if (c == "xaxis" || c == "x2axis") { e = this._plotDimensions.width } else { e = this._plotDimensions.height } if (this.min != null && this.max != null && this.numberTicks != null) { this.tickInterval = null } g = this.min != null ? this.min : d.min; h = this.max != null ? this.max : d.max; if (g == h) { var p = .05; if (g > 0) { p = Math.max(Math.log(g) / Math.LN10, .05) } g -= p; h += p } var q = h - g; var r, s; var t, u, v; var w = [3, 5, 6, 11, 21]; if (this.name == "yaxis" || this.name == "y2axis") { this.min = 0; this.max = 100; if (!this.numberTicks) { if (this.tickInterval) { this.numberTicks = 3 + Math.ceil(q / this.tickInterval) } else { t = 2 + Math.ceil((e - (this.tickSpacing - 1)) / this.tickSpacing); for (m = 0; m < w.length; m++) { v = t / w[m]; if (v == 1) { this.numberTicks = w[m]; break } else if (v > 1) { u = v; continue } else if (v < 1) { if (Math.abs(u - 1) < Math.abs(v - 1)) { this.numberTicks = w[m - 1]; break } else { this.numberTicks = w[m]; break } } else if (m == w.length - 1) { this.numberTicks = w[m] } } this.tickInterval = q / (this.numberTicks - 1) } } else { this.tickInterval = q / (this.numberTicks - 1) } for (var m = 0; m < this.numberTicks; m++) { l = this.min + m * this.tickInterval; k = new this.tickRenderer(this.tickOptions); if (!this.showTicks) { k.showLabel = false; k.showMark = false } else if (!this.showTickMarks) { k.showMark = false } k.setTick(l, this.name); this._ticks.push(k) } } else if (this.tickMode == "bar") { this.min = 0; this.numberTicks = this._series.length + 1; k = new this.tickRenderer(this.tickOptions); if (!this.showTicks) { k.showLabel = false; k.showMark = false } else if (!this.showTickMarks) { k.showMark = false } k.setTick(0, this.name); this._ticks.push(k); t = 0; for (m = 1; m < this.numberTicks; m++) { t += this._series[m - 1]._sumy; k = new this.tickRenderer(this.tickOptions); if (!this.showTicks) { k.showLabel = false; k.showMark = false } else if (!this.showTickMarks) { k.showMark = false } k.setTick(t, this.name); this._ticks.push(k) } this.max = this.max || t; if (this.max > t) { k = new this.tickRenderer(this.tickOptions); if (!this.showTicks) { k.showLabel = false; k.showMark = false } else if (!this.showTickMarks) { k.showMark = false } k.setTick(this.max, this.name); this._ticks.push(k) } } else if (this.tickMode == "even") { this.min = 0; this.max = this.max || d.max; var x = 2 + Math.ceil((e - (this.tickSpacing - 1)) / this.tickSpacing); q = this.max - this.min; this.numberTicks = x; this.tickInterval = q / (this.numberTicks - 1); for (m = 0; m < this.numberTicks; m++) { l = this.min + m * this.tickInterval; k = new this.tickRenderer(this.tickOptions); if (!this.showTicks) { k.showLabel = false; k.showMark = false } else if (!this.showTickMarks) { k.showMark = false } k.setTick(l, this.name); this._ticks.push(k) } } } }; a.jqplot.MekkoAxisRenderer.prototype.pack = function (b, c) { var d = this._ticks; var e = this.max; var f = this.min; var g = c.max; var h = c.min; var i = this._label == null ? false : this._label.show; for (var j in b) { this._elem.css(j, b[j]) } this._offsets = c; var k = g - h; var l = e - f; this.p2u = function (a) { return (a - h) * l / k + f }; this.u2p = function (a) { return (a - f) * k / l + h }; if (this.name == "xaxis" || this.name == "x2axis") { this.series_u2p = function (a) { return (a - f) * k / l }; this.series_p2u = function (a) { return a * l / k + f } } else { this.series_u2p = function (a) { return (a - e) * k / l }; this.series_p2u = function (a) { return a * l / k + e } } if (this.show) { if (this.name == "xaxis" || this.name == "x2axis") { for (var m = 0; m < d.length; m++) { var n = d[m]; if (n.show && n.showLabel) { var o; if (n.constructor == a.jqplot.CanvasAxisTickRenderer && n.angle) { var p = this.name == "xaxis" ? 1 : -1; switch (n.labelPosition) { case "auto": if (p * n.angle < 0) { o = -n.getWidth() + n._textRenderer.height * Math.sin(-n._textRenderer.angle) / 2 } else { o = -n._textRenderer.height * Math.sin(n._textRenderer.angle) / 2 } break; case "end": o = -n.getWidth() + n._textRenderer.height * Math.sin(-n._textRenderer.angle) / 2; break; case "start": o = -n._textRenderer.height * Math.sin(n._textRenderer.angle) / 2; break; case "middle": o = -n.getWidth() / 2 + n._textRenderer.height * Math.sin(-n._textRenderer.angle) / 2; break; default: o = -n.getWidth() / 2 + n._textRenderer.height * Math.sin(-n._textRenderer.angle) / 2; break } } else { o = -n.getWidth() / 2 } var q = this.u2p(n.value) + o + "px"; n._elem.css("left", q); n.pack() } } var r; if (i) { r = this._label._elem.outerWidth(true); this._label._elem.css("left", h + k / 2 - r / 2 + "px"); if (this.name == "xaxis") { this._label._elem.css("bottom", "0px") } else { this._label._elem.css("top", "0px") } this._label.pack() } var s, t, u; for (var m = 0; m < this.barLabels.length; m++) { s = this._barLabels[m]; if (s.show) { r = s.getWidth(); t = this._ticks[m].getLeft() + this._ticks[m].getWidth(); u = this._ticks[m + 1].getLeft(); s._elem.css("left", (u + t - r) / 2 + "px"); s._elem.css("top", this._ticks[m]._elem.css("top")); s.pack() } } } else { for (var m = 0; m < d.length; m++) { var n = d[m]; if (n.show && n.showLabel) { var o; if (n.constructor == a.jqplot.CanvasAxisTickRenderer && n.angle) { var p = this.name == "yaxis" ? 1 : -1; switch (n.labelPosition) { case "auto": case "end": if (p * n.angle < 0) { o = -n._textRenderer.height * Math.cos(-n._textRenderer.angle) / 2 } else { o = -n.getHeight() + n._textRenderer.height * Math.cos(n._textRenderer.angle) / 2 } break; case "start": if (n.angle > 0) { o = -n._textRenderer.height * Math.cos(-n._textRenderer.angle) / 2 } else { o = -n.getHeight() + n._textRenderer.height * Math.cos(n._textRenderer.angle) / 2 } break; case "middle": o = -n.getHeight() / 2; break; default: o = -n.getHeight() / 2; break } } else { o = -n.getHeight() / 2 } var q = this.u2p(n.value) + o + "px"; n._elem.css("top", q); n.pack() } } if (i) { var v = this._label._elem.outerHeight(true); this._label._elem.css("top", g - k / 2 - v / 2 + "px"); if (this.name == "yaxis") { this._label._elem.css("left", "0px") } else { this._label._elem.css("right", "0px") } this._label.pack() } } } } })(jQuery); (function (a) { function b(b, c, d) { d = d || {}; d.axesDefaults = d.axesDefaults || {}; d.legend = d.legend || {}; d.seriesDefaults = d.seriesDefaults || {}; var e = false; if (d.seriesDefaults.renderer == a.jqplot.MekkoRenderer) { e = true } else if (d.series) { for (var f = 0; f < d.series.length; f++) { if (d.series[f].renderer == a.jqplot.MekkoRenderer) { e = true } } } if (e) { d.axesDefaults.renderer = a.jqplot.MekkoAxisRenderer; d.legend.renderer = a.jqplot.MekkoLegendRenderer; d.legend.preDraw = true } } a.jqplot.MekkoRenderer = function () { this.shapeRenderer = new a.jqplot.ShapeRenderer; this.borderColor = null; this.showBorders = true }; a.jqplot.MekkoRenderer.prototype.init = function (b, c) { this.fill = false; this.fillRect = true; this.strokeRect = true; this.shadow = false; this._xwidth = 0; this._xstart = 0; a.extend(true, this.renderer, b); var d = { lineJoin: "miter", lineCap: "butt", isarc: false, fillRect: this.fillRect, strokeRect: this.strokeRect }; this.renderer.shapeRenderer.init(d); c.axes.x2axis._series.push(this); this._type = "mekko" }; a.jqplot.MekkoRenderer.prototype.setGridData = function (a) { var b = this._xaxis.series_u2p; var c = this._yaxis.series_u2p; var d = this._plotData; this.gridData = []; this._xwidth = b(this._sumy) - b(0); if (this.index > 0) { this._xstart = a.series[this.index - 1]._xstart + a.series[this.index - 1]._xwidth } var e = this.canvas.getHeight(); var f = 0; var g; var h; for (var i = 0; i < d.length; i++) { if (d[i] != null) { f += d[i][1]; g = e - f / this._sumy * e; h = d[i][1] / this._sumy * e; this.gridData.push([this._xstart, g, this._xwidth, h]) } } }; a.jqplot.MekkoRenderer.prototype.makeGridData = function (a, b) { var c = this._xaxis.series_u2p; var d = this.canvas.getHeight(); var e = 0; var f; var g; var h = []; for (var i = 0; i < a.length; i++) { if (a[i] != null) { e += a[i][1]; f = d - e / this._sumy * d; g = a[i][1] / this._sumy * d; h.push([this._xstart, f, this._xwidth, g]) } } return h }; a.jqplot.MekkoRenderer.prototype.draw = function (b, c, d) { var e; var f = d != undefined ? d : {}; var g = f.showLine != undefined ? f.showLine : this.showLine; var h = new a.jqplot.ColorGenerator(this.seriesColors); b.save(); if (c.length) { if (g) { for (e = 0; e < c.length; e++) { f.fillStyle = h.next(); if (this.renderer.showBorders) { f.strokeStyle = this.renderer.borderColor } else { f.strokeStyle = f.fillStyle } this.renderer.shapeRenderer.draw(b, c[e], f) } } } b.restore() }; a.jqplot.MekkoRenderer.prototype.drawShadow = function (a, b, c) { }; a.jqplot.MekkoLegendRenderer = function () { }; a.jqplot.MekkoLegendRenderer.prototype.init = function (b) { this.numberRows = null; this.numberColumns = null; this.placement = "outside"; a.extend(true, this, b) }; a.jqplot.MekkoLegendRenderer.prototype.draw = function () { var b = this; if (this.show) { var c = this._series; var d = "position:absolute;"; d += this.background ? "background:" + this.background + ";" : ""; d += this.border ? "border:" + this.border + ";" : ""; d += this.fontSize ? "font-size:" + this.fontSize + ";" : ""; d += this.fontFamily ? "font-family:" + this.fontFamily + ";" : ""; d += this.textColor ? "color:" + this.textColor + ";" : ""; this._elem = a('<table class="jqplot-table-legend" style="' + d + '"></table>'); var e = false, f = true, g, h; var i = c[0]; var j = new a.jqplot.ColorGenerator(i.seriesColors); if (i.show) { var k = i.data; if (this.numberRows) { g = this.numberRows; if (!this.numberColumns) { h = Math.ceil(k.length / g) } else { h = this.numberColumns } } else if (this.numberColumns) { h = this.numberColumns; g = Math.ceil(k.length / this.numberColumns) } else { g = k.length; h = 1 } var l, m, n, o, p, q, r, s; var t = 0; for (l = 0; l < g; l++) { if (f) { n = a('<tr class="jqplot-table-legend"></tr>').prependTo(this._elem) } else { n = a('<tr class="jqplot-table-legend"></tr>').appendTo(this._elem) } for (m = 0; m < h; m++) { if (t < k.length) { q = this.labels[t] || k[t][0].toString(); s = j.next(); if (!f) { if (l > 0) { e = true } else { e = false } } else { if (l == g - 1) { e = false } else { e = true } } r = e ? this.rowSpacing : "0"; o = a('<td class="jqplot-table-legend" style="text-align:center;padding-top:' + r + ';">' + '<div><div class="jqplot-table-legend-swatch" style="border-color:' + s + ';"></div>' + "</div></td>"); p = a('<td class="jqplot-table-legend" style="padding-top:' + r + ';"></td>'); if (this.escapeHtml) { p.text(q) } else { p.html(q) } if (f) { p.prependTo(n); o.prependTo(n) } else { o.appendTo(n); p.appendTo(n) } e = true } t++ } } n = null; o = null; p = null } } return this._elem }; a.jqplot.MekkoLegendRenderer.prototype.pack = function (a) { if (this.show) { var b = { _top: a.top, _left: a.left, _right: a.right, _bottom: this._plotDimensions.height - a.bottom }; if (this.placement == "insideGrid") { switch (this.location) { case "nw": var c = b._left + this.xoffset; var d = b._top + this.yoffset; this._elem.css("left", c); this._elem.css("top", d); break; case "n": var c = (a.left + (this._plotDimensions.width - a.right)) / 2 - this.getWidth() / 2; var d = b._top + this.yoffset; this._elem.css("left", c); this._elem.css("top", d); break; case "ne": var c = a.right + this.xoffset; var d = b._top + this.yoffset; this._elem.css({ right: c, top: d }); break; case "e": var c = a.right + this.xoffset; var d = (a.top + (this._plotDimensions.height - a.bottom)) / 2 - this.getHeight() / 2; this._elem.css({ right: c, top: d }); break; case "se": var c = a.right + this.xoffset; var d = a.bottom + this.yoffset; this._elem.css({ right: c, bottom: d }); break; case "s": var c = (a.left + (this._plotDimensions.width - a.right)) / 2 - this.getWidth() / 2; var d = a.bottom + this.yoffset; this._elem.css({ left: c, bottom: d }); break; case "sw": var c = b._left + this.xoffset; var d = a.bottom + this.yoffset; this._elem.css({ left: c, bottom: d }); break; case "w": var c = b._left + this.xoffset; var d = (a.top + (this._plotDimensions.height - a.bottom)) / 2 - this.getHeight() / 2; this._elem.css({ left: c, top: d }); break; default: var c = b._right - this.xoffset; var d = b._bottom + this.yoffset; this._elem.css({ right: c, bottom: d }); break } } else { switch (this.location) { case "nw": var c = this._plotDimensions.width - b._left + this.xoffset; var d = b._top + this.yoffset; this._elem.css("right", c); this._elem.css("top", d); break; case "n": var c = (a.left + (this._plotDimensions.width - a.right)) / 2 - this.getWidth() / 2; var d = this._plotDimensions.height - b._top + this.yoffset; this._elem.css("left", c); this._elem.css("bottom", d); break; case "ne": var c = this._plotDimensions.width - a.right + this.xoffset; var d = b._top + this.yoffset; this._elem.css({ left: c, top: d }); break; case "e": var c = this._plotDimensions.width - a.right + this.xoffset; var d = (a.top + (this._plotDimensions.height - a.bottom)) / 2 - this.getHeight() / 2; this._elem.css({ left: c, top: d }); break; case "se": var c = this._plotDimensions.width - a.right + this.xoffset; var d = a.bottom + this.yoffset; this._elem.css({ left: c, bottom: d }); break; case "s": var c = (a.left + (this._plotDimensions.width - a.right)) / 2 - this.getWidth() / 2; var d = this._plotDimensions.height - a.bottom + this.yoffset; this._elem.css({ left: c, top: d }); break; case "sw": var c = this._plotDimensions.width - b._left + this.xoffset; var d = a.bottom + this.yoffset; this._elem.css({ right: c, bottom: d }); break; case "w": var c = this._plotDimensions.width - b._left + this.xoffset; var d = (a.top + (this._plotDimensions.height - a.bottom)) / 2 - this.getHeight() / 2; this._elem.css({ right: c, top: d }); break; default: var c = b._right - this.xoffset; var d = b._bottom + this.yoffset; this._elem.css({ right: c, bottom: d }); break } } } }; a.jqplot.preInitHooks.push(b) })(jQuery); (function (a) { function d(a) { } function c(b, c, d) { d = d || {}; d.axesDefaults = d.axesDefaults || {}; d.legend = d.legend || {}; d.seriesDefaults = d.seriesDefaults || {}; d.grid = d.grid || {}; var e = false; if (d.seriesDefaults.renderer == a.jqplot.MeterGaugeRenderer) { e = true } else if (d.series) { for (var f = 0; f < d.series.length; f++) { if (d.series[f].renderer == a.jqplot.MeterGaugeRenderer) { e = true } } } if (e) { d.axesDefaults.renderer = a.jqplot.MeterGaugeAxisRenderer; d.legend.renderer = a.jqplot.MeterGaugeLegendRenderer; d.legend.preDraw = true; d.grid.background = d.grid.background || "white"; d.grid.drawGridlines = false; d.grid.borderWidth = d.grid.borderWidth != null ? d.grid.borderWidth : 0; d.grid.shadow = d.grid.shadow != null ? d.grid.shadow : false } } function b(a, b, c) { var d; for (var e = a.length - 1; e >= 0; e--) { d = b / (a[e] * Math.pow(10, c)); if (d == 4 || d == 5) { return d - 1 } } return null } a.jqplot.MeterGaugeRenderer = function () { a.jqplot.LineRenderer.call(this) }; a.jqplot.MeterGaugeRenderer.prototype = new a.jqplot.LineRenderer; a.jqplot.MeterGaugeRenderer.prototype.constructor = a.jqplot.MeterGaugeRenderer; a.jqplot.MeterGaugeRenderer.prototype.init = function (c) { this.diameter = null; this.padding = null; this.shadowOffset = 2; this.shadowAlpha = .07; this.shadowDepth = 4; this.background = "#efefef"; this.ringColor = "#BBC6D0"; this.needleColor = "#C3D3E5"; this.tickColor = "989898"; this.ringWidth = null; this.min; this.max; this.ticks = []; this.showTicks = true; this.showTickLabels = true; this.label = null; this.labelHeightAdjust = 0; this.labelPosition = "inside"; this.intervals = []; this.intervalColors = ["#4bb2c5", "#EAA228", "#c5b47f", "#579575", "#839557", "#958c12", "#953579", "#4b5de4", "#d8b83f", "#ff5800", "#0085cc", "#c747a3", "#cddf54", "#FBD178", "#26B4E3", "#bd70c7"]; this.intervalInnerRadius = null; this.intervalOuterRadius = null; this.tickRenderer = a.jqplot.MeterGaugeTickRenderer; this.tickPositions = [1, 2, 2.5, 5, 10]; this.tickSpacing = 30; this.numberMinorTicks = null; this.hubRadius = null; this.tickPadding = null; this.needleThickness = null; this.needlePad = 6; this.pegNeedle = true; this._type = "meterGauge"; a.extend(true, this, c); this.type = null; this.numberTicks = null; this.tickInterval = null; this.span = 180; if (this.type == "circular") { this.semiCircular = false } else if (this.type != "circular") { this.semiCircular = true } else { this.semiCircular = this.span <= 180 ? true : false } this._tickPoints = []; this._labelElem = null; this.startAngle = (90 + (360 - this.span) / 2) * Math.PI / 180; this.endAngle = (90 - (360 - this.span) / 2) * Math.PI / 180; this.setmin = !!(this.min == null); this.setmax = !!(this.max == null); if (this.intervals.length) { if (this.intervals[0].length == null || this.intervals.length == 1) { for (var d = 0; d < this.intervals.length; d++) { this.intervals[d] = [this.intervals[d], this.intervals[d], this.intervalColors[d]] } } else if (this.intervals[0].length == 2) { for (d = 0; d < this.intervals.length; d++) { this.intervals[d] = [this.intervals[d][0], this.intervals[d][1], this.intervalColors[d]] } } } if (this.ticks.length) { if (this.ticks[0].length == null || this.ticks[0].length == 1) { for (var d = 0; d < this.ticks.length; d++) { this.ticks[d] = [this.ticks[d], this.ticks[d]] } } this.min = this.min == null ? this.ticks[0][0] : this.min; this.max = this.max == null ? this.ticks[this.ticks.length - 1][0] : this.max; this.setmin = false; this.setmax = false; this.numberTicks = this.ticks.length; this.tickInterval = this.ticks[1][0] - this.ticks[0][0]; this.tickFactor = Math.floor(parseFloat((Math.log(this.tickInterval) / Math.log(10)).toFixed(11))); this.numberMinorTicks = b(this.tickPositions, this.tickInterval, this.tickFactor); if (!this.numberMinorTicks) { this.numberMinorTicks = b(this.tickPositions, this.tickInterval, this.tickFactor - 1) } if (!this.numberMinorTicks) { this.numberMinorTicks = 1 } } else if (this.intervals.length) { this.min = this.min == null ? 0 : this.min; this.setmin = false; if (this.max == null) { if (this.intervals[this.intervals.length - 1][0] >= this.data[0][1]) { this.max = this.intervals[this.intervals.length - 1][0]; this.setmax = false } } else { this.setmax = false } } else { this.min = this.min == null ? 0 : this.min; this.setmin = false; if (this.max == null) { this.max = this.data[0][1] * 1.25; this.setmax = true } else { this.setmax = false } } }; a.jqplot.MeterGaugeRenderer.prototype.setGridData = function (a) { var b = []; var c = []; var d = this.startAngle; for (var e = 0; e < this.data.length; e++) { b.push(this.data[e][1]); c.push([this.data[e][0]]); if (e > 0) { b[e] += b[e - 1] } } var f = Math.PI * 2 / b[b.length - 1]; for (var e = 0; e < b.length; e++) { c[e][1] = b[e] * f } this.gridData = c }; a.jqplot.MeterGaugeRenderer.prototype.makeGridData = function (a, b) { var c = []; var d = []; var e = this.startAngle; for (var f = 0; f < a.length; f++) { c.push(a[f][1]); d.push([a[f][0]]); if (f > 0) { c[f] += c[f - 1] } } var g = Math.PI * 2 / c[c.length - 1]; for (var f = 0; f < c.length; f++) { d[f][1] = c[f] * g } return d }; a.jqplot.MeterGaugeRenderer.prototype.draw = function (c, d, e) { var f; var g = e != undefined ? e : {}; var h = 0; var i = 0; var j = 1; if (e.legendInfo && e.legendInfo.placement == "inside") { var k = e.legendInfo; switch (k.location) { case "nw": h = k.width + k.xoffset; break; case "w": h = k.width + k.xoffset; break; case "sw": h = k.width + k.xoffset; break; case "ne": h = k.width + k.xoffset; j = -1; break; case "e": h = k.width + k.xoffset; j = -1; break; case "se": h = k.width + k.xoffset; j = -1; break; case "n": i = k.height + k.yoffset; break; case "s": i = k.height + k.yoffset; j = -1; break; default: break } } if (this.label) { this._labelElem = a('<div class="jqplot-meterGauge-label" style="position:absolute;">' + this.label + "</div>"); this.canvas._elem.after(this._labelElem) } var l = g.shadow != undefined ? g.shadow : this.shadow; var m = g.showLine != undefined ? g.showLine : this.showLine; var n = g.fill != undefined ? g.fill : this.fill; var o = c.canvas.width; var p = c.canvas.height; if (this.padding == null) { this.padding = Math.round(Math.min(o, p) / 30) } var q = o - h - 2 * this.padding; var r = p - i - 2 * this.padding; if (this.labelPosition == "bottom" && this.label) { r -= this._labelElem.outerHeight(true) } var s = Math.min(q, r); var t = s; if (!this.diameter) { if (this.semiCircular) { if (q >= 2 * r) { if (!this.ringWidth) { this.ringWidth = 2 * r / 35 } this.needleThickness = this.needleThickness || 2 + Math.pow(this.ringWidth, .8); this.innerPad = this.ringWidth / 2 + this.needleThickness / 2 + this.needlePad; this.diameter = 2 * (r - 2 * this.innerPad) } else { if (!this.ringWidth) { this.ringWidth = q / 35 } this.needleThickness = this.needleThickness || 2 + Math.pow(this.ringWidth, .8); this.innerPad = this.ringWidth / 2 + this.needleThickness / 2 + this.needlePad; this.diameter = q - 2 * this.innerPad - this.ringWidth - this.padding } this._center = [(o - j * h) / 2 + j * h, p + j * i - this.padding - this.ringWidth - this.innerPad] } else { if (!this.ringWidth) { this.ringWidth = t / 35 } this.needleThickness = this.needleThickness || 2 + Math.pow(this.ringWidth, .8); this.innerPad = 0; this.diameter = t - this.ringWidth; this._center = [(o - j * h) / 2 + j * h, (p - j * i) / 2 + j * i] } } if (this._labelElem && this.labelPosition == "bottom") { this._center[1] -= this._labelElem.outerHeight(true) } this._radius = this.diameter / 2; this.tickSpacing = 6e3 / this.diameter; if (!this.hubRadius) { this.hubRadius = this.diameter / 18 } this.shadowOffset = .5 + this.ringWidth / 9; this.shadowWidth = this.ringWidth * 1; this.tickPadding = 3 + Math.pow(this.diameter / 20, .7); this.tickOuterRadius = this._radius - this.ringWidth / 2 - this.tickPadding; this.tickLength = this.showTicks ? this._radius / 13 : 0; if (this.ticks.length == 0) { var u = this.max, v = this.min, w = this.setmax, x = this.setmin, y = (u - v) * this.tickSpacing / this.span; var z = Math.floor(parseFloat((Math.log(y) / Math.log(10)).toFixed(11))); var A = y / Math.pow(10, z); A > 2 && A <= 2.5 ? A = 2.5 : A = Math.ceil(A); var B = this.tickPositions; var C, D; for (f = 0; f < B.length; f++) { if (A == B[f] || f && B[f - 1] < A && A < B[f]) { y = B[f] * Math.pow(10, z); C = f } } for (f = 0; f < B.length; f++) { if (A == B[f] || f && B[f - 1] < A && A < B[f]) { y = B[f] * Math.pow(10, z); D = Math.ceil((u - v) / y) } } if (w && x) { var E = v > 0 ? v - v % y : v - v % y - y; if (!this.forceZero) { var F = Math.min(v - E, .8 * y); var G = Math.floor(F / B[C]); if (G > 1) { E = E + B[C] * (G - 1); if (parseInt(E, 10) != E && parseInt(E - B[C], 10) == E - B[C]) { E = E - B[C] } } } if (v == E) { v -= y } else { if (v - E > .23 * y) { v = E } else { v = E - y; D += 1 } } D += 1; var H = v + (D - 1) * y; if (u >= H) { H += y; D += 1 } if (H - u < .23 * y) { H += y; D += 1 } this.max = u = H; this.min = v; this.tickInterval = y; this.numberTicks = D; var I; for (f = 0; f < D; f++) { I = parseFloat((v + f * y).toFixed(11)); this.ticks.push([I, I]) } this.max = this.ticks[D - 1][1]; this.tickFactor = z; this.numberMinorTicks = b(this.tickPositions, this.tickInterval, this.tickFactor); if (!this.numberMinorTicks) { this.numberMinorTicks = b(this.tickPositions, this.tickInterval, this.tickFactor - 1) } } else if (w) { var H = v + (D - 1) * y; if (u >= H) { u = H + y; D += 1 } else { u = H } this.tickInterval = this.tickInterval || y; this.numberTicks = this.numberTicks || D; var I; for (f = 0; f < this.numberTicks; f++) { I = parseFloat((v + f * this.tickInterval).toFixed(11)); this.ticks.push([I, I]) } this.max = this.ticks[this.numberTicks - 1][1]; this.tickFactor = z; this.numberMinorTicks = b(this.tickPositions, this.tickInterval, this.tickFactor); if (!this.numberMinorTicks) { this.numberMinorTicks = b(this.tickPositions, this.tickInterval, this.tickFactor - 1) } } if (!w && !x) { var J = this.max - this.min; z = Math.floor(parseFloat((Math.log(J) / Math.log(10)).toFixed(11))) - 1; var K = [5, 6, 4, 7, 3, 8, 9, 10, 2], L, M, N = 0, O; if (J > 1) { var P = String(J); if (P.search(/\./) == -1) { var Q = P.search(/0+$/); N = Q > 0 ? P.length - Q - 1 : 0 } } O = J / Math.pow(10, N); for (f = 0; f < K.length; f++) { L = O / (K[f] - 1); if (L == parseInt(L, 10)) { this.numberTicks = K[f]; this.tickInterval = J / (this.numberTicks - 1); this.tickFactor = z + 1; break } } var I; for (f = 0; f < this.numberTicks; f++) { I = parseFloat((this.min + f * this.tickInterval).toFixed(11)); this.ticks.push([I, I]) } this.numberMinorTicks = b(this.tickPositions, this.tickInterval, this.tickFactor); if (!this.numberMinorTicks) { this.numberMinorTicks = b(this.tickPositions, this.tickInterval, this.tickFactor - 1) } if (!this.numberMinorTicks) { this.numberMinorTicks = 1; var R = [4, 5, 3, 6, 2]; for (f = 0; f < 5; f++) { var S = this.tickInterval / R[f]; if (S == parseInt(S, 10)) { this.numberMinorTicks = R[f] - 1; break } } } } } var T = this._radius, U = this.startAngle, V = this.endAngle, W = Math.PI, X = Math.PI / 2; if (this.semiCircular) { var Y = Math.atan(this.innerPad / T), Z = this.outerStartAngle = U - Y, _ = this.outerEndAngle = V + Y, ba = this.hubStartAngle = U - Math.atan(this.innerPad / this.hubRadius * 2), bb = this.hubEndAngle = V + Math.atan(this.innerPad / this.hubRadius * 2); c.save(); c.translate(this._center[0], this._center[1]); c.lineJoin = "round"; c.lineCap = "round"; c.save(); c.beginPath(); c.fillStyle = this.background; c.arc(0, 0, T, Z, _, false); c.closePath(); c.fill(); c.restore(); var bc = "rgba(0,0,0," + this.shadowAlpha + ")"; c.save(); for (var f = 0; f < this.shadowDepth; f++) { c.translate(this.shadowOffset * Math.cos(this.shadowAngle / 180 * Math.PI), this.shadowOffset * Math.sin(this.shadowAngle / 180 * Math.PI)); c.beginPath(); c.strokeStyle = bc; c.lineWidth = this.shadowWidth; c.arc(0, 0, T, Z, _, false); c.closePath(); c.stroke() } c.restore(); c.save(); var bd = parseInt((this.shadowDepth + 1) / 2, 10); for (var f = 0; f < bd; f++) { c.translate(this.shadowOffset * Math.cos(this.shadowAngle / 180 * Math.PI), this.shadowOffset * Math.sin(this.shadowAngle / 180 * Math.PI)); c.beginPath(); c.fillStyle = bc; c.arc(0, 0, this.hubRadius, ba, bb, false); c.closePath(); c.fill() } c.restore(); c.save(); c.beginPath(); c.strokeStyle = this.ringColor; c.lineWidth = this.ringWidth; c.arc(0, 0, T, Z, _, false); c.closePath(); c.stroke(); c.restore(); c.save(); c.beginPath(); c.fillStyle = this.ringColor; c.arc(0, 0, this.hubRadius, ba, bb, false); c.closePath(); c.fill(); c.restore(); if (this.showTicks) { c.save(); var be = this.tickOuterRadius, bf = this.tickLength, bg = bf / 2, bh = this.numberMinorTicks, bi = this.span * Math.PI / 180 / (this.ticks.length - 1), bj = bi / (bh + 1); for (f = 0; f < this.ticks.length; f++) { c.beginPath(); c.lineWidth = 1.5 + this.diameter / 360; c.strokeStyle = this.ringColor; var bk = bi * f + U; c.moveTo(-be * Math.cos(bi * f + U), be * Math.sin(bi * f + U)); c.lineTo(-(be - bf) * Math.cos(bi * f + U), (be - bf) * Math.sin(bi * f + U)); this._tickPoints.push([(be - bf) * Math.cos(bi * f + U) + this._center[0] + this.canvas._offsets.left, (be - bf) * Math.sin(bi * f + U) + this._center[1] + this.canvas._offsets.top, bi * f + U]); c.stroke(); c.lineWidth = 1 + this.diameter / 440; if (f < this.ticks.length - 1) { for (var bl = 1; bl <= bh; bl++) { c.beginPath(); c.moveTo(-be * Math.cos(bi * f + bj * bl + U), be * Math.sin(bi * f + bj * bl + U)); c.lineTo(-(be - bg) * Math.cos(bi * f + bj * bl + U), (be - bg) * Math.sin(bi * f + bj * bl + U)); c.stroke() } } } c.restore() } if (this.showTickLabels) { var bm, bn, B, bo, bp, bq, br = 0; var A = this.tickPadding * (1 - 1 / (this.diameter / 80 + 1)); for (f = 0; f < this.ticks.length; f++) { bm = a('<div class="jqplot-meterGauge-tick" style="position:absolute;">' + this.ticks[f][1] + "</div>"); this.canvas._elem.after(bm); bo = bm.outerWidth(true); bp = bm.outerHeight(true); bn = this._tickPoints[f][0] - bo * (this._tickPoints[f][2] - Math.PI) / Math.PI - A * Math.cos(this._tickPoints[f][2]); B = this._tickPoints[f][1] - bp / 2 + bp / 2 * Math.pow(Math.abs(Math.sin(this._tickPoints[f][2])), .5) + A / 3 * Math.pow(Math.abs(Math.sin(this._tickPoints[f][2])), .5); bm.css({ left: bn, top: B }); bq = bo * Math.cos(this._tickPoints[f][2]) + bp * Math.sin(Math.PI / 2 + this._tickPoints[f][2] / 2); br = bq > br ? bq : br } } if (this.label && this.labelPosition == "inside") { var bn = this._center[0] + this.canvas._offsets.left; var A = this.tickPadding * (1 - 1 / (this.diameter / 80 + 1)); var B = .5 * (this._center[1] + this.canvas._offsets.top - this.hubRadius) + .5 * (this._center[1] + this.canvas._offsets.top - this.tickOuterRadius + this.tickLength + A) + this.labelHeightAdjust; bn -= this._labelElem.outerWidth(true) / 2; B -= this._labelElem.outerHeight(true) / 2; this._labelElem.css({ left: bn, top: B }) } else if (this.label && this.labelPosition == "bottom") { var bn = this._center[0] + this.canvas._offsets.left - this._labelElem.outerWidth(true) / 2; var B = this._center[1] + this.canvas._offsets.top + this.innerPad + +this.ringWidth + this.padding + this.labelHeightAdjust; this._labelElem.css({ left: bn, top: B }) } c.save(); var bs = this.intervalInnerRadius || this.hubRadius * 1.5; if (this.intervalOuterRadius == null) { if (this.showTickLabels) { var bt = this.tickOuterRadius - this.tickLength - this.tickPadding - this.diameter / 8 } else { var bt = this.tickOuterRadius - this.tickLength - this.diameter / 16 } } else { var bt = this.intervalOuterRadius } var J = this.max - this.min; var bu = this.intervals[this.intervals.length - 1] - this.min; var bv, bw, bx = this.span * Math.PI / 180; for (f = 0; f < this.intervals.length; f++) { bv = f == 0 ? U : U + (this.intervals[f - 1][0] - this.min) * bx / J; if (bv < 0) { bv = 0 } bw = U + (this.intervals[f][0] - this.min) * bx / J; if (bw < 0) { bw = 0 } c.beginPath(); c.fillStyle = this.intervals[f][2]; c.arc(0, 0, bs, bv, bw, false); c.lineTo(bt * Math.cos(bw), bt * Math.sin(bw)); c.arc(0, 0, bt, bw, bv, true); c.lineTo(bs * Math.cos(bv), bs * Math.sin(bv)); c.closePath(); c.fill() } c.restore(); var by = this.data[0][1]; var bz = this.max - this.min; if (this.pegNeedle) { if (this.data[0][1] > this.max + bz * 3 / this.span) { by = this.max + bz * 3 / this.span } if (this.data[0][1] < this.min - bz * 3 / this.span) { by = this.min - bz * 3 / this.span } } var bA = (by - this.min) / bz * this.span * Math.PI / 180 + this.startAngle; c.save(); c.beginPath(); c.fillStyle = this.ringColor; c.strokeStyle = this.ringColor; this.needleLength = (this.tickOuterRadius - this.tickLength) * .85; this.needleThickness = this.needleThickness < 2 ? 2 : this.needleThickness; var bB = this.needleThickness * .4; var bC = this.needleLength / 10; var bD = (this.needleThickness - bB) / 10; var bE; for (var f = 0; f < 10; f++) { bE = this.needleThickness - f * bD; c.moveTo(bC * f * Math.cos(bA), bC * f * Math.sin(bA)); c.lineWidth = bE; c.lineTo(bC * (f + 1) * Math.cos(bA), bC * (f + 1) * Math.sin(bA)); c.stroke() } c.restore() } else { this._center = [(o - j * h) / 2 + j * h, (p - j * i) / 2 + j * i] } }; a.jqplot.MeterGaugeAxisRenderer = function () { a.jqplot.LinearAxisRenderer.call(this) }; a.jqplot.MeterGaugeAxisRenderer.prototype = new a.jqplot.LinearAxisRenderer; a.jqplot.MeterGaugeAxisRenderer.prototype.constructor = a.jqplot.MeterGaugeAxisRenderer; a.jqplot.MeterGaugeAxisRenderer.prototype.init = function (b) { this.tickRenderer = a.jqplot.MeterGaugeTickRenderer; a.extend(true, this, b); this._dataBounds = { min: 0, max: 100 }; this.min = 0; this.max = 100; this.showTicks = false; this.ticks = []; this.showMark = false; this.show = false }; a.jqplot.MeterGaugeLegendRenderer = function () { a.jqplot.TableLegendRenderer.call(this) }; a.jqplot.MeterGaugeLegendRenderer.prototype = new a.jqplot.TableLegendRenderer; a.jqplot.MeterGaugeLegendRenderer.prototype.constructor = a.jqplot.MeterGaugeLegendRenderer; a.jqplot.MeterGaugeLegendRenderer.prototype.init = function (b) { this.numberRows = null; this.numberColumns = null; a.extend(true, this, b) }; a.jqplot.MeterGaugeLegendRenderer.prototype.draw = function () { if (this.show) { var b = this._series; var c = "position:absolute;"; c += this.background ? "background:" + this.background + ";" : ""; c += this.border ? "border:" + this.border + ";" : ""; c += this.fontSize ? "font-size:" + this.fontSize + ";" : ""; c += this.fontFamily ? "font-family:" + this.fontFamily + ";" : ""; c += this.textColor ? "color:" + this.textColor + ";" : ""; c += this.marginTop != null ? "margin-top:" + this.marginTop + ";" : ""; c += this.marginBottom != null ? "margin-bottom:" + this.marginBottom + ";" : ""; c += this.marginLeft != null ? "margin-left:" + this.marginLeft + ";" : ""; c += this.marginRight != null ? "margin-right:" + this.marginRight + ";" : ""; this._elem = a('<table class="jqplot-table-legend" style="' + c + '"></table>'); var d = false, e = false, f, g; var h = b[0]; if (h.show) { var i = h.data; if (this.numberRows) { f = this.numberRows; if (!this.numberColumns) { g = Math.ceil(i.length / f) } else { g = this.numberColumns } } else if (this.numberColumns) { g = this.numberColumns; f = Math.ceil(i.length / this.numberColumns) } else { f = i.length; g = 1 } var j, k, l, m, n, o, p, q; var r = 0; for (j = 0; j < f; j++) { if (e) { l = a('<tr class="jqplot-table-legend"></tr>').prependTo(this._elem) } else { l = a('<tr class="jqplot-table-legend"></tr>').appendTo(this._elem) } for (k = 0; k < g; k++) { if (r < i.length) { o = this.labels[r] || i[r][0].toString(); q = h.color; if (!e) { if (j > 0) { d = true } else { d = false } } else { if (j == f - 1) { d = false } else { d = true } } p = d ? this.rowSpacing : "0"; m = a('<td class="jqplot-table-legend" style="text-align:center;padding-top:' + p + ';">' + '<div><div class="jqplot-table-legend-swatch" style="border-color:' + q + ';"></div>' + "</div></td>"); n = a('<td class="jqplot-table-legend" style="padding-top:' + p + ';"></td>'); if (this.escapeHtml) { n.text(o) } else { n.html(o) } if (e) { n.prependTo(l); m.prependTo(l) } else { m.appendTo(l); n.appendTo(l) } d = true } r++ } } } } return this._elem }; a.jqplot.preInitHooks.push(c); a.jqplot.postParseOptionsHooks.push(d); a.jqplot.MeterGaugeTickRenderer = function () { a.jqplot.AxisTickRenderer.call(this) }; a.jqplot.MeterGaugeTickRenderer.prototype = new a.jqplot.AxisTickRenderer; a.jqplot.MeterGaugeTickRenderer.prototype.constructor = a.jqplot.MeterGaugeTickRenderer })(jQuery); (function (a) { a.jqplot.OHLCRenderer = function () { a.jqplot.LineRenderer.call(this); this.candleStick = false; this.tickLength = "auto"; this.bodyWidth = "auto"; this.openColor = null; this.closeColor = null; this.wickColor = null; this.fillUpBody = false; this.fillDownBody = true; this.upBodyColor = null; this.downBodyColor = null; this.hlc = false; this.lineWidth = 1.5; this._tickLength; this._bodyWidth }; a.jqplot.OHLCRenderer.prototype = new a.jqplot.LineRenderer; a.jqplot.OHLCRenderer.prototype.constructor = a.jqplot.OHLCRenderer; a.jqplot.OHLCRenderer.prototype.init = function (b) { b = b || {}; this.lineWidth = b.lineWidth || 1.5; a.jqplot.LineRenderer.prototype.init.call(this, b); this._type = "ohlc"; var c = this._yaxis._dataBounds; var d = this._plotData; if (d[0].length < 5) { this.renderer.hlc = true; for (var e = 0; e < d.length; e++) { if (d[e][2] < c.min || c.min == null) { c.min = d[e][2] } if (d[e][1] > c.max || c.max == null) { c.max = d[e][1] } } } else { for (var e = 0; e < d.length; e++) { if (d[e][3] < c.min || c.min == null) { c.min = d[e][3] } if (d[e][2] > c.max || c.max == null) { c.max = d[e][2] } } } }; a.jqplot.OHLCRenderer.prototype.draw = function (b, c, d) { var e = this.data; var f = this._xaxis.min; var g = this._xaxis.max; var h = 0; var i = e.length; var j = this._xaxis.series_u2p; var k = this._yaxis.series_u2p; var l, m, n, o, p, q, r, s; var t; var u = this.renderer; var v = d != undefined ? d : {}; var w = v.shadow != undefined ? v.shadow : this.shadow; var x = v.fill != undefined ? v.fill : this.fill; var y = v.fillAndStroke != undefined ? v.fillAndStroke : this.fillAndStroke; u.bodyWidth = v.bodyWidth != undefined ? v.bodyWidth : u.bodyWidth; u.tickLength = v.tickLength != undefined ? v.tickLength : u.tickLength; b.save(); if (this.show) { var z, A, B, C, D; for (var l = 0; l < e.length; l++) { if (e[l][0] < f) { h = l } else if (e[l][0] < g) { i = l + 1 } } var E = this.gridData[i - 1][0] - this.gridData[h][0]; var F = i - h; try { var G = Math.abs(this._xaxis.series_u2p(parseInt(this._xaxis._intervalStats[0].sortedIntervals[0].interval, 10)) - this._xaxis.series_u2p(0)) } catch (H) { var G = E / F } if (u.candleStick) { if (typeof u.bodyWidth == "number") { u._bodyWidth = u.bodyWidth } else { u._bodyWidth = Math.min(20, G / 1.65) } } else { if (typeof u.tickLength == "number") { u._tickLength = u.tickLength } else { u._tickLength = Math.min(10, G / 3.5) } } for (var l = h; l < i; l++) { z = j(e[l][0]); if (u.hlc) { A = null; B = k(e[l][1]); C = k(e[l][2]); D = k(e[l][3]) } else { A = k(e[l][1]); B = k(e[l][2]); C = k(e[l][3]); D = k(e[l][4]) } t = {}; if (u.candleStick && !u.hlc) { q = u._bodyWidth; r = z - q / 2; if (D < A) { if (u.wickColor) { t.color = u.wickColor } else if (u.downBodyColor) { t.color = u.upBodyColor } n = a.extend(true, {}, v, t); u.shapeRenderer.draw(b, [[z, B], [z, D]], n); u.shapeRenderer.draw(b, [[z, A], [z, C]], n); t = {}; o = D; p = A - D; if (u.fillUpBody) { t.fillRect = true } else { t.strokeRect = true; q = q - this.lineWidth; r = z - q / 2 } if (u.upBodyColor) { t.color = u.upBodyColor; t.fillStyle = u.upBodyColor } s = [r, o, q, p] } else if (D > A) { if (u.wickColor) { t.color = u.wickColor } else if (u.downBodyColor) { t.color = u.downBodyColor } n = a.extend(true, {}, v, t); u.shapeRenderer.draw(b, [[z, B], [z, A]], n); u.shapeRenderer.draw(b, [[z, D], [z, C]], n); t = {}; o = A; p = D - A; if (u.fillDownBody) { t.fillRect = true } else { t.strokeRect = true; q = q - this.lineWidth; r = z - q / 2 } if (u.downBodyColor) { t.color = u.downBodyColor; t.fillStyle = u.downBodyColor } s = [r, o, q, p] } else { if (u.wickColor) { t.color = u.wickColor } n = a.extend(true, {}, v, t); u.shapeRenderer.draw(b, [[z, B], [z, C]], n); t = {}; t.fillRect = false; t.strokeRect = false; r = [z - q / 2, A]; o = [z + q / 2, D]; q = null; p = null; s = [r, o] } n = a.extend(true, {}, v, t); u.shapeRenderer.draw(b, s, n) } else { m = v.color; if (u.openColor) { v.color = u.openColor } if (!u.hlc) { u.shapeRenderer.draw(b, [[z - u._tickLength, A], [z, A]], v) } v.color = m; if (u.wickColor) { v.color = u.wickColor } u.shapeRenderer.draw(b, [[z, B], [z, C]], v); v.color = m; if (u.closeColor) { v.color = u.closeColor } u.shapeRenderer.draw(b, [[z, D], [z + u._tickLength, D]], v); v.color = m } } } b.restore() }; a.jqplot.OHLCRenderer.prototype.drawShadow = function (a, b, c) { }; a.jqplot.OHLCRenderer.checkOptions = function (a, b, c) { if (!c.highlighter) { c.highlighter = { showMarker: false, tooltipAxes: "y", yvalues: 4, formatString: '<table class="jqplot-highlighter"><tr><td>date:</td><td>%s</td></tr><tr><td>open:</td><td>%s</td></tr><tr><td>hi:</td><td>%s</td></tr><tr><td>low:</td><td>%s</td></tr><tr><td>close:</td><td>%s</td></tr></table>'} } } })(jQuery); (function (a) { function n() { if (this.plugins.pieRenderer && this.plugins.pieRenderer.highlightCanvas) { this.plugins.pieRenderer.highlightCanvas.resetCanvas(); this.plugins.pieRenderer.highlightCanvas = null } this.plugins.pieRenderer = { highlightedSeriesIndex: null }; this.plugins.pieRenderer.highlightCanvas = new a.jqplot.GenericCanvas; var b = a(this.targetId + " .jqplot-data-label"); if (b.length) { a(b[0]).before(this.plugins.pieRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-pieRenderer-highlight-canvas", this._plotDimensions, this)) } else { this.eventCanvas._elem.before(this.plugins.pieRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-pieRenderer-highlight-canvas", this._plotDimensions, this)) } var c = this.plugins.pieRenderer.highlightCanvas.setContext(); this.eventCanvas._elem.bind("mouseleave", { plot: this }, function (a) { h(a.data.plot) }) } function m(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; var g = e.plugins.pieRenderer.highlightedSeriesIndex; if (g != null && e.series[g].highlightMouseDown) { h(e) } var i = jQuery.Event("jqplotDataRightClick"); i.pageX = a.pageX; i.pageY = a.pageY; e.target.trigger(i, f) } } function l(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; var g = jQuery.Event("jqplotDataClick"); g.pageX = a.pageX; g.pageY = a.pageY; e.target.trigger(g, f) } } function k(a, b, c, d, e) { var f = e.plugins.pieRenderer.highlightedSeriesIndex; if (f != null && e.series[f].highlightMouseDown) { h(e) } } function j(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; if (e.series[f[0]].highlightMouseDown && !(f[0] == e.plugins.pieRenderer.highlightedSeriesIndex && f[1] == e.series[f[0]]._highlightedPoint)) { var i = jQuery.Event("jqplotDataHighlight"); i.pageX = a.pageX; i.pageY = a.pageY; e.target.trigger(i, f); g(e, f[0], f[1]) } } else if (d == null) { h(e) } } function i(a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; var i = jQuery.Event("jqplotDataMouseOver"); i.pageX = a.pageX; i.pageY = a.pageY; e.target.trigger(i, f); if (e.series[f[0]].highlightMouseOver && !(f[0] == e.plugins.pieRenderer.highlightedSeriesIndex && f[1] == e.series[f[0]]._highlightedPoint)) { var j = jQuery.Event("jqplotDataHighlight"); j.pageX = a.pageX; j.pageY = a.pageY; e.target.trigger(j, f); g(e, f[0], f[1]) } } else if (d == null) { h(e) } } function h(a) { var b = a.plugins.pieRenderer.highlightCanvas; b._ctx.clearRect(0, 0, b._ctx.canvas.width, b._ctx.canvas.height); for (var c = 0; c < a.series.length; c++) { a.series[c]._highlightedPoint = null } a.plugins.pieRenderer.highlightedSeriesIndex = null; a.target.trigger("jqplotDataUnhighlight") } function g(a, b, c) { var d = a.series[b]; var e = a.plugins.pieRenderer.highlightCanvas; e._ctx.clearRect(0, 0, e._ctx.canvas.width, e._ctx.canvas.height); d._highlightedPoint = c; a.plugins.pieRenderer.highlightedSeriesIndex = b; d.renderer.drawSlice.call(d, e._ctx, d._sliceAngles[c][0], d._sliceAngles[c][1], d.highlightColorGenerator.get(c), false) } function f(b) { for (var c = 0; c < this.series.length; c++) { this.series[c].seriesColors = this.seriesColors; this.series[c].colorGenerator = a.jqplot.colorGenerator } } function e(b, c, d) { for (var e = 0; e < this.series.length; e++) { if (this.series[e].renderer.constructor == a.jqplot.PieRenderer) { if (this.series[e].highlightMouseOver) { this.series[e].highlightMouseDown = false } } } } function d(b, c, d) { d = d || {}; d.axesDefaults = d.axesDefaults || {}; d.legend = d.legend || {}; d.seriesDefaults = d.seriesDefaults || {}; var e = false; if (d.seriesDefaults.renderer == a.jqplot.PieRenderer) { e = true } else if (d.series) { for (var f = 0; f < d.series.length; f++) { if (d.series[f].renderer == a.jqplot.PieRenderer) { e = true } } } if (e) { d.axesDefaults.renderer = a.jqplot.PieAxisRenderer; d.legend.renderer = a.jqplot.PieLegendRenderer; d.legend.preDraw = true; d.seriesDefaults.pointLabels = { show: false} } } function c(a, c, d, e, f) { var g = 0; var h = c - a; var i = Math.abs(h); var j = d; if (e == false) { j += f } if (j > 0 && i > .01 && i < 6.282) { g = parseFloat(j) / 2 / b(h) } return g } function b(a) { return Math.sin((a - (a - Math.PI) / 8 / Math.PI) / 2) } a.jqplot.PieRenderer = function () { a.jqplot.LineRenderer.call(this) }; a.jqplot.PieRenderer.prototype = new a.jqplot.LineRenderer; a.jqplot.PieRenderer.prototype.constructor = a.jqplot.PieRenderer; a.jqplot.PieRenderer.prototype.init = function (b, c) { this.diameter = null; this.padding = 20; this.sliceMargin = 0; this.fill = true; this.shadowOffset = 2; this.shadowAlpha = .07; this.shadowDepth = 5; this.highlightMouseOver = true; this.highlightMouseDown = false; this.highlightColors = []; this.dataLabels = "percent"; this.showDataLabels = false; this.dataLabelFormatString = null; this.dataLabelThreshold = 3; this.dataLabelPositionFactor = .52; this.dataLabelNudge = 2; this.dataLabelCenterOn = true; this.startAngle = 0; this.tickRenderer = a.jqplot.PieTickRenderer; this._drawData = true; this._type = "pie"; if (b.highlightMouseDown && b.highlightMouseOver == null) { b.highlightMouseOver = false } a.extend(true, this, b); if (this.sliceMargin < 0) { this.sliceMargin = 0 } this._diameter = null; this._radius = null; this._sliceAngles = []; this._highlightedPoint = null; if (this.highlightColors.length == 0) { for (var d = 0; d < this.seriesColors.length; d++) { var g = a.jqplot.getColorComponents(this.seriesColors[d]); var h = [g[0], g[1], g[2]]; var o = h[0] + h[1] + h[2]; for (var p = 0; p < 3; p++) { h[p] = o > 570 ? h[p] * .8 : h[p] + .3 * (255 - h[p]); h[p] = parseInt(h[p], 10) } this.highlightColors.push("rgb(" + h[0] + "," + h[1] + "," + h[2] + ")") } } this.highlightColorGenerator = new a.jqplot.ColorGenerator(this.highlightColors); c.postParseOptionsHooks.addOnce(f); c.postInitHooks.addOnce(e); c.eventListenerHooks.addOnce("jqplotMouseMove", i); c.eventListenerHooks.addOnce("jqplotMouseDown", j); c.eventListenerHooks.addOnce("jqplotMouseUp", k); c.eventListenerHooks.addOnce("jqplotClick", l); c.eventListenerHooks.addOnce("jqplotRightClick", m); c.postDrawHooks.addOnce(n) }; a.jqplot.PieRenderer.prototype.setGridData = function (a) { var b = []; var c = []; var d = this.startAngle / 180 * Math.PI; var e = 0; this._drawData = false; for (var f = 0; f < this.data.length; f++) { if (this.data[f][1] != 0) { this._drawData = true } b.push(this.data[f][1]); c.push([this.data[f][0]]); if (f > 0) { b[f] += b[f - 1] } e += this.data[f][1] } var g = Math.PI * 2 / b[b.length - 1]; for (var f = 0; f < b.length; f++) { c[f][1] = b[f] * g; c[f][2] = this.data[f][1] / e } this.gridData = c }; a.jqplot.PieRenderer.prototype.makeGridData = function (a, b) { var c = []; var d = []; var e = 0; var f = this.startAngle / 180 * Math.PI; this._drawData = false; for (var g = 0; g < a.length; g++) { if (this.data[g][1] != 0) { this._drawData = true } c.push(a[g][1]); d.push([a[g][0]]); if (g > 0) { c[g] += c[g - 1] } e += a[g][1] } var h = Math.PI * 2 / c[c.length - 1]; for (var g = 0; g < c.length; g++) { d[g][1] = c[g] * h; d[g][2] = a[g][1] / e } return d }; a.jqplot.PieRenderer.prototype.drawSlice = function (a, b, d, e, f) { function p(c) { if (d > 6.282 + this.startAngle) { d = 6.282 + this.startAngle; if (b > d) { b = 6.281 + this.startAngle } } if (b >= d) { return } a.beginPath(); a.fillStyle = e; a.strokeStyle = e; a.lineWidth = i; a.arc(0, 0, c, b, d, false); a.lineTo(0, 0); a.closePath(); if (h) { a.fill() } else { a.stroke() } } if (this._drawData) { var g = this._radius; var h = this.fill; var i = this.lineWidth; var j = this.sliceMargin; if (this.fill == false) { j += this.lineWidth } a.save(); a.translate(this._center[0], this._center[1]); var k = c(b, d, this.sliceMargin, this.fill, this.lineWidth); var l = k * Math.cos((b + d) / 2); var m = k * Math.sin((b + d) / 2); if (d - b <= Math.PI) { g -= k } else { g += k } a.translate(l, m); if (f) { for (var n = 0, o = this.shadowDepth; n < o; n++) { a.save(); a.translate(this.shadowOffset * Math.cos(this.shadowAngle / 180 * Math.PI), this.shadowOffset * Math.sin(this.shadowAngle / 180 * Math.PI)); p(g) } for (var n = 0, o = this.shadowDepth; n < o; n++) { a.restore() } } else { p(g) } a.restore() } }; a.jqplot.PieRenderer.prototype.draw = function (b, d, e, f) { var g; var h = e != undefined ? e : {}; var i = 0; var j = 0; var k = 1; var l = new a.jqplot.ColorGenerator(this.seriesColors); if (e.legendInfo && e.legendInfo.placement == "insideGrid") { var m = e.legendInfo; switch (m.location) { case "nw": i = m.width + m.xoffset; break; case "w": i = m.width + m.xoffset; break; case "sw": i = m.width + m.xoffset; break; case "ne": i = m.width + m.xoffset; k = -1; break; case "e": i = m.width + m.xoffset; k = -1; break; case "se": i = m.width + m.xoffset; k = -1; break; case "n": j = m.height + m.yoffset; break; case "s": j = m.height + m.yoffset; k = -1; break; default: break } } var n = h.shadow != undefined ? h.shadow : this.shadow; var o = h.fill != undefined ? h.fill : this.fill; var p = b.canvas.width; var q = b.canvas.height; var r = p - i - 2 * this.padding; var s = q - j - 2 * this.padding; var t = Math.min(r, s); var u = t; this._sliceAngles = []; var v = this.sliceMargin; if (this.fill == false) { v += this.lineWidth } var w; var x = 0; var y, z, A, B; var C = this.startAngle / 180 * Math.PI; for (var g = 0, D = d.length; g < D; g++) { z = g == 0 ? C : d[g - 1][1] + C; A = d[g][1] + C; this._sliceAngles.push([z, A]); w = c(z, A, this.sliceMargin, this.fill, this.lineWidth); if (Math.abs(A - z) > Math.PI) { x = Math.max(w, x) } } if (this.diameter != null && this.diameter > 0) { this._diameter = this.diameter - 2 * x } else { this._diameter = u - 2 * x } if (this._diameter < 6) { a.jqplot.log("Diameter of pie too small, not rendering."); return } var E = this._radius = this._diameter / 2; this._center = [(p - k * i) / 2 + k * i + x * Math.cos(C), (q - k * j) / 2 + k * j + x * Math.sin(C)]; if (this.shadow) { for (var g = 0, D = d.length; g < D; g++) { B = "rgba(0,0,0," + this.shadowAlpha + ")"; this.renderer.drawSlice.call(this, b, this._sliceAngles[g][0], this._sliceAngles[g][1], B, true) } } for (var g = 0; g < d.length; g++) { this.renderer.drawSlice.call(this, b, this._sliceAngles[g][0], this._sliceAngles[g][1], l.next(), false); if (this.showDataLabels && d[g][2] * 100 >= this.dataLabelThreshold) { var F, G = (this._sliceAngles[g][0] + this._sliceAngles[g][1]) / 2, H; if (this.dataLabels == "label") { F = this.dataLabelFormatString || "%s"; H = a.jqplot.sprintf(F, d[g][0]) } else if (this.dataLabels == "value") { F = this.dataLabelFormatString || "%d"; H = a.jqplot.sprintf(F, this.data[g][1]) } else if (this.dataLabels == "percent") { F = this.dataLabelFormatString || "%d%%"; H = a.jqplot.sprintf(F, d[g][2] * 100) } else if (this.dataLabels.constructor == Array) { F = this.dataLabelFormatString || "%s"; H = a.jqplot.sprintf(F, this.dataLabels[g]) } var I = this._radius * this.dataLabelPositionFactor + this.sliceMargin + this.dataLabelNudge; var J = this._center[0] + Math.cos(G) * I + this.canvas._offsets.left; var K = this._center[1] + Math.sin(G) * I + this.canvas._offsets.top; var L = a('<div class="jqplot-pie-series jqplot-data-label" style="position:absolute;">' + H + "</div>").insertBefore(f.eventCanvas._elem); if (this.dataLabelCenterOn) { J -= L.width() / 2; K -= L.height() / 2 } else { J -= L.width() * Math.sin(G / 2); K -= L.height() / 2 } J = Math.round(J); K = Math.round(K); L.css({ left: J, top: K }) } } }; a.jqplot.PieAxisRenderer = function () { a.jqplot.LinearAxisRenderer.call(this) }; a.jqplot.PieAxisRenderer.prototype = new a.jqplot.LinearAxisRenderer; a.jqplot.PieAxisRenderer.prototype.constructor = a.jqplot.PieAxisRenderer; a.jqplot.PieAxisRenderer.prototype.init = function (b) { this.tickRenderer = a.jqplot.PieTickRenderer; a.extend(true, this, b); this._dataBounds = { min: 0, max: 100 }; this.min = 0; this.max = 100; this.showTicks = false; this.ticks = []; this.showMark = false; this.show = false }; a.jqplot.PieLegendRenderer = function () { a.jqplot.TableLegendRenderer.call(this) }; a.jqplot.PieLegendRenderer.prototype = new a.jqplot.TableLegendRenderer; a.jqplot.PieLegendRenderer.prototype.constructor = a.jqplot.PieLegendRenderer; a.jqplot.PieLegendRenderer.prototype.init = function (b) { this.numberRows = null; this.numberColumns = null; a.extend(true, this, b) }; a.jqplot.PieLegendRenderer.prototype.draw = function () { var b = this; if (this.show) { var c = this._series; this._elem = a(document.createElement("table")); this._elem.addClass("jqplot-table-legend"); var d = { position: "absolute" }; if (this.background) { d["background"] = this.background } if (this.border) { d["border"] = this.border } if (this.fontSize) { d["fontSize"] = this.fontSize } if (this.fontFamily) { d["fontFamily"] = this.fontFamily } if (this.textColor) { d["textColor"] = this.textColor } if (this.marginTop != null) { d["marginTop"] = this.marginTop } if (this.marginBottom != null) { d["marginBottom"] = this.marginBottom } if (this.marginLeft != null) { d["marginLeft"] = this.marginLeft } if (this.marginRight != null) { d["marginRight"] = this.marginRight } this._elem.css(d); var e = false, f = false, g, h; var i = c[0]; var j = new a.jqplot.ColorGenerator(i.seriesColors); if (i.show) { var k = i.data; if (this.numberRows) { g = this.numberRows; if (!this.numberColumns) { h = Math.ceil(k.length / g) } else { h = this.numberColumns } } else if (this.numberColumns) { h = this.numberColumns; g = Math.ceil(k.length / this.numberColumns) } else { g = k.length; h = 1 } var l, m; var n, o, p; var q, r, s; var t = 0; var u, v; for (l = 0; l < g; l++) { n = a(document.createElement("tr")); n.addClass("jqplot-table-legend"); if (f) { n.prependTo(this._elem) } else { n.appendTo(this._elem) } for (m = 0; m < h; m++) { if (t < k.length) { q = this.labels[t] || k[t][0].toString(); s = j.next(); if (!f) { if (l > 0) { e = true } else { e = false } } else { if (l == g - 1) { e = false } else { e = true } } r = e ? this.rowSpacing : "0"; o = a(document.createElement("td")); o.addClass("jqplot-table-legend jqplot-table-legend-swatch"); o.css({ textAlign: "center", paddingTop: r }); u = a(document.createElement("div")); u.addClass("jqplot-table-legend-swatch-outline"); v = a(document.createElement("div")); v.addClass("jqplot-table-legend-swatch"); v.css({ backgroundColor: s, borderColor: s }); o.append(u.append(v)); p = a(document.createElement("td")); p.addClass("jqplot-table-legend jqplot-table-legend-label"); p.css("paddingTop", r); if (this.escapeHtml) { p.text(q) } else { p.html(q) } if (f) { p.prependTo(n); o.prependTo(n) } else { o.appendTo(n); p.appendTo(n) } e = true } t++ } } } } return this._elem }; a.jqplot.PieRenderer.prototype.handleMove = function (a, b, c, d, e) { if (d) { var f = [d.seriesIndex, d.pointIndex, d.data]; e.target.trigger("jqplotDataMouseOver", f); if (e.series[f[0]].highlightMouseOver && !(f[0] == e.plugins.pieRenderer.highlightedSeriesIndex && f[1] == e.series[f[0]]._highlightedPoint)) { e.target.trigger("jqplotDataHighlight", f); g(e, f[0], f[1]) } } else if (d == null) { h(e) } }; a.jqplot.preInitHooks.push(d); a.jqplot.PieTickRenderer = function () { a.jqplot.AxisTickRenderer.call(this) }; a.jqplot.PieTickRenderer.prototype = new a.jqplot.AxisTickRenderer; a.jqplot.PieTickRenderer.prototype.constructor = a.jqplot.PieTickRenderer })(jQuery); (function (a) { a.jqplot.PointLabels = function (b) { this.show = a.jqplot.config.enablePlugins; this.location = "n"; this.labelsFromSeries = false; this.seriesLabelIndex = null; this.labels = []; this._labels = []; this.stackedValue = false; this.ypadding = 6; this.xpadding = 6; this.escapeHTML = true; this.edgeTolerance = -5; this.formatter = a.jqplot.DefaultTickFormatter; this.formatString = ""; this.hideZeros = false; this._elems = []; a.extend(true, this, b) }; var b = ["nw", "n", "ne", "e", "se", "s", "sw", "w"]; var c = { nw: 0, n: 1, ne: 2, e: 3, se: 4, s: 5, sw: 6, w: 7 }; var d = ["se", "s", "sw", "w", "nw", "n", "ne", "e"]; a.jqplot.PointLabels.init = function (b, c, d, e, f) { var g = a.extend(true, {}, d, e); g.pointLabels = g.pointLabels || {}; if (this.renderer.constructor === a.jqplot.BarRenderer && this.barDirection === "horizontal" && !g.pointLabels.location) { g.pointLabels.location = "e" } this.plugins.pointLabels = new a.jqplot.PointLabels(g.pointLabels); this.plugins.pointLabels.setLabels.call(this) }; a.jqplot.PointLabels.prototype.setLabels = function () { var b = this.plugins.pointLabels; var c; if (b.seriesLabelIndex != null) { c = b.seriesLabelIndex } else if (this.renderer.constructor === a.jqplot.BarRenderer && this.barDirection === "horizontal") { c = 0 } else { c = this._plotData.length === 0 ? 0 : this._plotData[0].length - 1 } b._labels = []; if (b.labels.length === 0 || b.labelsFromSeries) { if (b.stackedValue) { if (this._plotData.length && this._plotData[0].length) { for (var d = 0; d < this._plotData.length; d++) { b._labels.push(this._plotData[d][c]) } } } else { var e = this._plotData; if (this.renderer.constructor === a.jqplot.BarRenderer && this.waterfall) { e = this._data } if (e.length && e[0].length) { for (var d = 0; d < e.length; d++) { b._labels.push(e[d][c]) } } e = null } } else if (b.labels.length) { b._labels = b.labels } }; a.jqplot.PointLabels.prototype.xOffset = function (a, b, c) { b = b || this.location; c = c || this.xpadding; var d; switch (b) { case "nw": d = -a.outerWidth(true) - this.xpadding; break; case "n": d = -a.outerWidth(true) / 2; break; case "ne": d = this.xpadding; break; case "e": d = this.xpadding; break; case "se": d = this.xpadding; break; case "s": d = -a.outerWidth(true) / 2; break; case "sw": d = -a.outerWidth(true) - this.xpadding; break; case "w": d = -a.outerWidth(true) - this.xpadding; break; default: d = -a.outerWidth(true) - this.xpadding; break } return d }; a.jqplot.PointLabels.prototype.yOffset = function (a, b, c) { b = b || this.location; c = c || this.xpadding; var d; switch (b) { case "nw": d = -a.outerHeight(true) - this.ypadding; break; case "n": d = -a.outerHeight(true) - this.ypadding; break; case "ne": d = -a.outerHeight(true) - this.ypadding; break; case "e": d = -a.outerHeight(true) / 2; break; case "se": d = this.ypadding; break; case "s": d = this.ypadding; break; case "sw": d = this.ypadding; break; case "w": d = -a.outerHeight(true) / 2; break; default: d = -a.outerHeight(true) - this.ypadding; break } return d }; a.jqplot.PointLabels.draw = function (b, e, f) { var g = this.plugins.pointLabels; g.setLabels.call(this); for (var h = 0; h < g._elems.length; h++) { g._elems[h].emptyForce() } g._elems.splice(0, g._elems.length); if (g.show) { var i = "_" + this._stackAxis + "axis"; if (!g.formatString) { g.formatString = this[i]._ticks[0].formatString; g.formatter = this[i]._ticks[0].formatter } var j = this._plotData; var k = this._xaxis; var l = this._yaxis; var m, n; for (var h = 0, o = g._labels.length; h < o; h++) { var p = g._labels[h]; if (g.hideZeros && parseInt(g._labels[h], 10) == 0) { p = "" } if (p != null) { p = g.formatter(g.formatString, p) } n = document.createElement("div"); g._elems[h] = a(n); m = g._elems[h]; m.addClass("jqplot-point-label jqplot-series-" + this.index + " jqplot-point-" + h); m.css("position", "absolute"); m.insertAfter(b.canvas); if (g.escapeHTML) { m.text(p) } else { m.html(p) } var q = g.location; if (this.fillToZero && j[h][1] < 0 || this.fillToZero && this._type === "bar" && this.barDirection === "horizontal" && j[h][0] < 0 || (this.waterfall && parseInt(p, 10)) < 0) { q = d[c[q]] } var r = k.u2p(j[h][0]) + g.xOffset(m, q); var s = l.u2p(j[h][1]) + g.yOffset(m, q); if (this.renderer.constructor == a.jqplot.BarRenderer) { if (this.barDirection == "vertical") { r += this._barNudge } else { s -= this._barNudge } } m.css("left", r); m.css("top", s); var t = r + m.width(); var u = s + m.height(); var v = g.edgeTolerance; var w = a(b.canvas).position().left; var x = a(b.canvas).position().top; var y = b.canvas.width + w; var z = b.canvas.height + x; if (r - v < w || s - v < x || t + v > y || u + v > z) { m.remove() } m = null; n = null } } }; a.jqplot.postSeriesInitHooks.push(a.jqplot.PointLabels.init); a.jqplot.postDrawSeriesHooks.push(a.jqplot.PointLabels.draw) })(jQuery); (function (a) { a.jqplot.PyramidAxisRenderer = function () { a.jqplot.LinearAxisRenderer.call(this) }; a.jqplot.PyramidAxisRenderer.prototype = new a.jqplot.LinearAxisRenderer; a.jqplot.PyramidAxisRenderer.prototype.constructor = a.jqplot.PyramidAxisRenderer; a.jqplot.PyramidAxisRenderer.prototype.init = function (b) { this.position = null; this.drawBaseline = true; this.baselineWidth = null; this.baselineColor = null; this.tickSpacingFactor = 25; this._type = "pyramid"; this._splitAxis = false; this._splitLength = null; this.category = false; this._autoFormatString = ""; this._overrideFormatString = false; a.extend(true, this, b); this.renderer.options = b; this.resetDataBounds = this.renderer.resetDataBounds; this.resetDataBounds() }; a.jqplot.PyramidAxisRenderer.prototype.resetDataBounds = function () { var a = this._dataBounds; a.min = null; a.max = null; var b; for (var c = 0; c < this._series.length; c++) { var d = this._series[c]; var e = d._plotData; for (var f = 0, g = e.length; f < g; f++) { if (this.name.charAt(0) === "x") { b = e[f][1]; if (b !== null && b < a.min || a.min === null) { a.min = b } if (b !== null && b > a.max || a.max === null) { a.max = b } } else { b = e[f][0]; if (b !== null && b < a.min || a.min === null) { a.min = b } if (b !== null && b > a.max || a.max === null) { a.max = b } } } } }; a.jqplot.PyramidAxisRenderer.prototype.draw = function (b, c) { if (this.show) { this.renderer.createTicks.call(this, c); var d = 0; var e; if (this._elem) { this._elem.emptyForce(); this._elem = null } this._elem = a(document.createElement("div")); this._elem.addClass("jqplot-axis jqplot-" + this.name); this._elem.css("position", "absolute"); if (this.name == "xaxis" || this.name == "x2axis") { this._elem.width(this._plotDimensions.width) } else { this._elem.height(this._plotDimensions.height) } this.labelOptions.axis = this.name; this._label = new this.labelRenderer(this.labelOptions); if (this._label.show) { var f = this._label.draw(b, c); f.appendTo(this._elem); f = null } var g = this._ticks; var h; for (var i = 0; i < g.length; i++) { h = g[i]; if (h.show && h.showLabel && !h.isMinorTick) { this._elem.append(h.draw(b, c)) } } h = null; g = null } return this._elem }; var b = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]; var c = {}; for (var d = 0, e = b.length; d < e; d++) { c[b[d]] = b[d] } a.jqplot.PyramidAxisRenderer.prototype.createTicks = function (b) { var d = this.ticks; var e = this._dataBounds; var f; var g; var h; var i; var j; var k; var l; var m; var n; var o; var p; var q = this.min; var r = this.max; var s; var t; var u; var v; var w; var x; var y; var z; var A; var B; var C = null; var D; if (d.length) { for (n = 0, o = d.length; n < o; n++) { s = d[n]; t = new this.tickRenderer(this.tickOptions); if (a.isArray(s)) { t.value = s[0]; t.label = s[1]; t.setTick(s[0], this.name); this._ticks.push(t) } else if (a.isPlainObject(s)) { a.extend(true, t, s); t.axis = this.name; this._ticks.push(t) } else { if (typeof s === "string") { B = n + b.defaultAxisStart } else { B = s } t.value = B; t.label = s; t.axis = this.name; this._ticks.push(t) } } this.numberTicks = d.length; this.min = this._ticks[0].value; this.max = this._ticks[this.numberTicks - 1].value; this.tickInterval = (this.max - this.min) / (this.numberTicks - 1); if (this._options.tickInterval) { var E = this._options.tickInterval; for (n = 0; n < this.numberTicks; n++) { if (n % E !== 0) { this._ticks[n].isMinorTick = true } } } else { f = this.name.charAt(0) === "x" ? this._plotDimensions.width : this._plotDimensions.height; A = Math.round(2 + f / this.tickSpacingFactor); if (this.numberTicks > A) { D = this.numberTicks - 1; for (n = 2; n < D; n++) { if (D % n === 0 && D / n < A) { C = n - 1; break } } if (C !== null) { var F = 1; for (n = 1, o = this._ticks.length; n < o; n++) { if (F <= C) { this._ticks[n].show = false; F += 1 } else { F = 1 } } } } } D = []; if (this.category) { this._ticks[0].showGridline = false; this._ticks[0].showMark = false; for (n = this._ticks.length - 1; n > 0; n--) { t = new this.tickRenderer(this.tickOptions); t.value = this._ticks[n - 1].value + this.tickInterval / 2; t.label = ""; t.showLabel = false; t.axis = this.name; this._ticks[n].showGridline = false; this._ticks[n].showMark = false; this._ticks.splice(n, 0, t) } t = new this.tickRenderer(this.tickOptions); t.value = this._ticks[0].value - this.tickInterval / 2; t.label = ""; t.showLabel = false; t.axis = this.name; this._ticks.unshift(t); t = new this.tickRenderer(this.tickOptions); t.value = this._ticks[this._ticks.length - 1].value + this.tickInterval / 2; t.label = ""; t.showLabel = false; t.axis = this.name; this._ticks.push(t); this.tickInterval = this.tickInterval / 2; this.numberTicks = this._ticks.length; this.min = this._ticks[0].value; this.max = this._ticks[this._ticks.length - 1].value } } else { if (this.name.charAt(0) === "x") { f = this._plotDimensions.width; var G = Math.max(e.max, Math.abs(e.min)); var H = Math.min(e.min, -G); h = H; i = G; j = i - h; if (this.tickOptions == null || !this.tickOptions.formatString) { this._overrideFormatString = true } u = 30; v = Math.max(f, u + 1); w = (v - u) / 300; x = a.jqplot.LinearTickGenerator(h, i, w); console.log(h, i, w, x); console.log(x[0].toString(), x[1].toString()); y = h + j * (this.padMin - 1); z = i - j * (this.padMax - 1); if (h < y || i > z) { y = h - j * (this.padMin - 1); z = i + j * (this.padMax - 1); x = a.jqplot.LinearTickGenerator(y, z, w); console.log(y, z, w, x) } this.min = x[0]; this.max = x[1]; this.numberTicks = x[2]; this._autoFormatString = x[3]; this.tickInterval = x[4] } else { f = this._plotDimensions.height; h = e.min; i = e.max; p = this._series[0]; this._ticks = []; j = i - h; if (c[j]) { j += 1; i += 1 } this.max = i; this.min = h; A = Math.round(2 + f / this.tickSpacingFactor); if (j + 1 <= A) { this.numberTicks = j + 1; this.tickInterval = 1 } else { for (var n = A; n > 1; n--) { if (j / (n - 1) === Math.round(j / (n - 1))) { this.numberTicks = n; this.tickInterval = j / (n - 1); break } } } } if (this._overrideFormatString && this._autoFormatString != "") { this.tickOptions = this.tickOptions || {}; this.tickOptions.formatString = this._autoFormatString } var I; for (n = 0; n < this.numberTicks; n++) { this.tickOptions.axis = this.name; I = this.min + this.tickInterval * n; if (this.name.charAt(0) === "x") { I = Math.abs(I) } this.tickOptions.value = this.min + this.tickInterval * n; t = new this.tickRenderer(this.tickOptions); t.label = t.prefix + t.formatter(t.formatString, I); this._ticks.push(t); if (this.name.charAt(0) === "x" && b.axes.yMidAxis.show && this.tickOptions.value === 0) { this._splitAxis = true; this._splitLength = b.axes.yMidAxis.getWidth(); t = new this.tickRenderer(this.tickOptions); this._ticks.push(t); t.value = this.max / 2e3 } } t = null } }; a.jqplot.PyramidAxisRenderer.prototype.set = function () { var b = 0; var c; var d = 0; var f = 0; var g; var h; var i; var j = this._label == null ? false : this._label.show; if (this.show) { h = this._ticks; e = h.length; for (g = 0; g < e; g++) { i = h[g]; if (!i._breakTick && i.show && i.showLabel && !i.isMinorTick) { if (this.name.charAt(0) === "x") { c = i._elem.outerHeight(true) } else { c = i._elem.outerWidth(true) } if (c > b) { b = c } } } if (this.name === "yMidAxis") { for (g = 0; g < e; g++) { i = h[g]; if (i._elem) { c = (b - i._elem.outerWidth(true)) / 2; i._elem.css("left", c) } } } i = null; h = null; if (j) { d = this._label._elem.outerWidth(true); f = this._label._elem.outerHeight(true) } if (this.name === "xaxis") { b = b + f; this._elem.css({ height: b + "px", left: "0px", bottom: "0px" }) } else if (this.name === "x2axis") { b = b + f; this._elem.css({ height: b + "px", left: "0px", top: "0px" }) } else if (this.name === "yaxis") { b = b + d; this._elem.css({ width: b + "px", left: "0px", top: "0px" }); if (j && this._label.constructor == a.jqplot.AxisLabelRenderer) { this._label._elem.css("width", d + "px") } } else if (this.name === "yMidAxis") { var c = b / 2 - d / 2; this._elem.css({ width: b + "px", top: "0px" }); if (j && this._label.constructor == a.jqplot.AxisLabelRenderer) { this._label._elem.css({ width: d, left: c, top: 0 }) } } else { b = b + d; this._elem.css({ width: b + "px", right: "0px", top: "0px" }); if (j && this._label.constructor == a.jqplot.AxisLabelRenderer) { this._label._elem.css("width", d + "px") } } } }; a.jqplot.PyramidAxisRenderer.prototype.pack = function (b, c) { b = b || {}; c = c || this._offsets; var d = this._ticks; var e = this.max; var f = this.min; var g = c.max; var h = c.min; var i = this._label == null ? false : this._label.show; for (var j in b) { this._elem.css(j, b[j]) } this._offsets = c; var k = g - h; var l = e - f; var m = this._splitLength; if (this._splitAxis) { k -= this._splitLength; this.p2u = function (a) { return (a - h) * l / k + f }; this.u2p = function (a) { if (a <= 0) { return (a - f) * k / l + h } else { return (a - f) * k / l + h + m } }; this.series_u2p = function (a) { if (a <= 0) { return (a - f) * k / l } else { return (a - f) * k / l + m } }; this.series_p2u = function (a) { return a * l / k + f } } else { this.p2u = function (a) { return (a - h) * l / k + f }; this.u2p = function (a) { return (a - f) * k / l + h }; if (this.name.charAt(0) === "x") { this.series_u2p = function (a) { return (a - f) * k / l }; this.series_p2u = function (a) { return a * l / k + f } } else { this.series_u2p = function (a) { return (a - e) * k / l }; this.series_p2u = function (a) { return a * l / k + e } } } if (this.show) { if (this.name.charAt(0) === "x") { for (var n = 0; n < d.length; n++) { var o = d[n]; if (o.show && o.showLabel) { var p; if (o.constructor == a.jqplot.CanvasAxisTickRenderer && o.angle) { var q = this.name == "xaxis" ? 1 : -1; switch (o.labelPosition) { case "auto": if (q * o.angle < 0) { p = -o.getWidth() + o._textRenderer.height * Math.sin(-o._textRenderer.angle) / 2 } else { p = -o._textRenderer.height * Math.sin(o._textRenderer.angle) / 2 } break; case "end": p = -o.getWidth() + o._textRenderer.height * Math.sin(-o._textRenderer.angle) / 2; break; case "start": p = -o._textRenderer.height * Math.sin(o._textRenderer.angle) / 2; break; case "middle": p = -o.getWidth() / 2 + o._textRenderer.height * Math.sin(-o._textRenderer.angle) / 2; break; default: p = -o.getWidth() / 2 + o._textRenderer.height * Math.sin(-o._textRenderer.angle) / 2; break } } else { p = -o.getWidth() / 2 } var r = this.u2p(o.value) + p + "px"; o._elem.css("left", r); o.pack() } } if (i) { var s = this._label._elem.outerWidth(true); this._label._elem.css("left", h + k / 2 - s / 2 + "px"); if (this.name == "xaxis") { this._label._elem.css("bottom", "0px") } else { this._label._elem.css("top", "0px") } this._label.pack() } } else { for (var n = 0; n < d.length; n++) { var o = d[n]; if (o.show && o.showLabel && !o.isMinorTick) { var p; if (o.constructor == a.jqplot.CanvasAxisTickRenderer && o.angle) { var q = this.name == "yaxis" ? 1 : -1; switch (o.labelPosition) { case "auto": case "end": if (q * o.angle < 0) { p = -o._textRenderer.height * Math.cos(-o._textRenderer.angle) / 2 } else { p = -o.getHeight() + o._textRenderer.height * Math.cos(o._textRenderer.angle) / 2 } break; case "start": if (o.angle > 0) { p = -o._textRenderer.height * Math.cos(-o._textRenderer.angle) / 2 } else { p = -o.getHeight() + o._textRenderer.height * Math.cos(o._textRenderer.angle) / 2 } break; case "middle": p = -o.getHeight() / 2; break; default: p = -o.getHeight() / 2; break } } else { p = -o.getHeight() / 2 } var r = this.u2p(o.value) + p + "px"; o._elem.css("top", r); o.pack() } } if (i) { var t = this._label._elem.outerHeight(true); if (this.name !== "yMidAxis") { this._label._elem.css("top", g - k / 2 - t / 2 + "px") } if (this.name == "yaxis") { this._label._elem.css("left", "0px") } else if (this.name !== "yMidAxis") { this._label._elem.css("right", "0px") } this._label.pack() } } } d = null } })(jQuery); (function (a) { a.jqplot.PyramidGridRenderer = function () { a.jqplot.CanvasGridRenderer.call(this) }; a.jqplot.PyramidGridRenderer.prototype = new a.jqplot.CanvasGridRenderer; a.jqplot.PyramidGridRenderer.prototype.constructor = a.jqplot.PyramidGridRenderer; a.jqplot.CanvasGridRenderer.prototype.init = function (b) { this._ctx; this.plotBands = { show: false, color: "rgb(230, 219, 179)", axis: "y", start: null, interval: 10 }; a.extend(true, this, b); var c = { lineJoin: "miter", lineCap: "round", fill: false, isarc: false, angle: this.shadowAngle, offset: this.shadowOffset, alpha: this.shadowAlpha, depth: this.shadowDepth, lineWidth: this.shadowWidth, closePath: false, strokeStyle: this.shadowColor }; this.renderer.shadowRenderer.init(c) }; a.jqplot.PyramidGridRenderer.prototype.draw = function () { function C(c, d, e, f, g) { b.save(); g = g || {}; if (g.lineWidth == null || g.lineWidth != 0) { a.extend(true, b, g); b.beginPath(); b.moveTo(c, d); b.lineTo(e, f); b.stroke() } b.restore() } this._ctx = this._elem.get(0).getContext("2d"); var b = this._ctx; var c = this._axes; var d = c.xaxis.u2p; var e = c.yMidAxis.u2p; var f = c.xaxis.max / 1e3; var g = d(0); var h = d(f); var i = ["xaxis", "yaxis", "x2axis", "y2axis", "yMidAxis"]; b.save(); b.clearRect(0, 0, this._plotDimensions.width, this._plotDimensions.height); b.fillStyle = this.backgroundColor || this.background; b.fillRect(this._left, this._top, this._width, this._height); if (this.plotBands.show) { b.save(); var j = this.plotBands; b.fillStyle = j.color; var k; var l, m, n, o; if (j.axis.charAt(0) === "x") { if (c.xaxis.show) { k = c.xaxis } } else if (j.axis.charAt(0) === "y") { if (c.yaxis.show) { k = c.yaxis } else if (c.y2axis.show) { k = c.y2axis } else if (c.yMidAxis.show) { k = c.yMidAxis } } if (k !== undefined) { var p = j.start; if (p === null) { p = k.min } for (var q = p; q < k.max; q += 2 * j.interval) { if (k.name.charAt(0) === "y") { l = this._left; m = k.series_u2p(q + j.interval) + this._top; n = this._right - this._left; o = k.series_u2p(p) - k.series_u2p(p + j.interval); b.fillRect(l, m, n, o) } } } b.restore() } b.save(); b.lineJoin = "miter"; b.lineCap = "butt"; b.lineWidth = this.gridLineWidth; b.strokeStyle = this.gridLineColor; var r, s, t, u; for (var q = 5; q > 0; q--) { var v = i[q - 1]; var k = c[v]; var w = k._ticks; var x = w.length; if (k.show) { if (k.drawBaseline) { var y = {}; if (k.baselineWidth !== null) { y.lineWidth = k.baselineWidth } if (k.baselineColor !== null) { y.strokeStyle = k.baselineColor } switch (v) { case "xaxis": if (c.yMidAxis.show) { C(this._left, this._bottom, g, this._bottom, y); C(h, this._bottom, this._right, this._bottom, y) } else { C(this._left, this._bottom, this._right, this._bottom, y) } break; case "yaxis": C(this._left, this._bottom, this._left, this._top, y); break; case "yMidAxis": C(g, this._bottom, g, this._top, y); C(h, this._bottom, h, this._top, y); break; case "x2axis": if (c.yMidAxis.show) { C(this._left, this._top, g, this._top, y); C(h, this._top, this._right, this._top, y) } else { C(this._left, this._bottom, this._right, this._bottom, y) } break; case "y2axis": C(this._right, this._bottom, this._right, this._top, y); break } } for (var z = x; z > 0; z--) { var A = w[z - 1]; if (A.show) { var B = Math.round(k.u2p(A.value)) + .5; switch (v) { case "xaxis": if (A.showGridline && this.drawGridlines && (!A.isMinorTick || k.showMinorTicks)) { C(B, this._top, B, this._bottom) } if (A.showMark && A.mark && (!A.isMinorTick || k.showMinorTicks)) { t = A.markSize; u = A.mark; var B = Math.round(k.u2p(A.value)) + .5; switch (u) { case "outside": r = this._bottom; s = this._bottom + t; break; case "inside": r = this._bottom - t; s = this._bottom; break; case "cross": r = this._bottom - t; s = this._bottom + t; break; default: r = this._bottom; s = this._bottom + t; break } if (this.shadow) { this.renderer.shadowRenderer.draw(b, [[B, r], [B, s]], { lineCap: "butt", lineWidth: this.gridLineWidth, offset: this.gridLineWidth * .75, depth: 2, fill: false, closePath: false }) } C(B, r, B, s) } break; case "yaxis": if (A.showGridline && this.drawGridlines && (!A.isMinorTick || k.showMinorTicks)) { C(this._right, B, this._left, B) } if (A.showMark && A.mark && (!A.isMinorTick || k.showMinorTicks)) { t = A.markSize; u = A.mark; var B = Math.round(k.u2p(A.value)) + .5; switch (u) { case "outside": r = this._left - t; s = this._left; break; case "inside": r = this._left; s = this._left + t; break; case "cross": r = this._left - t; s = this._left + t; break; default: r = this._left - t; s = this._left; break } if (this.shadow) { this.renderer.shadowRenderer.draw(b, [[r, B], [s, B]], { lineCap: "butt", lineWidth: this.gridLineWidth * 1.5, offset: this.gridLineWidth * .75, fill: false, closePath: false }) } C(r, B, s, B, { strokeStyle: k.borderColor }) } break; case "yMidAxis": if (A.showGridline && this.drawGridlines && (!A.isMinorTick || k.showMinorTicks)) { C(this._left, B, g, B); C(h, B, this._right, B) } if (A.showMark && A.mark && (!A.isMinorTick || k.showMinorTicks)) { t = A.markSize; u = A.mark; var B = Math.round(k.u2p(A.value)) + .5; r = g; s = g + t; if (this.shadow) { this.renderer.shadowRenderer.draw(b, [[r, B], [s, B]], { lineCap: "butt", lineWidth: this.gridLineWidth * 1.5, offset: this.gridLineWidth * .75, fill: false, closePath: false }) } C(r, B, s, B, { strokeStyle: k.borderColor }); r = h - t; s = h; if (this.shadow) { this.renderer.shadowRenderer.draw(b, [[r, B], [s, B]], { lineCap: "butt", lineWidth: this.gridLineWidth * 1.5, offset: this.gridLineWidth * .75, fill: false, closePath: false }) } C(r, B, s, B, { strokeStyle: k.borderColor }) } break; case "x2axis": if (A.showGridline && this.drawGridlines && (!A.isMinorTick || k.showMinorTicks)) { C(B, this._bottom, B, this._top) } if (A.showMark && A.mark && (!A.isMinorTick || k.showMinorTicks)) { t = A.markSize; u = A.mark; var B = Math.round(k.u2p(A.value)) + .5; switch (u) { case "outside": r = this._top - t; s = this._top; break; case "inside": r = this._top; s = this._top + t; break; case "cross": r = this._top - t; s = this._top + t; break; default: r = this._top - t; s = this._top; break } if (this.shadow) { this.renderer.shadowRenderer.draw(b, [[B, r], [B, s]], { lineCap: "butt", lineWidth: this.gridLineWidth, offset: this.gridLineWidth * .75, depth: 2, fill: false, closePath: false }) } C(B, r, B, s) } break; case "y2axis": if (A.showGridline && this.drawGridlines && (!A.isMinorTick || k.showMinorTicks)) { C(this._left, B, this._right, B) } if (A.showMark && A.mark && (!A.isMinorTick || k.showMinorTicks)) { t = A.markSize; u = A.mark; var B = Math.round(k.u2p(A.value)) + .5; switch (u) { case "outside": r = this._right; s = this._right + t; break; case "inside": r = this._right - t; s = this._right; break; case "cross": r = this._right - t; s = this._right + t; break; default: r = this._right; s = this._right + t; break } if (this.shadow) { this.renderer.shadowRenderer.draw(b, [[r, B], [s, B]], { lineCap: "butt", lineWidth: this.gridLineWidth * 1.5, offset: this.gridLineWidth * .75, fill: false, closePath: false }) } C(r, B, s, B, { strokeStyle: k.borderColor }) } break; default: break } } } A = null } k = null; w = null } b.restore(); if (this.shadow) { if (c.yMidAxis.show) { var D = [[this._left, this._bottom], [g, this._bottom]]; this.renderer.shadowRenderer.draw(b, D); var D = [[h, this._bottom], [this._right, this._bottom], [this._right, this._top]]; this.renderer.shadowRenderer.draw(b, D); var D = [[g, this._bottom], [g, this._top]]; this.renderer.shadowRenderer.draw(b, D) } else { var D = [[this._left, this._bottom], [this._right, this._bottom], [this._right, this._top]]; this.renderer.shadowRenderer.draw(b, D) } } if (this.borderWidth != 0 && this.drawBorder) { if (c.yMidAxis.show) { C(this._left, this._top, g, this._top, { lineCap: "round", strokeStyle: c.x2axis.borderColor, lineWidth: c.x2axis.borderWidth }); C(h, this._top, this._right, this._top, { lineCap: "round", strokeStyle: c.x2axis.borderColor, lineWidth: c.x2axis.borderWidth }); C(this._right, this._top, this._right, this._bottom, { lineCap: "round", strokeStyle: c.y2axis.borderColor, lineWidth: c.y2axis.borderWidth }); C(this._right, this._bottom, h, this._bottom, { lineCap: "round", strokeStyle: c.xaxis.borderColor, lineWidth: c.xaxis.borderWidth }); C(g, this._bottom, this._left, this._bottom, { lineCap: "round", strokeStyle: c.xaxis.borderColor, lineWidth: c.xaxis.borderWidth }); C(this._left, this._bottom, this._left, this._top, { lineCap: "round", strokeStyle: c.yaxis.borderColor, lineWidth: c.yaxis.borderWidth }); C(g, this._bottom, g, this._top, { lineCap: "round", strokeStyle: c.yaxis.borderColor, lineWidth: c.yaxis.borderWidth }); C(h, this._bottom, h, this._top, { lineCap: "round", strokeStyle: c.yaxis.borderColor, lineWidth: c.yaxis.borderWidth }) } else { C(this._left, this._top, this._right, this._top, { lineCap: "round", strokeStyle: c.x2axis.borderColor, lineWidth: c.x2axis.borderWidth }); C(this._right, this._top, this._right, this._bottom, { lineCap: "round", strokeStyle: c.y2axis.borderColor, lineWidth: c.y2axis.borderWidth }); C(this._right, this._bottom, this._left, this._bottom, { lineCap: "round", strokeStyle: c.xaxis.borderColor, lineWidth: c.xaxis.borderWidth }); C(this._left, this._bottom, this._left, this._top, { lineCap: "round", strokeStyle: c.yaxis.borderColor, lineWidth: c.yaxis.borderWidth }) } } b.restore(); b = null; c = null } })(jQuery); (function (a) { function f(a, b, c, f, g) { if (f) { var h = [f.seriesIndex, f.pointIndex, f.data]; var i = jQuery.Event("jqplotDataMouseOver"); i.pageX = a.pageX; i.pageY = a.pageY; g.target.trigger(i, h); if (g.series[h[0]].highlightMouseOver && !(h[0] == g.plugins.pyramidRenderer.highlightedSeriesIndex && h[1] == g.series[h[0]]._highlightedPoint)) { var j = jQuery.Event("jqplotDataHighlight"); j.pageX = a.pageX; j.pageY = a.pageY; g.target.trigger(j, h); d(g, f.seriesIndex, f.pointIndex, f.points) } } else if (f == null) { e(g) } } function e(a) { var b = a.plugins.pyramidRenderer.highlightCanvas; b._ctx.clearRect(0, 0, b._ctx.canvas.width, b._ctx.canvas.height); for (var c = 0; c < a.series.length; c++) { a.series[c]._highlightedPoint = null } a.plugins.pyramidRenderer.highlightedSeriesIndex = null; a.target.trigger("jqplotDataUnhighlight"); b = null } function d(a, b, c, d) { var e = a.series[b]; var f = a.plugins.pyramidRenderer.highlightCanvas; f._ctx.clearRect(0, 0, f._ctx.canvas.width, f._ctx.canvas.height); e._highlightedPoint = c; a.plugins.pyramidRenderer.highlightedSeriesIndex = b; var g = { fillStyle: e.highlightColors[c], fillRect: false }; e.renderer.shapeRenderer.draw(f._ctx, d, g); f = null } function c() { if (this.plugins.pyramidRenderer && this.plugins.pyramidRenderer.highlightCanvas) { this.plugins.pyramidRenderer.highlightCanvas.resetCanvas(); this.plugins.pyramidRenderer.highlightCanvas = null } this.plugins.pyramidRenderer = { highlightedSeriesIndex: null }; this.plugins.pyramidRenderer.highlightCanvas = new a.jqplot.GenericCanvas; this.eventCanvas._elem.before(this.plugins.pyramidRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-pyramidRenderer-highlight-canvas", this._plotDimensions, this)); this.plugins.pyramidRenderer.highlightCanvas.setContext(); this.eventCanvas._elem.bind("mouseleave", { plot: this }, function (a) { e(a.data.plot) }) } function b(b, c, d) { d = d || {}; d.axesDefaults = d.axesDefaults || {}; d.grid = d.grid || {}; d.legend = d.legend || {}; d.seriesDefaults = d.seriesDefaults || {}; var e = false; if (d.seriesDefaults.renderer === a.jqplot.PyramidRenderer) { e = true } else if (d.series) { for (var f = 0; f < d.series.length; f++) { if (d.series[f].renderer === a.jqplot.PyramidRenderer) { e = true } } } if (e) { d.axesDefaults.renderer = a.jqplot.PyramidAxisRenderer; d.grid.renderer = a.jqplot.PyramidGridRenderer; d.seriesDefaults.pointLabels = { show: false} } } if (a.jqplot.PyramidAxisRenderer === undefined) { a.ajax({ url: a.jqplot.pluginLocation + "jqplot.pyramidAxisRenderer.js", dataType: "script", async: false }) } if (a.jqplot.PyramidGridRenderer === undefined) { a.ajax({ url: a.jqplot.pluginLocation + "jqplot.pyramidGridRenderer.js", dataType: "script", async: false }) } a.jqplot.PyramidRenderer = function () { a.jqplot.LineRenderer.call(this) }; a.jqplot.PyramidRenderer.prototype = new a.jqplot.LineRenderer; a.jqplot.PyramidRenderer.prototype.constructor = a.jqplot.PyramidRenderer; a.jqplot.PyramidRenderer.prototype.init = function (b, d) { b = b || {}; this._type = "pyramid"; this.barPadding = 10; this.barWidth = null; this.fill = true; this.highlightMouseOver = true; this.highlightMouseDown = false; this.highlightColors = []; this.offsetBars = false; if (b.highlightMouseDown && b.highlightMouseOver == null) { b.highlightMouseOver = false } this.side = "right"; a.extend(true, this, b); this.renderer.options = b; this._highlightedPoint = null; this._dataColors = []; this._barPoints = []; this.fillAxis = "y"; this._primaryAxis = "_yaxis"; this._xnudge = 0; var e = { lineJoin: "miter", lineCap: "butt", fill: this.fill, fillRect: this.fill, isarc: false, strokeStyle: this.color, fillStyle: this.color, closePath: this.fill, lineWidth: this.lineWidth }; this.renderer.shapeRenderer.init(e); var g = b.shadowOffset; if (g == null) { if (this.lineWidth > 2.5) { g = 1.25 * (1 + (Math.atan(this.lineWidth / 2.5) / .785398163 - 1) * .6) } else { g = 1.25 * Math.atan(this.lineWidth / 2.5) / .785398163 } } var h = { lineJoin: "miter", lineCap: "butt", fill: this.fill, fillRect: this.fill, isarc: false, angle: this.shadowAngle, offset: g, alpha: this.shadowAlpha, depth: this.shadowDepth, closePath: this.fill, lineWidth: this.lineWidth }; this.renderer.shadowRenderer.init(h); d.postDrawHooks.addOnce(c); d.eventListenerHooks.addOnce("jqplotMouseMove", f); if (this.side === "left") { for (var i = 0, j = this.data.length; i < j; i++) { this.data[i][1] = -Math.abs(this.data[i][1]) } } }; a.jqplot.PyramidRenderer.prototype.setGridData = function (a) { var b = this._xaxis.series_u2p; var c = this._yaxis.series_u2p; var d = this._plotData; var e = this._prevPlotData; this.gridData = []; this._prevGridData = []; var f = d.length; var g = false; var h; for (h = 0; h < f; h++) { if (d[h][1] < 0) { this.side = "left" } } if (this._yaxis.name === "yMidAxis" && this.side === "right") { this._xnudge = this._xaxis.max / 2e3; g = true } for (h = 0; h < f; h++) { if (d[h][0] != null && d[h][1] != null) { this.gridData.push([b(d[h][1]), c(d[h][0])]) } else if (d[h][0] == null) { this.gridData.push([b(d[h][1]), null]) } else if (d[h][1] == null) { this.gridData.push(null, [c(d[h][0])]) } if (d[h][1] === 0 && g) { this.gridData[h][0] = b(this._xnudge) } } }; a.jqplot.PyramidRenderer.prototype.makeGridData = function (a, b) { var c = this._xaxis.series_u2p; var d = this._yaxis.series_u2p; var e = []; var f = a.length; var g = false; var h; for (h = 0; h < f; h++) { if (a[h][1] < 0) { this.side = "left" } } if (this._yaxis.name === "yMidAxis" && this.side === "right") { this._xnudge = this._xaxis.max / 2e3; g = true } for (h = 0; h < f; h++) { if (a[h][0] != null && a[h][1] != null) { e.push([c(a[h][1]), d(a[h][0])]) } else if (a[h][0] == null) { e.push([c(a[h][1]), null]) } else if (a[h][1] == null) { e.push([null, d(a[h][0])]) } if (a[h][1] === 0 && g) { e[h][0] = c(this._xnudge) } } return e }; a.jqplot.PyramidRenderer.prototype.setBarWidth = function () { var a; var b = 0; var c = 0; var d = this[this._primaryAxis]; var e, f, g; b = d.max - d.min; var h = d.numberTicks; var i = (h - 1) / 2; var j = this.barPadding === 0 ? 1 : 0; if (d.name == "xaxis" || d.name == "x2axis") { this.barWidth = (d._offsets.max - d._offsets.min) / b - this.barPadding + j } else { if (this.fill) { this.barWidth = (d._offsets.min - d._offsets.max) / b - this.barPadding + j } else { this.barWidth = (d._offsets.min - d._offsets.max) / b } } }; a.jqplot.PyramidRenderer.prototype.draw = function (b, c, d) { var e; var f = a.extend({}, d); var g = f.shadow != undefined ? f.shadow : this.shadow; var h = f.showLine != undefined ? f.showLine : this.showLine; var i = f.fill != undefined ? f.fill : this.fill; var j = this._xaxis.series_u2p; var k = this._yaxis.series_u2p; var l, m; this._dataColors = []; this._barPoints = []; if (this.renderer.options.barWidth == null) { this.renderer.setBarWidth.call(this) } var n = [], o, p; if (h) { var q = new a.jqplot.ColorGenerator(this.negativeSeriesColors); var r = new a.jqplot.ColorGenerator(this.seriesColors); var s = q.get(this.index); if (!this.useNegativeColors) { s = f.fillStyle } var t = f.fillStyle; var u; var v = this._xaxis.series_u2p(this._xnudge); var w = this._yaxis.series_u2p(this._yaxis.min); var x = this._yaxis.series_u2p(this._yaxis.max); var y = this.barWidth; var z = y / 2; var n = []; var A = this.offsetBars ? z : 0; for (var e = 0, B = c.length; e < B; e++) { if (this.data[e][0] == null) { continue } u = c[e][1]; if (this._plotData[e][1] < 0) { if (this.varyBarColor && !this._stack) { if (this.useNegativeColors) { f.fillStyle = q.next() } else { f.fillStyle = r.next() } } } else { if (this.varyBarColor && !this._stack) { f.fillStyle = r.next() } else { f.fillStyle = t } } if (this.fill) { if (this._plotData[e][1] >= 0) { o = c[e][0] - v; p = this.barWidth; n = [v, u - z - A, o, p] } else { o = v - c[e][0]; p = this.barWidth; n = [c[e][0], u - z - A, o, p] } this._barPoints.push([[n[0], n[1] + p], [n[0], n[1]], [n[0] + o, n[1]], [n[0] + o, n[1] + p]]); if (g) { this.renderer.shadowRenderer.draw(b, n) } var C = f.fillStyle || this.color; this._dataColors.push(C); this.renderer.shapeRenderer.draw(b, n, f) } else { if (e === 0) { n = [[v, w], [c[e][0], w], [c[e][0], c[e][1] - z - A]] } else if (e < B - 1) { n = n.concat([[c[e - 1][0], c[e - 1][1] - z - A], [c[e][0], c[e][1] + z - A], [c[e][0], c[e][1] - z - A]]) } else { n = n.concat([[c[e - 1][0], c[e - 1][1] - z - A], [c[e][0], c[e][1] + z - A], [c[e][0], x], [v, x]]); if (g) { this.renderer.shadowRenderer.draw(b, n) } var C = f.fillStyle || this.color; this._dataColors.push(C); this.renderer.shapeRenderer.draw(b, n, f) } } } } if (this.highlightColors.length == 0) { this.highlightColors = a.jqplot.computeHighlightColors(this._dataColors) } else if (typeof this.highlightColors == "string") { this.highlightColors = []; for (var e = 0; e < this._dataColors.length; e++) { this.highlightColors.push(this.highlightColors) } } }; a.jqplot.preInitHooks.push(b) })(jQuery); (function (a) { function h(a, b) { var c = b == null ? "linear" : b; var d; var e; var h = []; var i = []; var j = []; for (k = 0; k < a.length; k++) { if (a[k] != null && a[k][0] != null && a[k][1] != null) { h.push(a[k][0]); i.push(a[k][1]) } } if (c == "linear") { d = f(h, i); for (var k = 0; k < h.length; k++) { e = d[0] * h[k] + d[1]; j.push([h[k], e]) } } else if (c == "exp" || c == "exponential") { d = g(h, i); for (var k = 0; k < h.length; k++) { e = d[1] * Math.pow(d[0], h[k]); j.push([h[k], e]) } } return { data: j, slope: d[0], intercept: d[1]} } function g(a, b) { var c; var d = a; var f = b; c = e(d, f, "exp"); var g = Math.exp(c[0]); var h = Math.exp(c[1]); return [g, h] } function f(a, b) { var c; c = e(a, b, "linear"); return [c[0], c[1]] } function e(a, b, c) { var d = c == null ? "linear" : c; var e = a.length; var f; var g; var h = 0; var i = 0; var j = 0; var k = 0; var l = 0; var m = []; var n = []; if (d == "linear") { n = a; m = b } else if (d == "exp" || d == "exponential") { for (var o = 0; o < b.length; o++) { if (b[o] <= 0) { e-- } else { n.push(a[o]); m.push(Math.log(b[o])) } } } for (var o = 0; o < e; o++) { h = h + n[o]; i = i + m[o]; k = k + n[o] * m[o]; j = j + n[o] * n[o]; l = l + m[o] * m[o] } f = (e * k - h * i) / (e * j - h * h); g = (i - f * h) / e; return [f, g] } function d(b, c) { c = a.extend(true, {}, this.trendline, c); if (this.trendline && c.show) { var d; var e = c.data || this.data; d = h(e, this.trendline.type); var f = c.gridData || this.renderer.makeGridData.call(this, d.data); this.trendline.renderer.draw.call(this.trendline, b, f, { showLine: true, shadow: this.trendline.shadow }) } } function c(b, c, d, e, f) { if (this._type && (this._type === "line" || this._type == "bar")) { this.trendline = new a.jqplot.Trendline; e = e || {}; a.extend(true, this.trendline, { color: this.color }, d.trendline, e.trendline); this.trendline.renderer.init.call(this.trendline, null) } } function b(a) { var b = null; if (a.trendline && a.trendline.show) { var c = a.trendline.label.toString(); if (c) { b = { label: c, color: a.trendline.color} } } return b } a.jqplot.Trendline = function () { this.show = a.jqplot.config.enablePlugins; this.color = "#666666"; this.renderer = new a.jqplot.LineRenderer; this.rendererOptions = { marker: { show: false} }; this.label = ""; this.type = "linear"; this.shadow = true; this.markerRenderer = { show: false }; this.lineWidth = 1.5; this.shadowAngle = 45; this.shadowOffset = 1; this.shadowAlpha = .07; this.shadowDepth = 3; this.isTrendline = true }; a.jqplot.postSeriesInitHooks.push(c); a.jqplot.postDrawSeriesHooks.push(d); a.jqplot.addLegendRowHooks.push(b) })(jQuery)